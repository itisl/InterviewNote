## 指针
a. 常量指针
int *const p = &n;//p的值不能改变，*p可以改变，顶层const
b. 指向常量的指针
const int *p = &n;//p的值可以改变，不能通过*p改变n，底层const
int const *p = &n;//同上
c. 指针的类型必须与所指对象的类型一致。两个例外：
a. 可以用指向常量的指针指向非常量对象
int n = 0;
const int *p = &n;//n的值可以改变，但是不能通过指针*p修改
b. 向上转型（派生类指针赋值给基类指针）
d. 区别指针类型和所指对象的类型
    1 unsigned int i = 0xfffffff7;
    2 char *p = (char*)&i;
    3 printf("%x\n", *p);//输出结果fffffff7
指针类型对指针的运算产生影响，不会影响指针指向对象的大小
e. const在多个文件中使用
定义时使用extern关键字，在其他文件中也使用extern声明

## 引用
1. 左值引用:
a. 引用`&`是标识符的别名：
int &name = data;
1) 定义引用时，必须进行初始化，使其指向已存在的对象，引用被初始化后，就不能指向其他对象（常量指针）
2) 引用/指针作为函数参数或返回值，需要的内存较小，可以提高程序的效率
3) 如果不希望通过引用来修改原始的数据，那么可以在定义时添加 const 限制：const type &name = value;
或type const &name = value;
1) 引用本身不是对象，不能定义引用的引用，不能给引用绑定常量值（对const的引用“常量引用”可以绑定到常量、表达式）
注意	引用在定义时需要添加&，在使用时不能添加&。&表示取地址。
b. 引用作为函数参数
引用传参可以传地址，形式上比指针更加直观
```cpp
void swap(int& a,int& b){
    int temp = a;
    a = b;
    b = temp;
}
```
c. 引用作为函数返回值
注意：不可返回局部数据的引用

```cpp
int &plus(int &n){
    n += 10;
    return n;//不需要&
};
```

d. 指针的引用（从右往左阅读）：
int *&pnum = p; 
//离变量名最近的符号是变量的类型（引用），其余部分确定引用的类型
2. 右值引用：所引用对象为临时对象
a. 声明:
T &&rr {f()};  // 列表初始化
T &&rr = f();
b. 用途：判断对象为临时对象(指针，包括函数返回值，未命名的自由空间)后，可以用廉价的移动操作代替拷贝操作(浅拷贝)
c. std::move()
等价于static_cast<T&&>() , 将左值强制转换为右值
d. std::forward() 将右值转换成左值，实现同上
## 指针与引用
![20190821152058.png](https://raw.githubusercontent.com/itisl/Pic_Bed/master/img/20190821152058.png)
a. 可以用=, +=, -=, ++, --改变指针变量的值(内置类型的运算操作不支持重载)，引用永远对应同一个对象，不可变
b. 指针是一个实体，引用是一个别名。因此指针可以为空，引用不能
c. 引用会有类型检查，是类型安全的
