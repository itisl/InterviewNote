> **指针与引用的关系与区别**
> ![20190902144041.png](https://raw.githubusercontent.com/itisl/Pic_Bed/master/img/20190902144041.png)
> 1. 引用的底层实现是常量指针，但是从语言层面来讲引用和指针是完全不同的东西
> 2. 可以用`=`, `+=`, `-=`, `++`, `--`改变指针变量的值(内置类型的运算操作不支持重载)，引用永远对应同一个对象，不可变
> 3. 指针可以为空，引用不能(指针是一个实体，引用是一个别名)
> 4. 引用会有类型检查，是类型安全的
---
## 1. 指针
- 区别指针类型和所指对象的类型，指针类型对指针的运算产生影响，不会影响指针指向对象的大小
- 指针的类型必须与所指对象的类型一致。两个例外：
  1. 可以用指向常量的指针指向非常量对象
int n = 0;
const int *p = &n;//n的值可以改变，但是不能通过指针*p修改
  2. 向上转型（派生类指针赋值给基类指针）
```cpp
unsigned int i = 0xfffffff7;
char *p = (char*)&i;
printf("%x\n", *p);//输出结果fffffff7
```
### 指针与`const`
#### 顶层`const`：常量指针
```cpp
int *const p = &n; //p不能改变，*p和n可以改变
```
#### 底层`const`：指向常量的指针
```cpp
const int *p = &n; //p和n可以改变，但是不能通过*p改变n
int const *p = &n; //意义相同
```



## 2. 引用
**作用**：引用是已存在对象的别名，通常不用于声明变量，而用于参数类型(parameters type)和返回类型(return type)的描述
### 2.1 左值引用`&`
> 1. 引用必须被初始化为指代一个有效的对象或函数，引用被初始化后，就不能再代表其他对象
> 2. 引用在定义时需要添加`&`，在使用时不能添加`&`。`&`表示取地址。 
> 3. 使用引用/指针作为函数参数或返回值，需要的内存较小，可以提高程序的效率。
> 4. 如果不希望通过引用来修改原始的数据，那么可以在定义时用`const`限制
> 5. 引用本身不是对象，不存在 void 的引用，也不存在引用的引用不能定义引用
> 6. 常量左值引用(如函数参数中`const int&`)可以绑定到临时量(右值)
```cpp
int &name = data;
```


#### 左值引用作为函数参数
引用传参可以传地址，形式上比指针更加优美直观
```cpp
void swap(int& a,int& b){
    int temp = a;
    a = b;
    b = temp;
}
```
#### 左值引用作为函数返回值
注意：不可返回局部数据的引用
```cpp
int& plus(int &n){
    n += 10;
    return n;//不需要&
};
```
#### 指针的引用
离变量名最近的符号是变量的类型（引用），其余部分确定引用的类型（从右往左阅读）
```cpp
int*& pnum = p; 
```
### 2.2 右值引用`&&`
**作用**：引用对象为临时对象(函数返回值，未命名的自由空间等)，判断对象为临时对象后，可以用廉价的移动操作代替拷贝操作
> - 右值引用可用于为临时对象延长生存期
> - 当函数同时具有右值引用和左值引用的重载时，右值引用重载绑定到右值（包含纯右值和亡值），而左值引用重载绑定到左值
```cpp
T&& rr = 1;
T&& rr = a + b;
```
> **左值引用与右值引用的转换**
> - 将左值强制转换为右值
>   ```cpp
>   // 等价于static_cast<T&&>()
>   std::move()
>   ```
> - 将右值转换成左值
>   ```cpp
>   // 等价于static_cast<T&>()
>   std::forward()
>   ```