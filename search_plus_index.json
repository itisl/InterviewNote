{"./":{"url":"./","title":"Introduction","keywords":"","body":"Lzy's Interview Note 个人C/C++以及数据结构与算法、操作系统、TCP/IP网络编程、数据库相关的笔记 在GitBook、GitHub、Gitee上都有部署 "},"1.C++/":{"url":"1.C++/","title":"第一部分 C++","keywords":"","body":""},"1.C++/1.编译与链接/":{"url":"1.C++/1.编译与链接/","title":"1. 编译与链接","keywords":"","body":""},"1.C++/1.编译与链接/1.从代码到可执行文件.html":{"url":"1.C++/1.编译与链接/1.从代码到可执行文件.html","title":"1.1 如何运行一个C++程序？","keywords":"","body":"编译与链接 C++文件格式 编译器 Microsoft Visual C++ GCC（GNU C++） Borland C++ UNIX 源文件后缀 .cpp .cxx .cc .cpp .cxx .cc .c++ .C .cpp .C .cc .cxx 从代码到可执行文件 C++从源代码生成可执行文件的过程： 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件 程序的生命周期阶段 如何运行一个C++程序？ 使用g++命令行编译链接(Linux) 常用命令 -c 生成.o目标文件 -o生成可执行文件 -shared 指定生成动态链接库 -L 要链接的库所在目录 -l 指定链接时需要的动态库，隐含命名规则，即在前加lib，在后加.a或.so确定库文件名 1. 编译 -E预处理命令，宏的替换，还有注释的消除，还有找到相关的库文件，生成Test.i文件 g++ -E Test.cpp -S命令将文件转换为汇编文件，生成Test.s文件 g++ -S Test.cpp 2. 目标代码 -c命令将文件转换为目标文件，生成Test.o文件 g++ -c Test.cpp 3. 生成库文件 动态库 g++ Test.cpp -fPIC -shared -o libTest.so 静态库 ar cr libTest.a Test.o 4. 链接 -o命令生成可执行文件out(或out.exe)，-L命令链接库文件路径，-l链接动态链接库.so g++ Test.cpp -L /usr/include/iostream -l Test -o out "},"1.C++/1.编译与链接/2.编译预处理.html":{"url":"1.C++/1.编译与链接/2.编译预处理.html","title":"1.2 编译预处理","keywords":"","body":" 1. 条件编译 作用：预处理器支持有条件地编译源文件的某些部分。这一行为由 #if、#else、#elif、#ifdef、#ifndef 与#endif 指令所控制 #ifndef ___HPP_ #define ___HPP_ #endif // //.hpp的条件编译，防止重复引用头文件 2. include头文件 // TODO 完成 请你来回答一下 include 头文件的顺序以及双引号””和尖括号<>的区别？ 考点：编译过程 参考回答： Include 头文件的顺序：对于 include 的头文件来说，如果在文件 a.h 中声明一个在文件 b.h 中定义的变量，而不引用 b.h。那么要在 a.c 文件中引用 b.h 文件，并且要先引用 b.h，后引用 a.h,否则汇报变量类型未声明错误。 双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。 对于使用双引号包含的头文件，查找头文件路径的顺序为： 当前头文件目录 编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径） 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径 对于使用尖括号包含的头文件，查找头文件的路径顺序为： 编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径 宏与预定义常量 1. 宏定义#define 宏：#define在预编译时展开，将相对应位置宏定义替换成文本, 其作用域范围从定义位置开始，到其当前所在作用域结束 应尽量避免使用宏定义常量，使用宏时要非常谨慎，尽量以内联函数、枚举和常量代替 1.1 简单宏定义 #define FOREVER for(;;) //死循环 #define CASE break;case 宏意味着你和编译器看到的代码是不同的。这可能会导致异常行为，尤其因为宏具有全局作用域，应该==避免使用宏定义常量==: #define PI 3.14 1.2 带参数的宏定义 #define () 宏体中出现的参数，如果必须使用宏需要注意： 尽量用()把每个宏参数括起来 整个宏体也要使用()括起来 全局名字一定要使用作用域解析符:: #define MIN(a, b) (((a) 2. const常量 C++编译器会在编译时为const常量分配地址，并提供类型检查和作用域检查 3. enum hack 作用：#define进行的是字符串替换，不利于程序调试，而且不容易控制范围。使用enum hack可以定义一个枚举常量，而且也不会导致不必要的内存分配。 class box{ private: enum {volume = 10}; int things[volume]; }; // 利用enum hack和模板元实现递归版本的阶乘直接求值 template struct Factorial{ enum {value = n * Factorial::value}; }; template<> struct Factorial{ enum {value = 1}; }; std::cout::value; enum hack比较像#define而不像const，比如对enum取址不合法； enum和#define一样不会导致非必要的内存分配； enum hack是模板元编程的一项基本技术，大量的代码在使用 enum定义的常量，并不是在预编译的时候进行替换，只是在编译的时候，根据标识去常量区获取对应的值 4. constexpr // TODO "},"1.C++/1.编译与链接/3.main函数.html":{"url":"1.C++/1.编译与链接/3.main函数.html","title":"1.3 main函数","keywords":"","body":"主函数main() 作用：是程序在有宿主 (hosted)环境（亦即有操作系统）中所指定的入口点，在程序启动中完成对具有静态存储期的全局对象的初始化之后被调用。 (因此全局对象的构造函数会在主函数之前执行。) main()应当有下列形式之一： int main(){ body } int main(int argc, char* argv[]){ body } //int main(int argc, char** argv) 同样合法 argc：非负数，表示从程序运行的环境传递给程序的实参个数。 argv：指针数组，表示从执行环境传递给程序的若干参数，指向包含 argc + 1 个指针的数组的首元素。数组最后元素为空指针。 main函数具有几项特殊性质： 不能在程序的任何地方使用它 不能递归调用它 不能取其地址 不能预定义，不能重载 不能定义为=delete、或声明为extern \"C\"、inline、static 或 constexpr。 主函数的函数体可以不需要包含return语句，末尾会自动执行return 0; 执行返回时，先正常离开函数（这将销毁具有自动存储期的对象），然后用和return相同的实参来调用std::exit。（std::exit 随即销毁静态对象并终止程序） (C++14 起)不允许 auto main() {...} "},"1.C++/1.编译与链接/4.extern和static.html":{"url":"1.C++/1.编译与链接/4.extern和static.html","title":"1.4 extern和static","keywords":"","body":"extern extern 声明符仅在变量和函数的声明中允许使用（除了类成员或函数形参）。它指定外部连接，而且技术上不影响存储期，但它不能用于自动存储期的对象的定义，故所有 extern 对象都具有静态或线程存储期 extern \"C\" 作用：会指示编译器这部分代码按C语言（而不是C++）的方式进行编译 static static 说明符仅在对象声明（除了函数参数列表中）、函数声明（除了块作用域中）及匿名联合体的声明中允许使用，不允许用在定义。 类的静态成员不与类的对象关联，是具有静态存储期的独立变量，或者常规函数。 class X { static int n; }; // （仅）声明（用 'static'） int X::n = 1; // 定义（不用 'static'） "},"1.C++/1.编译与链接/5.静态绑定和动态绑定.html":{"url":"1.C++/1.编译与链接/5.静态绑定和动态绑定.html","title":"1.5 静态绑定和动态绑定","keywords":"","body":"静态绑定和动态绑定 (见虚函数与多态) 静态类型：对象在声明时采用的类型，在编译期既已确定； 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的； 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期； 非虚函数一般是静态绑定，虚函数一般是动态绑定 "},"1.C++/1.编译与链接/6.链接与符号.html":{"url":"1.C++/1.编译与链接/6.链接与符号.html","title":"1.6 链接与符号","keywords":"","body":"符号与符号表https://www.jianshu.com/p/bda60193808d 编译原理 符号表 https://blog.csdn.net/getianao97/article/details/85316436 "},"1.C++/1.编译与链接/附：常用头文件.html":{"url":"1.C++/1.编译与链接/附：常用头文件.html","title":"附：常用头文件","keywords":"","body":"附录：头文件 万能头文件 头文件: 作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明 包含STL以及[常用头文件]的, 可用LeetCode等在线编程网站 #include // gcc编译器可用, vs不支持 常用头文件及其作用 概念库 #include //(C++20 起) 基础库概念 协程库 #include //(C++20 起) 协程支持库 工具库 #include //通用工具：程序控制、动态内存分配、随机数、排序与搜索 #include //信号管理的函数与宏常量 #include //保存执行语境的宏，及跳转到某个执行语境的函数 #include //变长实参列表的处理 #include //运行时类型信息工具 #include //(C++11 起)std::type_index #include //(C++11 起)编译时类型信息 #include //std::bitset 类模板 #include //函数对象、函数调用、绑定操作、引用包装 #include //多种工具组件 #include //C 风格的时间/日期工具 #include //(C++11 起)C++ 时间工具 #include //标准宏和 typedef #include //(C++11 起)std::initializer_list 类模板 #include //(C++11 起)std::tuple 类模板 #include //(C++17 起)std::any 类 #include //(C++17 起)std::optional 类模板 #include //(C++17 起)std::variant 类模板 #include //(C++20 起)三路比较运算符支持 #include //(C++20 起)提供依赖于实现的库信息 #include //(C++20 起)提供获得源码位置的手段 动态内存管理 #include //低层内存管理工具 #include //高层内存管理工具 #include //(C++11 起)嵌套分配器类 #include //(C++17 起)多态分配器及内存资源 数值界限 #include //整型类型的界限 #include //浮点类型的界限 #include //(C++11 起)定长整数及其他类型的界限 #include //(C++11 起)格式化宏、 intmax_t 及 uintmax_t，数学工具及转换 #include //查询算术类型属性的标准化方式 错误处理 #include //异常处理工具 #include //标准异常对象 #include //将其实参与零比较的条件性编译宏 #include //(C++11 起)定义 std::error_code，依赖于平台的错误码 #include //含有最近一次错误号的宏 字符串库 #include //确定字符数据中所含类型的函数 #include //确定宽字符数据中所含类型的函数 #include //多种窄字符串处理函数 #include //多种宽及多字节字符串处理函数 #include //(C++11 起)C 风格 Unicode 字符转换函数 #include //std::basic_string 类模板 #include //(C++17 起)std::basic_string_view 类模板 #include //(C++17 起)std::to_chars 与 std::from_chars 容器库 #include //(C++11 起)std::array 容器 #include //std::vector 容器 #include //std::deque 容器 #include //std::list 容器 #include //(C++11 起)std::forward_list 容器 #include //std::set 及 std::multiset 关联容器 #include //std::map 及 std::multimap 关联容器 #include //(C++11 起)std::unordered_set 及 #include std::unordered_multiset 无序关联容器 #include //(C++11 起) std::unordered_map 及 #include std::unordered_multimap 无序关联容器 #include //std::stack 容器适配器 #include //std::queue 及 std::priority_queue 容器适配器 #include //(C++20 起)std::span 视图 迭代器库 #include //范围迭代器 范围库 #include //(C++20 起)范围访问、原语、要求、工具及适配器 算法库 #include //对范围操作的算法 #include //(C++17 起)针对算法的并行版本的预定义执行策略 数值库 #include //常用数学函数 #include //复数类型 #include //表示和操作值的数组的类 #include //(C++11 起)随机数生成器及分布 #include //容器中值的数值运算 #include //(C++11 起)编译时有理数算术 #include //(C++11 起)浮点环境访问函数 #include //(C++20 起)位操纵函数 输入/输出库 #include //所有输入/输出库中的类的前置声明 #include //std::ios_base 类、std::basic_ios 类模板及数个 typedef #include //std::basic_istream 类模板及数个 typedef #include //std::basic_ostream、std::basic_iostream 类模板及数个 typedef #include //数个标准流对象 #include //std::basic_fstream、std::basic_ifstream、#include std::basic_ofstream 类模板及数个typedef #include //std::basic_stringstream、std::basic_istringstream、#include std::basic_ostringstream 类模板及数个 typedef #include //(C++20 起)std::basic_osyncstream、std::basic_syncbuf 及 #include typedef #include //(C++98 中弃用)std::strstream、std::istrstream、#include std::ostrstream #include //控制输入输出格式的辅助函数 #include //std::basic_streambuf 类模板 #include //C 风格输入输出函数 本地化库 #include //本地化工具 #include //C 本地化工具 #include //(C++11 起)(C++17 中弃用) Unicode 转换设施 #include //正则表达式库 #include //(C++11 起)支持正则表达式处理的类、算法及迭代器 #include //原子操作库 #include //(C++11 起)原子操作库 线程支持库 #include //(C++11 起)std::thread 类及支持函数 #include //(C++20 起)std::jthread 的停止记号 #include //(C++11 起)互斥原语 #include //(C++14 起)共享的互斥原语 #include //(C++11 起)异步计算的原语 #include //(C++11 起)线程等待条件 #include //(C++20 起)信号量 #include //(C++20 起)闩 #include //(C++20 起)屏障 文件系统库 #include //(C++17 起)std::path 类及 支持函数 "},"1.C++/2.基础/":{"url":"1.C++/2.基础/","title":"2. 基础","keywords":"","body":""},"1.C++/2.基础/1.作用域与生命期.html":{"url":"1.C++/2.基础/1.作用域与生命期.html","title":"2.1 作用域与生命期","keywords":"","body":" 作用域和生命期 声明域 潜在作用域 作用域 名字空间namespace namespace的成员位于相同的作用域中，无须特殊符号可以访问，名字空间外访问需要域解析符:: namespace mynamespace{ // 该名字空间下的成员和函数 ... } using声明可以使一个namespace的成员在当前作用域下使用，不必使用域解析符::using namespace std; { cout 名字空间别名 可以为名字空间长名起一个别名： namespace Glib = Graph_lib; "},"1.C++/2.基础/2.声明、表达式与运算符.html":{"url":"1.C++/2.基础/2.声明、表达式与运算符.html","title":"2.2 声明、表达式与运算符","keywords":"","body":"声明 离变量名最近的符号是变量的类型 "},"1.C++/2.基础/3.左值和右值.html":{"url":"1.C++/2.基础/3.左值和右值.html","title":"2.3 左值和右值","keywords":"","body":" 每个表达式恰属于三种基本值类别之一：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue) 左值 以下均为左值表达式： 变量、函数、模板形参对象 (C++20 起)或数据成员，不论其类型，即使变量的类型是右值引用，由其名字构成的表达式仍是左值表达式 函数调用或重载运算符表达式，其返回类型为左值引用，例如 std::getline(std::cin, str)、std::cout 、str1 = str2 a = b，a += b，a %= b，以及所有其他内建的赋值及复合赋值表达式； 内建的前置自增与前置自减表达式++a 和 --a 内建的间接寻址表达式*p 内建的下标表达式a[n] 或n[a]，但 a[n] 中的一个操作数应为数组左值 (C++11 起)； a.m，对象成员表达式，除了 m 为成员枚举项或非静态成员函数，或者 a 为右值而 m 为非引用类型的非静态数据成员的情况； p->m，内建的指针成员表达式，除了 m 为成员枚举项或非静态成员函数的情况； a.mp，对象的成员指针表达式，其中 a 是左值且 mp 是数据成员指针； p->mp，内建的指针的成员指针表达式，其中 mp 是数据成员指针； a, b，内建的逗号表达式，其中 b 是左值； a ? b : c，对某些 b 和 c 的三元条件表达式（例如，当它们都是同类型左值时，但细节见其定义）； 字符串字面量，例如 \"Hello, world!\"； 转换为左值引用类型的转型表达式，例如 static_cast(x)； 函数调用表达式或重载的运算符表达式，其返回类型是到函数的右值引用； 转换为函数的右值引用类型的转型表达式，如 static_cast(x)。 性质： 与泛左值相同（见下文）。 可以取左值的地址：&++i[1] 及 &std::endl 是合法表达式。 可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数。 左值可用于初始化左值引用；这会将一个新名字关联给该表达式所标识的对象。 只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 std::forward 功能函数 右值 "},"1.C++/2.基础/4.初始化.html":{"url":"1.C++/2.基础/4.初始化.html","title":"2.4 初始化","keywords":"","body":" 统一初始化 说明：在C++11之前，初始化可能发生在(), {}或者=上，C++11标准提供了一个共通的初始化方法，使用{}列表初始化 实现：编译器将{t1, t2, ..., tn}当做initializer_list，关联到一个array(类中包含array)，编译器将array内的元素逐一分解传给函数(如构造函数) int arr[] {1, 2, 3} // 初始化一个数组 vector v{4, 5, 6} // 初始化一个容器 complex c{1.0, 2.0} // 调用构造函数初始化对象，等价于complex c(1.0, 2.0) 使用列表初始化，可以避免发生窄化转换，如果没有参数，还会初始化为0(指针为nullptr) int i = 3.14; // 会发生窄化转换，丢失0.14 int i = {3.14}; // 编译器不通过，或者warning int* p; // 未定义的值 int* q{}; // 初始化为nullptr 列表初始化避免和auto结合使用，除非目的就是为了得到一个initializer_list 如果初始化的对象本身有一个接受initializer_list的构造函数(如vector)，那么整个initializer_list将作为参数传入，如果要使用其他的构造函数，应该使用() vector v1{5, 1}; // {5,1} vector v2(5, 1); // {1,1,1,1,1} cout 类型别名 1. C语言方法typedef typedef int n; //n是int的同义词 typedef n a, *p; //a是int的同义词，p是int*的同义词 2. 新标准别名声明using using zs = int; //n是int的同义词 ==注意==类型别名前不能加修饰符：unsigned zs i; // 错误 auto占位符 1. auto与变量 作用：自动推导变量的类型，无需显示指定(返回迭代器等类型时手动写太复杂) auto变量必须在定义时初始化 auto只能使用在局部变量。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别使用{}初始化auto变量 定义在一个auto序列的变量必须始终推导成同一类型 auto a4 = 10, a5 = 20, a6 = 30;//正确 auto b4 = 10, b5 = 20.0, b6 = 'a';//错误,没有推导为同一类型 如果初始化表达式是引用，则自动去除引用语义 如果初始化表达式为const或volatile，则除去const/volatile语义(auto不能自动推导成cv限定符) auto仅仅是一个占位符，不能使用sizeof或typeid 可以使用valatile, *(指针类型说明符), &(引用类型说明符)，&&(右值引用)来修饰auto关键字 auto会自动推断出数组和指针类型，因此auto与auto*作用一致 auto与{}列表: 如果不希望得到initializer_list类型，应该选择=而非{} auto x{1}; // 推断为{1}列表 auto用于vector不会得到bool类型 2.auto与函数 当不知道函数返回类型，可以用auto f();自动推导返回类型；(C++14) 泛型lambda，参数列表可以使用[](auto x, auto y){return x+y;}(C++14) 自动推导函数对象类型auto f=function(){}; "},"1.C++/2.基础/5.数据类型.html":{"url":"1.C++/2.基础/5.数据类型.html","title":"2.5 数据类型","keywords":"","body":" typename()表示默认构造函数构造的临时对象 自定义数据类型 class, union, struct和enum的关系 struct是一种特殊的类, union和enum则是一种特殊的struct； struct是成员和继承关系默认是public属性的,class默认为private； C语言中struct只能包含成员变量，不可包含成员函数，C++都可包含； struct是C++用来兼容C语言的，实际使用上除了访问权限完全等价。 union: 联合，所有成员都分配在同一地址 同一时刻union只能保存一个成员变量的值，不推荐使用 union Value{ char *s; int i; }; 枚举enum 枚举: 枚举是列出某些有穷序列集的所有成员, 在程序中用于声明一组命名的==常数== 枚举默认为int，必须是一种带符号或无符号的整数类型； 不指定值时默认从0开始，后面每个值为前项+1，枚举常量的值可以重复； 枚举命名常量的值不可更改，没有初始化枚举对象时不占用内存空间。 枚举常量详见enum hack 无作用域枚举：枚举名与类型在同一作用域内，值可以隐式转换成整数 enum 名字 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... }; enum 名字 : 类型 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... };(C++11) enum 名字 : 类型 ;(C++11) enum {a = 0, b, c}; //可以不声明枚举名，这种声明仅将各枚举项常量引入到其外围作用域中 enum Color{red=1, yellow, green=1}; //可以声明相同的值，后一项yellow默认=2 enum Rooms:char{ livingroom, den, bedroom, kitchen }; //可以声明类型 Color c = red; //enum定义 有作用域枚举：枚举名位于enum局部作用域，值不会隐式转换(C++11) enum struct|class 名字 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... }; enum class Color{red, yellow, green}; //关键词class与struct等价 Color c = Color::red; //使用必须加上枚举名Color "},"1.C++/2.基础/6.类型转换.html":{"url":"1.C++/2.基础/6.类型转换.html","title":"2.6 类型转换","keywords":"","body":" 隐式转换 强制类型转换 ==C语言强制类型转换干扰了正常的类型检查，尽量避免使用== int num = 10; double d = (double)num; //会有警告 语法格式 cast_name(expr) int num = 10; double d = static_cast(num); 四种强制类型的转换 cast_name 作用 static_cast 静态转换, 只要不包含底层const就可以使用，只能进行编译器允许的隐式转换 dynamic_cast 用于将基类的指针或引用安全地转换成派生类指针或引用。如果转型失败，当转型对象是指针的时候会返回一个nullptr指针: dynamic_cast (p) const_cast 只能改变对象的底层const，可以改变表达式的常量属性 reinterpret_cast 不相关类型的转换, 例如从class A到int* "},"1.C++/2.基础/7.输入输出.html":{"url":"1.C++/2.基础/7.输入输出.html","title":"2.7 输入输出","keywords":"","body":" cin与cout getline(istream is,string& str,结束符=\"\\n\") // 已知个数数据输入，以空格隔开, \\n 结束 while(cin>>a>>b){ cout > n; while(n--){ cin >> e; } } // 多行数据，每行不定个数 while(getline(cin, s, \",\")){ stringstream ss{s}; while(ss >> e){ stoi(e); //如果 } } endl等价于'\\n'，会刷新缓冲区，造成效率低下。推荐用'\\n'代替endl； 可以使用tie()函数解除cin与cout的绑定，加快输入输出效率： std::ios::syn_with_stdio(false); //解除stdio的兼容 std::cin.tie(nullptr); std::cout.tie(nullptr); 输出精度控制： cout.precesion(3);//3为有效数字 格式化输出，见格式化字符串 标准库I/O流 标准库I/O流 cout 标准字符输出(默认为屏幕) cin 标准字符输入(默认为键盘) cerr 标准字符错误输出(无缓冲) clog 标准字符日志输出(有缓冲) 文件流 "},"1.C++/2.基础/8.数组、指针与引用.html":{"url":"1.C++/2.基础/8.数组、指针与引用.html","title":"2.8 数组、指针与引用","keywords":"","body":"1. 数组 2. 指针 概念：指针是一个变量，其值为另一个变量的内存地址 指针类型 指针指向的类型 指针的大小是固定的，在32为系统中为4个字节，64位系统中为8个字节 指针的类型决定了指针运算的内存偏移量(包括*, +, -, ++, --) 指针的类型必须与所指对象的类型一致。两个例外： 可以用指向常量的指针指向非常量对象int n = 0; const int *p = &n;//n的值可以改变，但是不能通过指针*p修改 类的多态空指针nullptr与NULL和0 nullptr是C++11标准的关键字，指针指向nullptr代表指针为空void f(int); void f(void*); f(0); // 调用f(int) f(NULL); // 实际调用f(int)，与目标调用不符 f(nullptr); // 调用f(void*) 2.1 指针与数组 2.2 指针与const 顶层const：常量指针 int *const p = &n; //p不能改变，*p和n可以改变 底层const：指向常量的指针 const int *p = &n; //p和n可以改变，但是不能通过*p改变n int const *p = &n; //意义相同 3. 引用 作用：引用是已存在对象的别名，通常不用于声明变量，而用于参数类型(parameters type)和返回类型(return type)的描述 指针与引用的关系与区别 引用的底层实现是常量指针，但是从语言层面来讲引用和指针是完全不同的东西 可以用=, +=, -=, ++, --改变指针变量的值(内置类型的运算操作不支持重载)，引用永远对应同一个对象，不可变 指针可以为空，引用不能(指针是一个实体，引用是一个别名) 引用会有类型检查，是类型安全的3.1 左值引用& 引用必须被初始化为指代一个有效的对象或函数，引用被初始化后，就不能再代表其他对象 引用在定义时需要添加&，在使用时不能添加&。&表示取地址。 使用引用/指针作为函数参数或返回值，需要的内存较小，可以提高程序的效率。 如果不希望通过引用来修改原始的数据，那么可以在定义时用const限制 引用本身不是对象，不存在 void 的引用，也不存在引用的引用不能定义引用 常量左值引用(如函数参数中const int&)可以绑定到临时量(右值)int &name = data; 左值引用作为函数参数 引用传参可以传地址，形式上比指针更加优美直观 void swap(int& a,int& b){ int temp = a; a = b; b = temp; } 左值引用作为函数返回值 注意：不可返回局部数据的引用 int& plus(int &n){ n += 10; return n;//不需要& }; 指针的引用 离变量名最近的符号是变量的类型（引用），其余部分确定引用的类型（从右往左阅读） int*& pnum = p; 3.2 右值引用&& 作用：引用对象为临时对象(函数返回值，未命名的自由空间等)，判断对象为临时对象后，可以用廉价的移动操作代替拷贝操作 右值引用可用于为临时对象延长生存期 当函数同时具有右值引用和左值引用的重载时，右值引用重载绑定到右值（包含纯右值和亡值），而左值引用重载绑定到左值T&& rr = 1; T&& rr = a + b; 左值引用与右值引用的转换 将左值强制转换为右值// 等价于static_cast() std::move() 将右值转换成左值// 等价于static_cast() std::forward() "},"1.C++/2.基础/9.C++关键字.html":{"url":"1.C++/2.基础/9.C++关键字.html","title":"2.9 C++常用关键字","keywords":"","body":"说明符 1. 类型说明符 1.1 alignas说明符 1.2 decltype()说明符 作用：声明返回类型(包括顶层const和引用) decltype(f()) sum = x;//sum的类型是f的返回类型 decltype((i)) n = a; //编译器认为(i)为表达式，得到左值引用，如果i为普通变量，最终结果n也是a的引用 若实参是指名某个结构化绑定的无括号的标识表达式，则decltype产生被引用类型（在关于结构化绑定声明的说明中有所描述）。(C++17 起) 若实参是指名某个非类型模板形参的无括号的标识表达式，则decltype生成该模板形参的类型（当该模板形参以占位符类型声明时，则为进行任何所需的类型推导后的类型）。(C++20 起) 若实参为无括号的标识表达式或无括号的类成员访问表达式，则decltype产生以此表达式命名的实体的类型。若无这种实体，或该实参指名某个重载函数，则程序非良构。 若实参是其他类型为 T 的任何表达式，且 若 表达式 的值类别为亡值，则decltype产生 T&&； 若 表达式 的值类别为左值，则decltype产生 T&； 若 表达式 的值类别为纯右值，则decltype产生 T。 若 表达式 是返回类类型纯右值的函数调用，或是右操作数为这种函数调用的逗号表达式，则不对该纯右值引入临时量。(C++17 前) 若 表达式 是除了（可带括号的）立即调用以外的 (C++20 起)纯右值，则不从该纯右值实质化临时对象。(C++17 起) 不需要该类型完整或拥有可用的析构函数，而且类型可以是抽象的。此规则不适用于其子表达式：decltype(f(g()))中，g()必须有完整类型，但f()不必。 注意如果对象的名字带有括号，则它被当做通常的左值表达式，从而decltype(x)和 decltype((x))通常是不同的类型。 在难以或不可能以标准写法进行声明的类型时，decltype 很有用，例如lambda相关类型或依赖于模板形参的类型。占位符类型说明符 auto类型说明符 auto让编译器通过初始值来推算变量类型，auto定义的变量必须有初始值 auto item1 = var1, item2 = var2;//若var1和var2类型不一样将会报错 对于变量，指定要从其初始化器自动推导出其类型。 对于函数，指定要从其 return 语句推导出其返回类型。(C++14 起) 对于非类型模板形参，指定要从实参推导出其类型。(C++17 起) 2. 限定符 2.1 cv-限定符 2.2 constexpr 作用：constexpr说明符声明可以在编译时求得函数或变量的值 将变量声明为constexpr类型，可以让编译器验证变量值是否为常量表达式（编译过程就能得到结果的表达式），必须用常量表达式初始化。 普通函数不能作为constexpr变量的初始值，但是可以通过定义constexpr函数（足够简单）来初始化constexpr变量 constexpr int *p = nullptr; // p是常量指针（顶层const,和const定义的不同）2.3 constexpr函数 constexpr函数可以在编译时求值，从而可以用constexpr函数来初始化constexpr变量constexpr int Fac(int n){ return (n>1)? n*Fac(n-1):1; } constexpr int kf9 = Fac(9); //必须在编译时求值 constexpr函数必须是一个==纯函数==：必须包含一条独立的return语句(return 常量表达式)，不能有==循环==、==条件判断==、==局部变量==、不能有==副作用==(修改变量的值)，允许递归和条件表达式 int kGlob; constexpr void Bad1(int a){ //错误：函数类型不能是void，必须有返回值 kGlob = a; // 错误：不能有副作用（修改变量的值） } constexpr int Bad2(int a){ if(a>0) return a; // 错误：不能有if语句 else return -a; } 3. 属性 [[...]]被称为属性，可以置于C++语法的任何位置， [[noreturn]] 作用：[[noreturn]]放在函数声明开始位置表示不希望任何返回结果。 [[noreturn]] void exit(int); //exit永远不会返回任何结果 using using可以用于namespace和namespace中的成员 using可以用于类型别名和模板别名 using用于类的成员中，可以在派生类中指定使用基类的某个成员(即使该成员为private/protected，包括基类的构造函数) noexcept 作用：表明一个函数不会抛出异常 void swap(int, int) noexcept{}; // 也可以加上判断 void swap(int, int) noexcept(if a>b){}; decltype sizeof() 作用：返回类型或其对象在内存中所占的字节数 sizeof()是一个占位符，其值在编译时期就已经确定 "},"1.C++/3.类与对象/":{"url":"1.C++/3.类与对象/","title":"3. 类与对象","keywords":"","body":""},"1.C++/3.类与对象/1.类与对象.html":{"url":"1.C++/3.类与对象/1.类与对象.html","title":"3.1 类与对象","keywords":"","body":" 1. 什么是类 class是用户自定义类型 一个类是包含其成员的namespace 可以为类定义运算符，如+, !和[] 类是一个模板，编译后不占用内存空间，所以定义类时不能对类进行初始化，只能创建对象的时候初始化; 类在声明前不能定义对象，但是可以定义其指针类型 class Clock{ public: // 公有成员 void display();//成员函数的声明（也叫方法），成员函数是属于类的，但是要通过对象来调用 private: // 私有成员 int m_hour;//成员变量的声明（也叫属性），成员变量是属于对象的 … }; ==和struct, enum一样，';'也是类定义的一部分, 表示类定义结束== 1.1 访问控制 public成员提供类的接口，private成员提供实现细节 class如果不指明成员属性，默认为private 1.2 成员函数 参数列表中使用const可以同时适用于const参数和非const参数 1.3 成员变量 class, union, struct和enum的关系 struct是一种特殊的类, union和enum则是一种特殊的struct； struct是成员和继承关系默认是public属性的,class默认为private； C语言中struct只能包含成员变量，不可包含成员函数，C++都可包含； struct是C++用来兼容C语言的，实际使用上除了访问权限完全等价。 更多关于struct, enum, union可见数据类型 "},"1.C++/3.类与对象/2.构造函数与析构函数.html":{"url":"1.C++/3.类与对象/2.构造函数与析构函数.html","title":"3.2 构造函数与析构函数","keywords":"","body":"构造函数 构造函数作用：创建对象时自动执行，用于初始化成员变量。名字和类名相同，无返回值： 构造函数没有名字且无法被直接调用。它们在发生初始化时调用，且它们按照初始化的规则进行选择； 单参数的构造函数应该声明为explicit，避免编译器做类型转换； 有constexpr说明符的构造函数令其类型成为字面类型(LiteralType) class Clock{ public: Clock(int hour,int minute,int second);//声明构造函数 Clock(); void show(); private: int hour_; int minute_; int second_; }; 1. 默认构造函数： 作用：构造对象时默认调用的构造函数 不能定义两个带初始值的默认构造函数（会报错）。 程序中已定义构造函数，编译器不再隐含生成，编译器A()=default; 调用没有参数的构造函数可以省略括号：Clock today; =default 可以写在声明处也可以写在定义处2. 拷贝构造函数： 拷贝构造函数作用：类内成员变量含指针、动态分配的内存时，必须定义拷贝构造函数进行深拷贝，否则可以不定义。 类内成员变量含指针、动态分配的内存时，必须定义拷贝构造函数进行深拷贝； 拷贝构造函数和拷贝赋值操作operator=必须同时给出，见拷贝与移动。 可以在private中加入拷贝构造的声明（不必定义），用来防止默认拷贝。Clock(const Clock &today);//复制构造函数的声明 Clock(const Clock &today)=delete;//指示编译器不生成默认复制构造函数 Clock B = A; // Clock B(A); 使用拷贝构造函数初始化新对象 ==注意：== 拷贝构造函数参数必须是当前类的引用，否则形参会调用拷贝构造函数创建临时对象，陷入死循环； 如果不加const限制，将不能拷贝const修饰的对象 3. 移动构造函数： 注意：和拷贝构造一样，移动构造函数和移动赋值操作operator=必须同时给出。 4. 转换构造函数： 转换构造函数还作为用户定义的转换序列中的一部分，在复制初始化中受到考虑 隐式声明的及用户定义的非explicit复制构造函数与移动构造函数也是转换构造函数 // 加上默认参数，构成单参数构造函数 Fraction(int numerator, int denomirator=1) :numerator_(numerator), denomirator_(denomirator){ } // 重载 + 操作符 Fraction operator+(){ return Fraction(...); } // 运算时，会将整数当做一个参数 Fraction f(3, 5); double d = 4 + f; // 调用构造函数将4转换为F(4,1), 然后调用operator+ 5. 委托构造函数： 使用类的其他构造函数执行初始化过程(两个构造函数功能相似时，可以调用减少代码量) Clock::Clock(int hour,int minute,int second):m_hour(hour),m_minute(minute),m_second(second){}; Clock::Clock():m_hour(0),m_minute(0),m_second(0){};//不使用委托构造函数 Clock::Clock():Clock(0,0,0){};//使用委托构造函数 析构函数 作用：用于销毁对象释放内存。 一个类只有一个析构函数； 析构函数在销毁对象时自动执行，无法显式调用，没有参数和返回值； 当类中不存在指针、动态分配内存时，可以不指定析构函数；否则必须指定用来释放掉指针所指向内存，避免内存泄漏 使用多态时基类的析构函数必须为virtual，否则会造成部分析构而内存泄漏 Clock::~Clock(){ delete[] m_arr; //释放申请的数组的内存 } //析构函数定义 派生类的构造与析构： 派生类构造 类的构造函数不能被继承（可以用using语句继承基类构造函数（只能初始化继承的成员）即使继承了也不能成为派生类的构造函数，==最好不用==） using People::People; 在子类的构造函数中调用基类的构造函数。 People(std::string name,int age);//基类构造函数声明 Student(std::string name,int age,float score);//派生类构造函数声明 Student::Student(std::string name,int age,float score): People(name, age), score_(score){ ... //单继承派生类构造函数的初始化列表 构造函数的执行顺序： 调用基类构造函数：顺序按照继承时声明的顺序 初始化列表成员进行初始化，按照在类中定义的顺序，对象成员初始化自动调用所. 的构造函数 执行派生类的构造函数体 派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的 调用规则： 定义派生类构造函数时应指明基类构造函数，否则就调用基类的默认构造函数。如果基类没有默认构造函数（定义了其他构造函数，编译器不生成隐含的默认构造函数），编译失败 派生类的析构 基类的析构函数应该为virtual 如果需要，子类的析构函数另外声明定义 类的析构函数也不能被继承，与构造函数不同的是，在子类的析构函数中不用显式地调用父类的析构函数。 构造和析构的顺序 派生类(或复合)对象构造由内到外： Derivrd构造函数先调用Base的默认构造函数，然后调用Component的默认构造函数，然后执行自己 Derived::Derived(...):Base(), Component(){ ... } 派生类(或复合)对象析构由外到内：Derived析构函数先执行自己，然后调用Component的析构函数，然后再调用Base析构函数(顺序相反) Derived::~Derived(...):{ ... ~Component(), ~Base() } "},"1.C++/3.类与对象/3.类成员初始化.html":{"url":"1.C++/3.类与对象/3.类成员初始化.html","title":"3.3 类成员初始化","keywords":"","body":" 1. 类内初始化(C++11起) class A{ int a{1};// 或int a = 1; 注意这里不能使用()初始化 } 2. 参数初始化列表： 作用：在构造函数中对成员变量赋值，效率比逐个变量赋值要好。同时可以为const类型变量初始化(也可以使用类内初始化器) Clock::Clock(int hour,int minute,int second):hour_(hour),minute_(minute), second_(second){}; ==初始化const成员变量、引用只能用参数初始化列表== 参数初始化顺序只与成员变量在类中声明的顺序有关，与初始化表列出的变量的顺序无关 "},"1.C++/3.类与对象/4.成员类型关键词.html":{"url":"1.C++/3.类与对象/4.成员类型关键词.html","title":"3.4 成员类型关键词","keywords":"","body":" 类成员关键词 this关键词： 作用： 在类的非静态成员函数中需要返回类对象本身的时候，使用 return *this; 当参数与成员变量名相同时，如this->n = n; （不能写成n = n） 用在类的内部，是一个const指针，指向当前对象，可以用->来访问当前对象的成员变量或成员函数 this是const指针，不能被修改，==只能在成员函数内部使用==，用在其他地方是非法的 this实质上是成员函数的一个形参，在调用成员函数时将对象地址作为实参传递给this, 在编译阶段由编译器自动将其添加到参数列表(成员函数有一个隐藏的参数this) this是一个右值，不能取得this的地址(不能&this) inline关键词 作用：inline希望编译器能够在编译时将函数在调用的地方展开，能加快运行效率。 在class/struct/union的定义之内定义的函数，无论它是成员函数还是非成员friend函数，均为隐式的内联函数 // 模板类类外内联函数的定义示例 template class shared_ptr { public: inline T& operator() const; private: T* px; long* pn; }; template inline T* shared_ptr::operator->() const{ return px; } 内联函数比较简单，当形式复杂时，编译器不会将其编译为内联函数 声明有 constexpr 的函数是隐式的内联函数。 const与mutable关键词 const可以用来修饰成员变量、成员函数、对象 const成员变量：和普通变量用法相似，只能通过参数初始化列表初始化 const对象：将对象定义为常对象后，就只能访问被const修饰的成员（非const成员可能会修改对象数据，编译器是禁止的，因此不改变数据的成员函数必须加const） const成员函数（常成员函数）：可以使用类中所有成员变量，但是不能修改它们的值，在定义和声明的时候都要在结尾加上const关键词 注意：const成员函数中，实际上const修饰的是*this，因此const成员函数不可以修改非static成员(可以修改static和mutable修饰的成员变量，因为static不属于子对象) int gethour() const; //类内 void Clock::gethour() const{ return m_hour; } const成员函数可以使用类中所有成员变量，但是不能修改它们的值 const成员函数声明和定义都必须使用const后缀 const对象只能调用const成员函数，不能调用非const成员函数 mutable：容许在即便包含它的对象被声明为const时仍可修改声明为mutable的类成员。如果需要一部分成员变量能在const成员函数中修改(用于改变const对象)，可以加上mutable修饰： mutable bool flag; static关键词 static数据或函数成员==在整个程序中只能有唯一定义==，其生存期为整个程序 静态成员变量 作用：使用static成员变量来实现多个对象共享数据（如计数器）。 函数体内static变量的作用范围为该函数体, 在第一次调用时初始化。不同于普通成员变量, 该变量的内存只被分配一次, 因此其值在下次调用时仍维持上次的值 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问 在类的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝 static成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。 class Clock { ... public: static int count_; }； 注意事项： static静态成员变量必须在类声明的外部初始化(C++17之前)；type class::name = value; //静态成员变量在初始化时不能再加static，但必须要有数据类型 (C++17)静态数据成员可以声明为inline。内联静态数据成员可以在类定义中定义，而且可以指定初始化器，不需要类外定义：struct X { inline static int n = 1; }; static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。没有在类外初始化的 static 成员变量不能使用。 static成员变量既可以通过对象来访问，也可以通过classname::member来访问 静态成员函数 没有对象的时候要访问类成员函数的话，只能访问static成员函数 静态成员函数主要目的是访问static成员变量。 在类中的static成员函数属于整个类所拥有，这个函数==不接收this指针==，因而只能访问类的static成员变量 在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内 操作 说明 声明和定义 类中声明需要static，类外定义不能加static，但必须要有数据类型 this指针 静态成员函数通过类调用，不属于对象，编译器不会为其增加形参this指针 访问 不可使用this指针，可以通过对象调用，也可以在没有实例化对象时直接调用 friend友元函数 作用：可以使其他类中的成员函数或全局函数访问当前类的private成员。 friend的关系不能传递（你朋友的朋友不是你的朋友），也不能被继承（你朋友的孩子不是你的朋友）； friend函数没有this指针，不能直接访问类的成员，必须借助类的对象访问； 同一个class的对象互为friend； 一个函数可以被多个类声明为友元函数，这样可以访问多个类中的private成员； 访问说明符(public，protect，private)对于友元声明的含义没有影响1. friend函数 将非成员函数声明为friend函数： class Clock{ public: friend void show(Clock &ck); ... }; void show(Clock &ck){ //非成员函数 ... } 其他类的成员函数声明为friend函数： class Clock{ ... public: friend void show(Clock *ptime); };//声明Clock类 class Address{ ... pubilc: void show(Clock *ptime); }; 2. friend类 友元类：可以将整个类声明为另一个类的友元（==不建议，只将成员函数声明为友元函数更安全==） 友元关系是单向的（你是我的朋友，我不一定是你的） 友元类只能声明，不能定义新的类（friend class X {}; 是错的） class Clock{ public: friend class Address;//Address类声明为Clock的友元类 ... }; explicit关键词 作用：禁止隐式调用单参数的构造函数，包括： 禁止隐式调用拷贝构造函数complex c1(1, 2); complex c2 = c1+5; // 此时会隐式调用构造函数complex(5, imag=0) 禁止类对象之间的隐式转换(见转换函数) 一般而言，只有单参数的构造函数会用到explicit关键字 explicit指明构造函数不能作隐式类型转换，只能进行初始化和显式类型转换 用=进行初始化可看作拷贝初始化，初始化器是右值时可能会采取移动操作。省略=会将初始化变为显式初始化 ==单参数的构造函数应声明为explicit==，避免发生不必要的类型转换，更多可见转换函数class Clock{ public: explicit Clock(int d); }; virtual, override与final关键词 作用： virtual函数(Virtual Function)见虚函数与多态。 override防止出现意外的继承行为。override说明编译器会检查该函数是否为虚函数，是否会覆盖基类中的虚函数，如果不是虚函数会报错 void func() override{} // 子类中使用 是在成员函数声明符之后使用时拥有特殊含义的标识符，其他情况下它不是保留的关键词，如果不能覆盖（不是虚函数、形参不对）会出错 如果没有用overide关键字，当虚函数返回类型或参数不一样时将会造成函数的隐藏而不是覆盖 覆盖的方法不能为private final用来防止类被继承(用于类定义类名后面)或成员函数被覆盖(用于成员函数后) class base final{}; void setname() final; using关键词 作用：using可以在派生类中使用基类的成员，无论继承方式为private/protected =default和=delete =default用于要求编译器生成一个默认构造函数 =delete用于指定编译器禁止该函数调用 禁止编译器使用默认生成的构造函数 也可用于类的成员函数，防止隐式类型转换 在模板特化中，用=delete过滤特定的形参类型 在C++11之前，为了防止隐式转换需要把函数声明到private域并且不实现 // 这两种类型可以只声明不实现 class A{ A()=default; void get(double)=delete; } 在C++11之前 "},"1.C++/3.类与对象/5.拷贝与移动.html":{"url":"1.C++/3.类与对象/5.拷贝与移动.html","title":"3.5 拷贝与移动","keywords":"","body":"拷贝 1. 浅拷贝 浅拷贝：默认的拷贝函数是逐成员复制，如果成员中有指针变量时会复制其指向的地址，复制对象还是可以访问到被复制对象的部分内存 2. 深拷贝 深拷贝：拷贝对象的完整状态，会重新开辟一块内存地址存储指针指向地址的内容。 深拷贝构造函数 // String对象的深拷贝构造函数 inline String::String(String& str){ data_=new char[strlen(str.data_) + 1]; strcpy(data_, str.data_); } 拷贝赋值函数 存在深拷贝构造函数时，还必须定义拷贝赋值函数，即operator= ==定义拷贝赋值函数的步骤：== 先判断是否自我赋值 delete掉复制对象数据的内存 new出一块与被复制对象数据相等的内存空间，并复制// String对象的拷贝赋值函数 inline String&String::operator=(const String& str){ if(this == &str){ //先判断是否是自我赋值 return *this; } delete[] this.data_; //先delete已存在的字符串 this.data_ = new char[strlen(str.m_data) + 1]; //+1是末尾的'\\0' strcpy(this.data_, str.data_); return *this; } String s1(\"hello\"); String s2(s1); // 调用拷贝构造函数 s2 = s1; // 调用拷贝赋值函数 移动操作： 代替深拷贝，最小化拷贝量而不会增加复杂性 "},"1.C++/3.类与对象/6.继承与派生.html":{"url":"1.C++/3.类与对象/6.继承与派生.html","title":"3.6 继承与派生","keywords":"","body":"1. 继承与派生 1.1 继承与派生的概念 被继承的类称为父类或基类，继承的类称为子类或派生类 派生类包含了全部基类中除构造函数和析构函数外的所有成员 尽量不要使用多继承class 派生类名:继承方式 基类名{ // 派生类新增成员 }； class People{ public: void setname(char *name); void setage(int age); private: string name_; int age_; }; class Student: public People{//单继承时派生类 Student public: void setscore(float score); float getscore(); private: float score_; }; class girl:pubilc People, private Student{//多继承时的派生类 ... }; //防止该类被继承：使用关键字final class People_2 final{…};//People_2将不能被被继承 1.2. 继承方式的访问权限 继承方式/基类成员 public成员 protected成员 private成员 public继承 public protected 不可见 protected继承 protected protected 不可见 private继承 private private 不可见 继承方式中的public/protected/private是用来指明基类成员在派生类中的最高访问权限 基类中的private成员在派生类中始终不能在派生类的成员函数中访问或调用，在派生类访问基类private成员的方法是使用基类的非private成员函数 改变访问权限：使用using关键字可以改变基类成员在派生类的访问权限public: using People::name_; 1.3. 基类成员的遮蔽 当派生类声明了和基类成员同名的新成员，基类成员函数和派生类成员函数不会构成重载，派生的新成员会遮蔽同名成员 对于virtual函数，必须形参列表相同才能override，否则编译器会认为相互独立而遮蔽 要使用基类中的同名成员stu.People::f(); 1.4 向上与向下转型 向上转型：隐式转型，更好的方法是使用dynamic_cast 将派生类对象赋值给基类对象 将派生类指针赋值给基类指针 将派生类引用赋值给基类引用（编译器自动完成） 向下转型：借助static_cast或dynamic_cast 将基类赋值给派生类（需要手动干预）derived = static_cast (base); 更多查阅类型转换 2. 虚继承： 作用：多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。虚派生只影响从指定了虚基类的派生类中进一步派生出来的类D，它不会影响派生类A、B。 菱形继承可能会产生命名冲突 语法:在继承方式前加上virtual关键字 //虚基类A class A{ public: int x; }; //虚继承 class B: virtual public A{ … }; class C: virtual public A{ … }; //只会保留一份间接基类A中的成员 class D: public B, public C{ … }; 2.1 虚继承的变量覆盖 二义性 从不同基类继承的同名成员，派生类中没有定义同名成员，需要使用类名限定 stu1.People::f();//或stu1.Student::f(); 类A和B中都没有定义变量x, x被解析成A的成员，无二义性 类A或B中只有一个定义了变量x, x被解析成A或B中的成员变量，A中的被覆盖 类A和B中都定义了变量x，有二义性，必须用域解析符::说明x所属的类冗余 菱形继承时，A中的变量在D就会有两份，产生冗余，也应该加B::或C::限定 二义性和冗余应该尽量避免，不要重新定义继承来的非虚函数 2.2. 虚继承时的构造函数 最终派生类不仅需要调用B, C的构造函数，还需要调用间接基类A的构造函数（B, C的构造函数对A的初始化是无效的，只有D有效，普通继承不能调用间接基类） D::D(int x1, int x2, int x3, int x4): A(x1),B(x2),C(x3),D_x(x4) {} 调用顺序：先调用虚基类的构造函数，再按出现顺序调用其他构造函数 "},"1.C++/3.类与对象/7.虚函数与多态.html":{"url":"1.C++/3.类与对象/7.虚函数与多态.html","title":"3.7 虚函数与多态","keywords":"","body":" 1. 虚函数 虚函数是可在派生类中覆盖其行为的成员函数。与非虚函数相反，即使没有关于该类实际类型的编译时信息，仍然保留被覆盖的行为。==虚函数的唯一用途就是构成运行时的多态。== 重载和覆盖的区别 声明符 虚说明符序列(可选) 纯说明符(可选) 虚说明符序列，必须是 override、final、final override 或 override final之一 非虚(non-virtual)函数：不希望派生类重定义(override)，普通成员函数 虚(virtual)函数：希望派生类重新定义，当前类有定义 纯虚(pure virtual)函数：派生类必须重新定义，而且没有默认定义 1.1 普通虚函数 注意：基类的析构函数应该为virtual，否则使用基类指针指向子类对象时，会造成只析构基类部分 class A{ public: virtual ~A();//虚函数的定义 ... }; class B:public A{ public: virtual ~B(); ... }; 1.2 纯虚函数 纯虚函数的声明:virtual type FunName(para_list) = 0; //在结尾加上=0告诉编译器这是纯虚函数 只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数 抽象类（Abstract Class）：包含纯虚函数的类成为抽象类。 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。纯虚函数没有函数体，因此抽象类无法被实例化(通常没有构造函数) class Line(){ public: Line();//默认构造函数 virtual float area() = 0;//声明这是一个纯虚函数 protected: float m_len; }; class Cube:public Line{ public: Cube(float len); float area();//纯虚函数在派生类中声明 }; Cube::Cube(float len):Line(len){} //纯虚函数的定义 float Cube::area(){ return m_len*m_len; } main中： Line *p = new Cube(5);//纯虚函数可以实现多态 在抽象基类中不需要或无法实现的功能，可以声明为纯虚函数。纯虚函数为派生类提供了约束，派生类必须完成纯虚函数的功能才能实例化 2. 多态 作用：基类指针可以使用基类的方法，也可以使用派生类的方法，实现一种接口，就能针对不同子类对象完成不同的功能 作用 派生类的方法，可以被基类的方法或引用变量调用。而有了多态，只需要一个指针p就可以调用所有派生类的虚函数，提高可扩充性。 同一个函数可以处理多种不同的情况，定义了统一的接口 指针和引用都可以实现多态，但是引用不如指针灵活 对某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数，让基类指针可以访问派生类的成员函数。可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行访问。 public派生类对象可以被当做基类对象使用，反之不行。基类对象名、指针只能使用从基类继承的成员 派生类的对象可以隐含转换为基类对象； 派生类的对象可以初始化基类的引用； 派生类的指针可以隐含转换为基类的指针 虚函数注意事项： 只有类的成员函数才能声明为虚函数。 只需要在虚函数的声明处加上virtual 键字，函数定义处可以加也可以不加(最好加上，使程序更加清晰)。 在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将用基类的虚函数。 只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态。 静态成员函数不能使虚函数，因为它不受限于某个对象。 内联函数不能是虚函数。 构造函数不能是虚函数，因为构造函数不能被继承 基类的析构函数应该声明为虚函数（防止基类指针只析构基类部分而不析构派生类） 构成多态的条件： 必须存在继承关系； 继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。 存在基类的指针，通过该指针调用虚函数。 "},"1.C++/3.类与对象/8.类的嵌套与组合.html":{"url":"1.C++/3.类与对象/8.类的嵌套与组合.html","title":"3.8 类的嵌套与组合","keywords":"","body":"嵌套类 嵌套类(nested class)：可以在一个类的内部嵌套声明另一个类，也称为成员类(member class) class Tree{ //在Tree的内部声明Node类 class Node{ Node *right; Node *left; } } 嵌套类Node可以访问所属类Tree的成员(包括private)，但是只有类，没有对象 类Tree不可访问嵌套类Node的成员 ==note：注意和类的组合区分== 类的组合 类组合：类中的成员是另一个类的对象，实现更复杂的抽象。 class A{ ... }; class B{ public: void g(A a); A a2; }; 类组合的构造函数： 组合类不仅要对本类的成员数据初始化，也要对对象成员初始化。初始化次序是成员在类体中定义的次序： Clock::Clock(对象成员形参，本类成员形参):对象1(参数)，对象2(参数), ...{ ... } 部件类最好有不带参数的默认构造函数。如果部件类要作为函数参数，需要有拷贝构造函数前向引用声明 前向引用声明作用：类只能先声明，后使用。如果两个类互相引用，应进行前向引用声明。前向引用声明只为程序引入一个标识符说明这是一个类，具体声明在其他地方。 ```cpp class B; //前向引用声明 class A{ public: void f(B b); B b2; //错误用法 B *b2; //正确的用法，并在构造函数中分配内存 }; class B{ public: void g(A a); A a2; }; ``` 在提供完整的类声明之前，可以用作函数参数，但不能声明该类的对象（因为需要空间大小位置，可以用指针），也不能在内联成员函数使用该类的对象； 使用前向引用声明时，不能涉及类的任何细节，只能使用被声明的符号； "},"1.C++/3.类与对象/9.类似指针的类.html":{"url":"1.C++/3.类与对象/9.类似指针的类.html","title":"3.9 类似指针的类","keywords":"","body":"类似指针的类(pointer-like-class) 1. 智能指针 1.1 shared_ptr的实现 template class shared_ptr { public: // 构造函数 shared_ptr() :_ptr((T*)0), _pCount(new int(1)){} explicit shared_ptr(T* p) :_ptr(p), _pConut(new int(1)){} // 拷贝构造函数 shared_ptr(const shared_ptr& ap): _ptr(ap._ptr) , _pCount(ap._pCount){ ++(*_pCount); } // 拷贝赋值函数 shared_ptr& operator=(const shared_ptr& ap){ // 处理自我赋值 if (_ptr != ap._ptr){ // 先销毁原来指向的对象 if (--(*_pCount) == 0){ delete _ptr; delete _pCount; } // 重新指向新的对象和计数器 _ptr = ap._ptr; _pCount = ap._pCount; ++(*_pCount); } return *this; } // 析构函数 ~shared_ptr(){ if (--(*_pCount) == 0){ delete _ptr; delete _pCount; } } // 类指针行为的定义 T& operator*(){ return *_ptr; } T* operator->(){ return _ptr; } private: T* _ptr; int* _pCount; }; shared_ptr sp(new Foo); f(*sp);// 调用operator* sp->method();// 调用operator->(特殊行为, 指向符会继续作用下去不会被消耗掉)编译器将sp->解析为px-> 1.2 weak_ptr的实现 template class weak_ptr { public: weak_ptr(const shared_ptr sp) :ptr(sp._ptr){} weak_ptr(const weak_ptr& wp) :ptr(wp.ptr){} weak_ptr& operator=(const weak_ptr& wp){ if (this != &wp){ ptr = wp.ptr; } return *this; } private: T* ptr; }; 2. 迭代器 template struct __list_node{ __list_node* prev; __list_node* next; T data; }; struct __list_iterator{ refernce operator*() const{return (*node).data;} pointer operator->() const{return &(operator*());} }; "},"1.C++/4.函数/":{"url":"1.C++/4.函数/","title":"4. 函数","keywords":"","body":""},"1.C++/4.函数/1.函数声明与定义.html":{"url":"1.C++/4.函数/1.函数声明与定义.html","title":"4.1 函数声明与定义","keywords":"","body":"函数声明 [[noreturn]] static inline auto func(const unsigned long int *const)->void const noexcept; 必选项：函数名，参数列表(可以为空())，返回类型 可选项： static链接说明 inline表示希望内联调用 constexpr返回类型为常量表达式时，可以在编译时求值 noexcept函数不允许抛出异常，，属性[[noreturn]]不会用常规调用、返回 函数需要调用，必须先定义。定义是特殊的函数声明，需要给出函数体 函数名就是函数地址func，func、*func、&func三者等价 函数返回值 引用：可作为左值 列表初始化： return {\"1\", \"2\"}; // vector对象 返回数组指针： i. 使用类型别名: using arrT = int[10]; arrT func(int i); // 返回指向10个整数数组的指针 int (func(int i))[10]; // 不使用类型别名 ii. 尾置返回类型: auto func(int i) -> int()[10]; iii. 使用decltype int arr[10]; decltype(arr) func(int i); 函数的重载： 同一作用域内的函数名字相同但形参列表不同，在不同的作用域中无法重载，只会覆盖 只重载相似操作的函数，给函数起不同的名字能使程序更容易理解（除非名字很难取） 重载和const形参:无法区分顶层const和普通形参 const_cast:将常量的引用转换回非常量的引用 特殊函数 构造函数：严格来说不是函数，没有返回值，无法得到其地址，可以初始化基类和成员，初始化时自动调用 析构函数：用来销毁函数对象，无法得到其地址 函数对象：是对象不是函数，不能被重载，其operator()是函数 lambda表达式：匿名函数对象，定义函数对象的一种简写形式 "},"1.C++/4.函数/2.函数参数与返回值.html":{"url":"1.C++/4.函数/2.函数参数与返回值.html","title":"4.2 函数参数与返回值","keywords":"","body":"不定参数 1. 实参类型都相同：initializer_list类模板 initializer_list提供的操作： initializer_list lst：默认初始化；T类型元素的空列表 initializer_list lst{a,b,c...}：lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const initializer_list ls;// 元素类型是string void error_msg(initializer_list ls){ for(auto beg = ls.begin(); beg != ls.end(); ++beg){ cout 2. 参数类型不同：可变参数的模板 ...参数列表 (前两种不可用时) "},"1.C++/4.函数/3.函数重载.html":{"url":"1.C++/4.函数/3.函数重载.html","title":"4.3 函数重载","keywords":"","body":"函数重载 重载和覆盖的区别 重载是在同一个类或作用域中，覆盖是在子类和父类中(不同作用域) 覆盖要求参数列表相同，重载要求参数列表不同，当虚函数返回类型或参数不一样时将会造成函数的隐藏而不是覆盖 覆盖的方法不能为private 覆盖返回类型必须一致(抛出异常也要一致)，重载可以不一致运算符重载 概念：运算符重载是通过函数实现的，本质上是函数重载。oprator是关键字，用来定义重载运算符的函数。可以将operator运算符看作函数名。 运算符函数或者是类的成员，或者至少含有一个类类型的参数（无法改变内置类型运算符的含义） 重载运算符的参数数量与该运算符作用的运算对象数量一样。当一个重载的运算符是成员函数时，左侧运算对象绑定到隐式的this指针上（函数体内用this作为参数）。因此成员运算符的显式参数数量比运算符运算对象少一个。 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变 重载不能改变运算符的优先级和结合性 运算符重载函数不能有默认的参数（否则就改变了运算符操作数的个数） 运算符重载函数既可以作为类的成员函数，也可以作为类的友元函数或普通函数（普通函数不能访问类的私有，极少用到） 运算符重载的格式： type operator 运算符名称(parm){ ... } 运算符重载的规则 箭头运算符->、下标运算符[]、函数调用运算符()、赋值运算符=只能以成员函数的形式重载 一般将单目运算符以及+=、-=、*=、/=（复合赋值运算符）重载为成员函数，将双目运算符重载为友元函数（因为成员函数的运算符左侧会绑定到对象） 双目运算符形参在参数表中的顺序任意，但在使用时左侧操作数需要与第一个参数对应，右侧操作数与第二个参数对应。数学上的交换律在此不适用，如果希望适用，应再次重载操作符并调整参数表顺序。 不能被重载的运算符 下列5个运算符不能被重载： :: .* . ?: sizeof 通常情况下，尽量避免逗号,、取地址&、逻辑与&&或and、逻辑或||或or运算符的重载 可以被重载的运算符 + - * / % ^ & | ~ ! = += -= *= /= % = ^= &= |= > >= == != = && || ++ -- , ->* -> () [] new new[] delete delete[] 示例1：重载+运算符 //以全局函数的形式重载`+` class Complex{ public: friend Complex operator+(const Complex &c1, const Complex &c2); //重载+运算符 } Complex operator+(const Complex &c1, const Complex &c2){ Complex c; c.real_ = c1.real_ + c2.real_; c.imag_ = c1.imag_ + c2.imag_; return c; } 示例2：重载复合赋值+=运算符 //以成员函数的形式重载+=，双目运算符，返回引用类型可作为左值 Complex & Complex::operator+=(const Complex &c){ this->real_ += c.real_; this->imag_ += c.imag_; return *this; } 示例3：重载输入输出运算符>>和 输入输出运算符必须是非成员函数，不能是成员函数，否则左侧运算对象将是当前类，无法完成输入。 // 以全局函数的形式重载>>，用来输入复数 istream &operator>>(istream &is, complex &A){//返回引用，目的为能够连续读取 is >> A.real_ >> A.imag_; return is; } 示例4：重载输出运算符 输出运算符应尽量减少格式化操作，以便让用户能控制输出的细节 //对输出运算符>>进行重载，让它能够输出复数 ostream &operator 示例5：重载下标运算符[] 单目运算符必须以成员函数形式进行重载，[]是后置运算符 //不仅可以访问元素，还可以修改 int &operator[](int i){ return data_[i]; } //只能访问不能修改，为了适应const int& Array::operator[](int i) const int &Array::operator[](int i) const{ return data_[i]; } 示例6：重载自增++和自减--运算符： 对++运算符以成员函数形式进行重载，有前置和后置两种形式 A &operator++(); //++i，前置形式。为了与内置保持一致应返回对象的引用 A operator++(int); //i++，后置形式，参数int没有意义，只是为了区分前置和后置 A::A &operator++(){ return run();//run返回增加后的值 } A::A operator++(int n){ A temp = *this; run(); return temp;//temp保存原来的值 } 示例7：重载new和delete运算符： 可以以成员函数形式或全局函数形式重载new运算符，在重载new或new[]时，无论是作为成员函数还是作为全局函数，它的第一个参数必须是size_t类型。size_t表示的是要分配空间的大小，对于new[]的重载函数而言，size_t则表示所需要分配的所有空间的总和。 void * className::operator new(size_t size){//成员函数形式 ... } void * operator new(size_t size){//全局函数形式 ... } 重载delete运算符，两种重载形式的返回值都是void类型，并且都必须有一个void类型的指针作为参数，该指针指向需要释放的内存空间。 void className::operator delete( void *ptr){//成员函数形式 ... } void operator delete( void *ptr){//全局函数形式 ... } "},"1.C++/4.函数/4.转换函数.html":{"url":"1.C++/4.函数/4.转换函数.html","title":"4.4 转换函数","keywords":"","body":"转换函数 转换函数(conversion function)：自定义类型转换函数，可以把目标类的类型转换为系统预定义类型的数据 ==注意：不同于其他运算符重载，转换函数没有返回类型，因为其返回类型在其操作符中== // 这是一个类的成员函数 operator type() const{ return type(); } 示例：自定义分数类转换成double类型 class Fraction { private: int numerator_; // 分子 int denomirator_; // 分母 public: Fraction(int numerator, int denomirator) :numerator_(numerator), denomirator_(denomirator){ }; // 转换函数 operator double() const{ return double(1.0*numerator_ / denomirator_); } }; 调用double时，会执行类型转换 Fraction f(3, 5); double d = 4 + f; //调用operator double()将f=3/5转换为0.6 非explicit单参数构造函数 当转换函数和非explicit单参数构造函数同时存在时，可能出现二义性造成编译错误 class Fraction { private: int numerator_; // 分子 int denomirator_; // 分母 public: // 加上默认参数，构成单参数构造函数 Fraction(int numerator, int denomirator=1) :numerator_(numerator), denomirator_(denomirator){ }; operator double() const{ return double(1.0*numerator_ / denomirator_); } Fraction operator+(){ return Fraction(...); } }; //in main() Fraction f(3, 5); // 编译器不知道调用构造函数将4转换为F(4,1), 然后调用operator+ // 还是Fraction d2 = 4.6，产生二义性 Fraction d2 = 4 + f; "},"1.C++/4.函数/5.函数对象与lambda表达式.html":{"url":"1.C++/4.函数/5.函数对象与lambda表达式.html","title":"4.5 函数对象与lambda表达式","keywords":"","body":"函数对象： 函数对象(FunctionObject)类型是可用在函数调用运算符左侧的对象的类型 1. 函数指针 函数指针：不同于函数或函数的引用，函数指针是对象，从而能存储于数组、被复制、被赋值等。 void f(int); void (*p1)(int) = &f; void (*p2)(int) = f; // 与 &f 相同 2. 仿函数(functor) 仿函数：实质上就是一个重载了operator()操作符的类，概念上是函数指针的功能。 函数对象可以将附加数据保存在成员变量中，从而实现携带附加数据，而函数指针不行。 将operator()设置为inline函数，可以提高速度 函数对象在概念上偏向于函数，而不是类。标准风格应使用结构体struct。 unary_function, binary_function与适配器兼容的一元函数、二元函数基类(C++11 中弃用)(C++17 中移除) struct Output{ void operator()(int __n){ cout v(5,100);//初始化vector，5个元素，元素值均为100 //依次输出vector的元素，这里传入的不是函数指针，而是一个类 for_each(v.begin(),v.end(),Output()); return 0; } // STL中for_each()函数可能实现： template UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f) { for (; first != last; ++first) { f(*first); } return f; // C++11 起隐式移动 } 仿函数的使用 函数中的调用： int main(){ vector v(5,100);//初始化vector，5个元素，元素值均为100 //依次输出vector的元素，这里传入的不是函数指针，而是一个类 for_each(v.begin(),v.end(),Output()); //这里的函数对象参数是output() return 0; } 类名直接调用 Output()(100); //输出100 类的对象调用 Output obj(); obj(100); 3. lambda表达式 lambda表达式的作用： 函数指针和仿函数较复杂，lambda表达式简洁，不需要实现类 匿名内包的形式不会产生多余的函数名 代码表达能力强，提高代码清晰度lambda的形式 [&a, b](int i) mutable{}noexcept -> int 最简单形式为[]{} []捕获列表，指明环境中哪些名字能用在lambda作用域内，以&为前缀的局部名字通过引用捕获，否则以值捕获 [=]值隐式捕获 [&]引用隐式捕获，所以局部变量都能捕获，通过引用访问 [捕获列表]显示捕获，只捕获列表中变量 [&, 捕获列表]捕获列表可以出现this，不能使用&; 不在列表中的变量引用隐式捕获 [=, 捕获列表]捕获列表不可以出现this，必须使用&; 不在列表中的变量值隐式捕获 ()参数列表，lambda函数所需参数，可选 mutable可选，可能会修改通过值捕获的变量的状态(不是通过引用捕获的变量的状态) noexcept可选，lambda不会发出异常 ->尾置类型，可选，声明返回的类型lambda与this lambda用在成员函数，把this添加到捕获列表，[this]通过指针访问，而非拷贝。[this]和[=]不兼容，所以在多线程中可能产生竞争。 lambda表达式类型: std::function 可以赋值给函数指针, R为返回类型 a. 给lambda起名字 auto name = &{...}; b. 赋值给函数指针(捕获列表必须为空) int (p)(int) = {return a+1}; c. 递归：使用递归函数之前必须知道函数返回类型 functionb, char e)> rev = [&](char b, char e){ if(b-e>1){swap(b,*--e); rev(++b, e);} } // 用来逆序char[]字符串 捕捉表达式（定义的是变量，不是函数，lambda需要有返回值） // 利用表达式捕获，可以更灵活地处理作用域内的变量 int x = 4; auto y = [&r = x, x = x + 1] { r += 2; return x x; }(); // 此时 x 更新为6，y 为25 // 直接用字面值初始化变量，此时z是const char 类型，不是函数 auto z = [str = \"string\"]{ return str; }(); 泛型lambda（和模板一样，参数类型自动推断） auto add = { return x + y; }; int x = add(2, 3); // 5 double y = add(2.5, 3.5); // 6.0 "},"1.C++/5.泛型/":{"url":"1.C++/5.泛型/","title":"5. 泛型","keywords":"","body":""},"1.C++/5.泛型/1.函数模板.html":{"url":"1.C++/5.泛型/1.函数模板.html","title":"5.1 函数模板","keywords":"","body":"函数模板(Function Template) 不同的参数实例化出不同的重载函数。例如，用五个不同参数实例化一个函数模板，相当于新定义了五个重载函数。 作用：函数模板是建立一个通用函数，用到的数据类型用虚拟类型替代，虚拟类型可以用于函数定义和函数声明，函数调用时再推导真正的类型。 template //模板头，和函数中间可以换行，但不能有分号 void swap(T &a,T &b);//函数声明，需要带上模板头。模板头和函数是一个整体。 template void swap(T &a,T &b){//和普通函数一样使用，不过要保持两个参数的一致 T temp = a; a = b; b = temp; } 类型参数可以有多个，它们之间以,分隔。类型参数列表以<>包围，形式参数列表以()包围 typename可以用class替代，两者没有区别 对于函数模板，编译器可以根据给定的数据推导出数据类型(类模板必须指定类型) //一个模板参数, a, b类型必须相同 int a = 0, b = 1; // 显示调用 swap(a, b); // 隐式调用（隐式参数类型推导） swap(a, b); 注意：模板类支持默认参数，模板函数不支持 "},"1.C++/5.泛型/2.类模板.html":{"url":"1.C++/5.泛型/2.类模板.html","title":"5.2 类模板","keywords":"","body":"类模板 和函数模板类似，模板类被实例化时实际产生一种新的类型，不同的参数实例化出不同的类型。 作用：和函数模板类似，可以将数据的类型参数化。声明了类模板后，就可以将类型参数用于类的成员函数和成员变量。 template class Point{ public: Point(T1 x,T2 y):x_(x), y_(y){} T1 getX(T1 x); T2 getY(T2 y); private: T1 x_; T2 y_; }; template T1 Point::getX(T1 x){//类名也要带上类型参数，不加typename return x_; } template T2 Point::getY(T2 y){ return y_; } // 栈上实例化： Point P2(1, 1.2); // 自由存储区实例化, 赋值号两边都要指明具体的数据类型, 且要保持一致： Point *pP1 = new Point(1,2); //（使用auto代替） auto *pP3 = new Point(1,2); 类名也要带上类型参数，不加typename 类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型 类外定义成员函数时仍然需要带上模板头 在类外定义成员函数时，template后面的类型参数要和类声明时的一致 注意：模板类支持默认参数，模板函数不支持 模板别名 作用：为模板设置别名并能够自己指定参数类型 template using vec = std::vector; vec v1{1, 2}; using vec_int = std::vector; vec_int v2{1, 2}; // 不使用模板只能事先定义模板参数 "},"1.C++/5.泛型/3.成员模板.html":{"url":"1.C++/5.泛型/3.成员模板.html","title":"5.3 成员模板","keywords":"","body":"成员模板 成员模板：类(普通类或模板类)可以包含本身是模板的成员函数。 成员模板不能是virtual函数。 1. 普通类的成员模板 与类模板的区别是，可以不用创建对象时指定模板参数 //完成一个删除器的类 class Deleter{ public: Deleter(){}; //重载operator(), 构成函数对象 template void operator()(T* p) const{ deleter p; } } //代替deleter操作 int* p = new int{0}; Deleter d; d(p); 2. 类模板的成员模板 类模板也可以定义成员模板，此时类和成员的模板参数独立 作用：模板拷贝构造函数可以进行不同参数类模板之间的类型转换，也可以在构造函数中用来作向上转型(基类智能指针指向派生类对象) template struct Point{ T x_; T y_; Point(T x,T y):x_(x), y_(y){} template Point(const Point& p): x_(static_cast(p.x_)), y_(static_cast(p.y_)){} } // 可以用double模板的类拷贝构造int模板的类 Point d1{1.0, 2.0}; Point d2(d1); // 在外部定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表 template template Point::Point(){...} "},"1.C++/5.泛型/4.模板特化与偏特化.html":{"url":"1.C++/5.泛型/4.模板特化与偏特化.html","title":"5.4 模板特化与偏特化","keywords":"","body":"模板特化 作用：也称为模板全特化，可以对某些特定的类型进行特殊的处理(例如某个算法对int类型的点有更快的处理方法) template struct hash{}; // 对int类型进行模板特化 template<> struct hash{ // ... }; 模板偏特化 参数偏特化 作用：多个模板参数时，对其中某个模板参数进行特化 template class Point{ // ... }; // 对TypeA进行偏特化 template class Point{ // ... }; 范围偏特化 作用：可以对模板参数的某种类型(例如指针)进行特化 template class C{}; // 对指针类型进行偏特化 template class C{ // ... }; // 两个对象初始化将执行不同地方的代码 C obj1; C obj2; "},"1.C++/5.泛型/5.可变参数模板与模板模板参数.html":{"url":"1.C++/5.泛型/5.可变参数模板与模板模板参数.html","title":"5.5 可变参数模板与模板参数","keywords":"","body":"可变参数模板 // 出口函数 void print(){} template void print(const T& firstArg,const Types&... Args){ std::cout ...用于模板参数，是一个模板参数包 ...用于函数参数，是一个函数参数包 ...用于函数参数类型，是一个函数参数类型包 sizeof...(Args)，参数数量 模板模板参数 "},"1.C++/6.断言与异常/":{"url":"1.C++/6.断言与异常/","title":"6. 错误与异常","keywords":"","body":""},"1.C++/6.断言与异常/1.断言.html":{"url":"1.C++/6.断言与异常/1.断言.html","title":"6.1 断言","keywords":"","body":""},"1.C++/6.断言与异常/2.异常.html":{"url":"1.C++/6.断言与异常/2.异常.html","title":"6.1 异常","keywords":"","body":""},"1.C++/7.内存模型/":{"url":"1.C++/7.内存模型/","title":"7. 内存模型","keywords":"","body":""},"1.C++/7.内存模型/1.内存空间模型.html":{"url":"1.C++/7.内存模型/1.内存空间模型.html","title":"7.1 内存空间模型","keywords":"","body":"虚拟内存分布 // TODO C++内存空间分配 "},"1.C++/7.内存模型/2.内存、堆、栈.html":{"url":"1.C++/7.内存模型/2.内存、堆、栈.html","title":"7.2 内存、堆、栈","keywords":"","body":"内存 一般应用程序内存空间有如下区域： 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据栈 栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面： • 函数的返回地址和参数 • 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 • 保存上下文：包括函数调用前后需要保持不变的寄存器堆 堆分配算法： • 空闲链表（Free List） • 位图（Bitmap） • 对象池 https://www.yuque.com/huihut/interview/readme?inner=762d3cc0 “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write” 典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。 普遍原因： • 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针 • 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针 "},"1.C++/7.内存模型/3.new和delete.html":{"url":"1.C++/7.内存模型/3.new和delete.html","title":"7.3 new和delete","keywords":"","body":"new和delete new/delete、new[]/delete[]位于头文件中，返回类型为指向其类型初始化对象的指针，不负责初始化得到的内存 void *operator new(size_t); void *operator new[](size_t); void *operator delete(void *p); void *operator delete[](void *p); 1. new操作符 先分配内存，再调用ctor(构造函数)，内部调用malloc() // Complex* pc = new Complex(1, 2); // 编译器自动转换为 Complex *pc; void* mem = operator malloc(sizeof(Complex));//内部调用malloc pc = static_cast(mem); pc->Complex::Complex(1, 2); 没有多余内存时会抛出bad_alloc异常，有的程序不允许异常，可以使用noexcept版本： void *oparator new(size_t, const nothrow_t&) noexcept; void *oparator delete(void *pt, const nothrow_t&) noexcept; int *p = new(nothrow) int[10]; delete(nothrow, p); 在指定地方分配对象： void *operator new(size_t, void *p){return p;} X *p = new{buf} X; // 在buf处构建X 2. delete操作符 先调用dtor析构函数，再释放内存，内部调用free() 3. delete和delete[]区别与联系 new[]一定要搭配delete[]，否则会造成少调用析构函数 string *p = new string[3]; ... delete[] p; //调用3次dtor string *p = new string[3]; ... delete p; //调用1次dtor 4. new/delete和malloc/free的区别 new/delete和malloc/free成对使用，不要混合使用： 当使用free()释放new申请的内存时，可能会导致没有调用对象的析构函数 C++没有规定new实现的标准，有的编译器可能不是使用malloc()实现； operator new可以被重载，可能会引发其他的错误 堆是操作系统维护的一块内存，而自由存储是C++中通过new/delete动态分配和释放对象的抽象概念(类似于顺序表与线性表的关系)。堆与自由存储区并不等价。自由存储区可以由堆实现，也可以用其他内存 "},"1.C++/7.内存模型/4.内存对齐、类对象大小和空基类优化.html":{"url":"1.C++/7.内存模型/4.内存对齐、类对象大小和空基类优化.html","title":"7.4 内存对齐、类对象大小和空基类优化","keywords":"","body":"1. 内存对齐 对齐规则： #pragram pack(n) 表示的是设置n字节对齐，VC默认8，gcc默认4 结构体内数据成员对齐，min(数据成员, n)，成员偏移量必须在这个数的倍数的地址上 结构体对齐，整个结构体大小一定是min(最大数据成员, n)的倍数 class Data1 { char c; // 偏移量在1 }; // 内存布局为 1 class Data2 { char c; // 偏移量在1 int a; // 偏移量在4 char d; // 偏移量在9 // 整体为4的倍数 }; // 内存布局为 1 _ _ _ | 4 4 4 4 1 _ _ _ _ class Data3 { char c; // 偏移量在1 int a; // 偏移量在4 char c2; // 偏移量在9 double d; // 偏移量在16 // 整体为4的倍数 }; // 内存布局为 1 _ _ _ | 4 4 4 4 | 1 _ _ _ _ _ _ _ _ | 8 8 8 8 8 8 8 8 | cout 2. 类对象大小 ==类对象的大小== ： 数据成员的总和 + vfptr指针大小 + vbptr指针大小 + 编译器内存对齐增加的字节。 包括父类的非static数据成员，不包括所有的成员函数。虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类象的存储空间的 由于空基类优化，空类、单一继承的空类、多重继承的空类所占空间大小为：1字节 当类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器自动在对象里安插一个指针vPtr指向虚函数表VTable，多继承下可能不止一个，单继承时虚函数个数不会影响类对象大小； 虚承继的情况：由于涉及到虚函数表和虚基表，会同时增加一个（多重虚继承下对应多个）vfPtr指针指向虚函数表vfTable和一个vbPtr指针指向虚基表vbTable，这两者所占的空间大小总共为：8（或8乘以多继承时父类的个数）； 3. 空基类优化： 作用：当存在空的基类子对象，子类可以将其默认规定的占位字节忽略 为保证同一类型的不同对象地址始终有别，要求任何对象或成员子对象的大小至少为 1，即使该类型是空的类。 然而，空基类的子类对象不受这种制约，而且可以完全从对象布局中被优化掉 例外：第一个非静态数据成员为空基类对象时，禁用空基类优化 #include struct Base {}; // 空类 struct Derived1 : Base { int i; }; struct Derived2: Base { Base a; int i; } int main() { // 任何空类类型的对象大小至少为 1 assert(sizeof(Base) > 0); // 应用空基类优化，判定为True assert(sizeof(Derived1) == sizeof(int)); // 第一个非静态数据成员为空基类对象时，禁用空基类优化 assert(sizeof(Derived2) == 2*sizeof(int)); } "},"1.C++/7.内存模型/5.内存泄漏与解决.html":{"url":"1.C++/7.内存模型/5.内存泄漏与解决.html","title":"7.5 内存泄漏与解决","keywords":"","body":"// TODO RAII资源获取是初始化 RAII（Resource Acquisition Is Initialization） RAII 可以帮助我们将管理堆上的内存，简化为管理栈上的内存，从而达到利用编译器自动解决内存回收问题的效果 智能指针 "},"1.C++/7.内存模型/6.智能指针.html":{"url":"1.C++/7.内存模型/6.智能指针.html","title":"7.6 智能指针","keywords":"","body":"智能指针 作用：智能指针表达所有权，位于中，智能指针自身被销毁时，会自动销毁指针指向的对象。能有效解决内存泄漏问题。 1. auto_ptr 自C++11开始已经弃用 2. unique_ptr unique_ptr拥有互斥的所有权 拥有一个对象，保存一个指针，并负责用释放器销毁对象(默认版本无释放器，直接调用delete) 不能拷贝，但可以移动 3. shared_ptr 智能指针的实现见类似指针的类 shared_ptr拥有共享的所有权 由引用计数实现，当计数为0时才销毁负责的对象 可以理解为包含两个指针的结构：一个指向对象，一个指向计数器 尽量使用unique_ptr，因为shared_ptr：循环链表可能资源泄漏(需要weak_ptr打破)、资源占用更高、多线程防止计数的数据竞争代价很高 4. weak_ptr 智能指针的循环引用 weak_ptr结合shared_ptr使用，打破循环共享数据的回路 指向一个shared_ptr管理的对象，为了访问对象，可以使用成员函数lock()将其转换为shared_ptr // TODO weak_ptr如何打破循环引用 "},"1.C++/7.内存模型/7.虚函数表与虚指针.html":{"url":"1.C++/7.内存模型/7.虚函数表与虚指针.html","title":"7.7 虚函数表与虚指针","keywords":"","body":"虚函数表与虚指针 虚函数底层实现：每个类对象中都存在一个虚函数表指针vfptr指向当前类的虚函数表vtbl，虚函数表中存储着对应虚函数的地址，同一个类的不同实例共用同一份虚函数表，编译时期创建。 存在继承的情况：继承类的虚函数表被加在基类的后面，多继承时哪个类拥有虚函数，位置就越靠前，同时虚函数表加到该基类后面。如果基类都没有虚函数则直接指向当前类的虚函数表。 类B继承于A，A中存在虚函数vfunc1()和vfunc2()，B中覆盖了A中的虚函数vfunc1()和非虚成员函数func2()，如下述代码所示： class A{ public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int data1_; }; class B:public A{ public: virtual void vfunc1(); void func2(); private: int data2_; }; 虚函数表和虚函数的地址 A obj{}; printf(\"Address of vtbl: %p\\n\", *(int*)&obj); // 虚函数表地址 printf(\"Address of vfunc1: %p\\n\", *(int*)*(int*)&obj); // 第一个虚函数地址 printf(\"Address of vfunc2: %p\\n\", *((int*)*(int*)&obj + 1)); // 第二个虚函数地址 虚函数表vtbl的结构模型 橙色线框中的内容仅限于虚拟继承的情形（若无虚继承，则无此内容） “offset to top”是指到对象起始地址的偏移值，只有多重继承的情形才有可能不为0，单继承或无继承的情形都为0。 “RTTI information”是一个对象指针，它用于唯一地标识该类型。 “virtual function pointers”也就是我们之前理解的虚函数表指针，其中存放着虚函数指针列表。 虚函数指针__vfptr位于所有的成员变量之前定义 "},"1.C++/8.STL标准库/":{"url":"1.C++/8.STL标准库/","title":"8. STL标准库","keywords":"","body":"STL索引 STL详细文档 "},"1.C++/8.STL标准库/1.STL容器.html":{"url":"1.C++/8.STL标准库/1.STL容器.html","title":"8.1 STL容器","keywords":"","body":"顺序容器 基于范围的for循环 能自动遍历整个容器（数组、vector对象等），不需要知道数组的长度，语句简洁 //遍历数组的元素 int arr[] {1, 2, 3, }; for(auto& elem:arr){//改变数组元素的值，所以用引用 elem += 2; std::cout 1. 字符串string string类需要包含头文件，以及命名空间std，其不同于C风格字符串，末尾没有'\\0'，长度为真实长度 初始化： string s; //空字符串 string s = \"C plus plus\" ; //初始化，结尾没有'\\0' string s(\"C plus plus\"); string s(5, 's'); //初始化成\"sssss\" 原始字符串：用于正则表达式的字符串, 括号内就是原始的字符串，不需要用转义符号\\ string s = R\"(\\hello)\"; // \"\\hello\" string s = R\"***(\"hello\"(()())***\"; // 自定义定界符 )***\"这一部分，)和\"中间可以是任意符号，但是必须和\"***(匹配 string类常用： string.size() string.c_str() 转换为C风格字符串（例如打开文件时的路径） \"+\"\"+=\" 和变量一样拼接字符串 插入字符串原型 string& insert(size_t pos,const string& str);//pos表示插入位置（下标），str为要插入字符串，可以是string，也可以是C风格，string.insert(5,\"hello\") 删除字符串原型 string& erase(size_t pos=0,size_t len=npos);//pos表示删除子字符串起始下标，len为长度，若不指明len，将删除到结束的所有字符，string.erase(5,3)。最多只能删除到字符串结尾，若pos越界会抛出异常 提取子字符串原型 string substr(size_t pos=0,size_t len=npos) const;//pos为要提取字符串起始下标,len为长度。string2=string1.substr(6,6)。pos越界会抛出异常，len越界会提取到结尾 字符串查找 size_t find(const string& str或char *s,size_t pos=0) const;//str为待查找字符串，pos为开始查找下标，若没找到返回无穷大值INF rfind函数查找到pos处 string1.find_first_of(string2);//查找s2字符串和s1字符串共同具有的字符在字符串中首次出现的位置 将字符串转换为整数 stoi(str) 格式化字符串boost::format 2. 动态数组vector 作用： 封装任何类型的动态数组，自动创建、释放(只有调用析构函数时，无法随着大小动态释放) 数组下标越界检查 构建vector对象 vector对象可以高效添加元素，在初始时设定大小可能效率更差 #include std::vector a(n);//建立大小为n的int数组（vector） std::vector arr {1, 2, 3,}; std::vector a;//空的vector，运行中动态改变大小 vector a(n,1);//n个元素全初始化为1 其他vector操作： ```cpp v.push_back(i) 添加元素，把i放在arr尾端 v.pop_back() 删除最后一个元素 v.empty() 判断是否为空 v.size() 返回元素个数 v1 = v2 将v2拷贝到v1 v1 == v2 判断是否相等 !=,,>=v.clear() 令size = 0 v.shrink_to_fit() 将容器可存储空间缩小到size大小，可以配合clear动态释放内存 ``` 注意：不能在范围for循环中向vector对象添加元素，添加元素操作将会使迭代器失效 3. 双端队列deque 4. 双链表list 关联容器 1. map 2. multimap 3. set 4. multiset "},"1.C++/8.STL标准库/2.适配器.html":{"url":"1.C++/8.STL标准库/2.适配器.html","title":"8.2 适配器","keywords":"","body":"容器适配器 1. 栈stack 2. 队列queue 3. 优先队列priority_queue "},"1.C++/8.STL标准库/3.STL容器的操作.html":{"url":"1.C++/8.STL标准库/3.STL容器的操作.html","title":"8.3 STL容器的操作","keywords":"","body":"标准容器的方法 ?表明这些操作有些容器不支持： milti* 关联容器不提供[]或at() forward_list不提供insert()/erase()/back()/push_back()/pop_back()或emplace()，但是提供*_after forward_list不提供reverse_iterator/const_reverse_iterator/rbegin()/rend()/crbegin()/crend()及size() unordered_* 关联容器不提供//>/>= 标准容器的遍历 1. 迭代器 访问string对象字符或vector对象的元素可以使用下标，也可以使用另一种更通用的机制：迭代器 标准库容器（如vector）都可以使用迭代器（string不属于容器，但支持迭代器） 访问安全，但性能比指针低 vector arr(3); auto b = arr.begin();//类似于指针类型，使用方法和指针一样 auto e = arr.end();//尾后迭代器（尾迭代器的下一位置） // 使用迭代器进行迭代 for(auto it = b; it != b; ++it){ ... } // 迭代器运算 iter += n //向前移动n个元素 iter -= n //向后移动n个元素 iter1 - iter2 //距离 没有iter1 + iter2的操作定义 有些容器没有定义运算符，但是都定义了==和!=，使用迭代器和!=就不用在意容器的类型 向容器添加元素或删除元素将会使迭代器失效。每次改变容器后都得正确的重新定位迭代器，原来位置的迭代器值未知 cbegin()/cend()，无论可迭代对象是不是常量，返回的迭代器都是常量，可以读不能修改 rbegin()和rend()用于从后向前的迭代访问 "},"1.C++/8.STL标准库/4.迭代器.html":{"url":"1.C++/8.STL标准库/4.迭代器.html","title":"8.4 迭代器","keywords":"","body":" 容器 迭代器功能 vector 随机访问 deque 随机访问 list 双向 set / multiset 双向 map / multimap 双向 stack 不支持迭代器 queue 不支持迭代器 priority_queue 不支持迭代器 advance(p, n)：使迭代器 p 向前或向后移动 n 个元素。 distance(p, q)：计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。 iter_swap(p, q)：用于交换两个迭代器 p、q 指向的值。 "},"1.C++/8.STL标准库/5.algorithm.html":{"url":"1.C++/8.STL标准库/5.algorithm.html","title":"8.5 algorithm","keywords":"","body":"STL通用算法 中函数都是函数模板在元素范围上操作，范围定义为[first, last) 不修改序列的操作 函数 作用 all_of()any_of()none_of() (C++11)检查谓词是否对范围中所有、任一或无元素为true for_each() 应用函数到范围中的元素 for_each_n() (C++17)应用一个函数对象到序列的前 n 个元素 count() count_if() 返回满足指定判别标准的元素数 mismatch() 寻找两个范围出现不同的首个位置 find()find_if()find_if_not() (C++11)寻找首个满足特定判别标准的元素 find_end() 在特定范围中寻找最后出现的元素序列 find_first_of() 搜索元素集合中的任意元素 adjacent_find() 查找首对相邻的相同（或满足给定谓词的）元素 search() 搜索一个元素范围 search_n() 在范围中搜索一定量的某个元素的连续副本 修改序列的操作 函数 作用 copy()copy_if() (C++11)将某一范围的元素复制到一个新的位置 copy_n() (C++11)将一定数目的元素复制到一个新的位置 copy_backward() 按从后往前的顺序复制一个范围内的元素 move() (C++11)将某一范围的元素移动到一个新的位置 move_backward (C++11)按从后往前的顺序移动某一范围的元素到新的位置 fill() 将一个给定值复制赋值给一个范围内的每个元素 fill_n() 将一个给定值复制赋值给一个范围内的 N 个元素 transform() 将一个函数应用于某一范围的各个元素 generate() 将相继的函数调用结果赋值给一个范围中的每个元素 generate_n() 将相继的函数调用结果赋值给一个范围中的 N 个元素 remove()remove_if() 移除满足特定判别标准的元素 remove_copy()remove_copy_if() 复制一个范围的元素，忽略满足特定判别标准的元素 replace()replace_if() 将所有满足特定判别标准的值替换为另一个值 replace_copy()replace_copy_if() 复制一个范围内的元素，并将满足特定判别标准的元素替换为另一个值 swap() 交换两个对象的值 swap_ranges() 交换两个范围的元素 iter_swap() 交换两个迭代器所指向的元素 reverse() 逆转范围中的元素顺序 reverse_copy() 创建一个范围的逆向副本 shift_left()shift_right() (C++20)迁移范围中的元素 rotate() 旋转范围中的元素顺序 rotate_copy() 复制并旋转元素范围 random_shuffle()shuffle() (C++17 前)(C++11)随机重排范围中的元素 sample() (C++17)从一个序列中随机选择 n 个元素 unique() 移除范围内的连续重复元素 unique_copy() 创建某范围的不含连续重复元素的副本 划分操作 函数 作用 is_partitioned() (C++11)判断范围是否已按给定的谓词划分 partition() 将范围中的元素分为两组 partition_copy() (C++11)复制一个范围，将各元素分为两组 stable_partition() 将元素分为两组，同时保留其相对顺序 partition_point() (C++11)定位已划分范围的划分点 排序操作 函数 作用 is_sorted()(C++11) 检查范围是否已按升序排列 is_sorted_until()(C++11) 找出最大的已排序子范围 sort() 将范围按升序排序 partial_sort() 排序一个范围的前 N 个元素 partial_sort_copy() 对范围内的元素进行复制并部分排序 stable_sort() 将范围内的元素排序，同时保持相等的元素之间的顺序 nth_element() 将给定的范围部分排序，确保其按给定元素划分 二分搜索操作 函数 作用 lower_bound() 返回指向第一个不小于给定值的元素的迭代器 upper_bound() 返回指向第一个大于给定值的元素的迭代器 binary_search() 确定元素是否存在于某范围中 equal_range() 返回匹配特定键值的元素范围 集合操作（已排序范围） 函数 作用 merge() 归并两个已排序的范围 inplace_merge() 就地归并两个有序范围 includes() 若一个集合是另一个的子集则返回true set_difference() 计算两个集合的差集 set_intersection() 计算两个集合的交集 set_symmetric_difference() 计算两个集合的对称差 set_union() 计算两个集合的并集 堆操作 函数 作用 is_heap() 检查给定范围是否为一个最大堆 is_heap_until() (C++11)查找能成为最大堆的最大子范围 make_heap() 从一个元素范围创建出一个最大堆 push_heap() 将一个元素加入到一个最大堆 pop_heap() 从最大堆中移除最大元素 sort_heap() 将一个最大堆变成一个按升序排序的元素范围 最大/最小操作 函数 作用 max() 返回各给定值中的较大者 max_element() 返回范围内的最大元素 min() 返回各给定值中的较小者 min_element() 返回范围内的最小元素 minmax() (C++11)返回两个元素的较小和较大者 minmax_element() (C++11)返回范围内的最小元素和最大元素 clamp() (C++17)在一对边界值间夹逼一个值 比较操作 函数 作用 equal() 确定两个元素集合是否是相同的 lexicographical_compare() 当一个范围按字典顺序小于另一个范围时，返回true lexicographical_compare_three_way() (C++20)用三路比较比较两个范围 排列操作 函数 作用 is_permutation() (C++11)判断一个序列是否为另一个序列的排列 next_permutation() 产生某个元素范围的按字典顺序的下一个较大的排列 prev_permutation() 产生某个元素范围的按字典顺序的下一个较小的排列 数值运算 函数 作用 iota() 用从起始值开始连续递增的值填充一个范围 (C++11) accumulate() 对一个范围内的元素求和 inner_product() 计算两个范围的元素的内积 adjacent_difference() 计算范围内各相邻元素之间的差 partial_sum() 计算范围内元素的部分和 reduce() 类似std::accumulate，但不依序执行(C++17) exclusive_scan() 类似std::partial_sum，第 i 个和中排除第 i 个输入(C++17) inclusive_scan() 类似std::partial_sum，第 i 个和中包含第 i 个输入(C++17) transform_reduce() 应用一个函数对象，然后以乱序规约(C++17) transform_exclusive_scan() 应用一个函数对象，然后进行排除扫描(C++17) transform_inclusive_scan() 应用一个函数对象，然后进行包含扫描(C++17) 为初始化内存上的操作 函数 作用 uninitialized_copy() 将范围内的对象复制到未初始化的内存区域 uninitialized_copy_n() 将指定数量的对象复制到未初始化的内存区域(C++11) uninitialized_fill() 复制一个对象到以范围定义的未初始化内存区域 uninitialized_fill_n() 复制一个对象到以起点和计数定义的未初始化内存区域 uninitialized_move() 移动一个范围的对象到未初始化的内存区域(C++17) uninitialized_move_n() 移动一定数量对象到未初始化内存区域(C++17) uninitialized_default_construct() 在范围所定义的未初始化的内存区域以默认初始化构造对象(C++17) uninitialized_default_construct_n() 在起始和计数所定义的未初始化内存区域用默认初始化构造对象(C++17) uninitialized_value_construct() 在范围所定义的未初始化内存中用值初始化构造对象(C++17) uninitialized_value_construct_n() 在起始和计数所定义的未初始化内存区域以值初始化构造对象(C++17) destroy_at() 销毁在给定地址的对象(C++17) destroy() 销毁一个范围中的对象(C++17) destroy_n() 销毁范围中一定数量的对象(C++17) "},"1.C++/8.STL标准库/6.附：STL速查表.html":{"url":"1.C++/8.STL标准库/6.附：STL速查表.html","title":"附：STL速查表","keywords":"","body":"STL索引 STL详细文档 字符串和整数 atoi() itoa() 数据结构 数组 链表 栈 队列 堆 优先队列priority_queue 哈希表 数学 随机数 整数和浮点数 include const int l = 1; const int r = 5; std::mt19937 gen{std::random_device{}()}; std::uniform_int_distribution<> dis1(l, r); std::uniform_real_distribution<> dis2(l, r); // 整数 int a = dis1(gen); // C语言方法 int a1 = rand()%(r - l + 1) + l; // 浮点数 double b = dis2(gen); "},"1.C++/9.设计模式/":{"url":"1.C++/9.设计模式/","title":"9. 设计模式","keywords":"","body":""},"1.C++/9.设计模式/1.单例模式.html":{"url":"1.C++/9.设计模式/1.单例模式.html","title":"9.1 单例模式","keywords":"","body":"作用：确保一个类只有一个实例，并提供该实例的全局访问点。 实现: 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。 // 懒汉式单例模式 class Singleton { private: Singleton() { } static Singleton * pInstance; public: static Singleton * GetInstance() { if (pInstance == nullptr) pInstance = new Singleton(); return pInstance; } }; // 线程安全的单例模式 class Singleton { private: Singleton() { } ~Singleton() { } Singleton(const Singleton &); Singleton & operator = (const Singleton &); public: static Singleton & GetInstance() { static Singleton instance; return instance; } }; "},"1.C++/9.设计模式/2.工厂模式.html":{"url":"1.C++/9.设计模式/2.工厂模式.html","title":"9.2 工厂模式","keywords":"","body":"简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。 在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。 // 抽象工厂模式 class Factory { public: enum FACTORY_TYPE { BENZ_FACTORY, // 奔驰工厂 BMW_FACTORY, // 宝马工厂 AUDI_FACTORY // 奥迪工厂 }; virtual ICar* CreateCar() = 0; // 生产汽车 virtual IBike* CreateBike() = 0; // 生产自行车 static Factory * CreateFactory(FACTORY_TYPE factory); // 创建工厂 }; // TODO 完成设计模式 "},"1.C++/9.设计模式/3.代理模式.html":{"url":"1.C++/9.设计模式/3.代理模式.html","title":"9.3 代理模式","keywords":"","body":""},"1.C++/9.设计模式/4.策略模式.html":{"url":"1.C++/9.设计模式/4.策略模式.html","title":"9.4 策略模式","keywords":"","body":""},"1.C++/9.设计模式/5.模板方法模式.html":{"url":"1.C++/9.设计模式/5.模板方法模式.html","title":"9.5 模板方法模式","keywords":"","body":""},"2.数据结构与算法/":{"url":"2.数据结构与算法/","title":"第二部分 数据结构与算法","keywords":"","body":""},"2.数据结构与算法/1.排序与查找/":{"url":"2.数据结构与算法/1.排序与查找/","title":"1. 排序与查找","keywords":"","body":""},"2.数据结构与算法/1.排序与查找/1.排序算法.html":{"url":"2.数据结构与算法/1.排序与查找/1.排序算法.html","title":"1.1 排序算法","keywords":"","body":" 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性 冒泡排序 $O(n^2)$ $O(n^2)$ $O(1)$ 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(1)$ 数组不稳定、链表稳定 插入排序 $O(n^2)$ ) $O(n^2)$ $O(1)$ 稳定 快速排序 $O(n*log_2n)$ $O(n^2)$ O(log2n) 不稳定 堆排序 $O(n*log_2n)$ $O(n*log_2n)$ $O(1)$ 不稳定 归并排序 $O(n*log_2n)$ $O(n*log_2n)$ $O(n)$ 稳定 希尔排序 $O(n*log_2n)$ $O(n^2)$ $O(1)$ 不稳定 计数排序 $O(n+m)$ $O(n+m)$ $O(n+m)$ 稳定 桶排序 $O(n)$ $O(n)$ $O(m)$ 稳定 基数排序 $O(k*n)$ $O(n^2)$ 稳定 冒泡排序 原理：(从头部到尾部)每一次比较相邻元素，将最大元素移动到数组尾部，重复这个步骤 优化：设定一个标志，如果没有发生交换则已经有序，排序完成 vector bubble_sort(const vector& vec) { int n = vec.size(); auto vec1 = vec; for (int i = 0; i i; j--) { if (vec1[j] 选择排序 原理：从剩余未排序序列找出最大（最小）元素放到序列尾部（头部），重复这个步骤 vector selection_sort(const vector& vec) { int n = vec.size(); auto vec_copy = vec; for (int i = 0; i 插入排序 原理：将待排序序列每个元素插入到前面已排序序列合适的位置 优化：用一个变量保存待插入元素，将大于该数的元素后移，用赋值代替交换 插入排序用于接近有序的数组效率是最高的 // 插入排序 vector insertion_sort(const vector& vec) { int n = vec.size(); auto vec_copy = vec; for (int i = 1; i 0 and elem 希尔排序 原理： // 希尔排序：每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。 template void shell_sort(T array[], int length) { int h = 1; while (h = 1) { for (int i = h; i = h && array[j] 归并排序 原理：分治，将两个有序序列合并成一个有序数列。可以将序列从中间分成两部分，递归进行 优化：当归并的左边序列都比右边小时，可以不用执行归并 自顶向下(递归) //递归的归并排序 void merge(vector& vec, int l, int mid, int r) { vector tmp(begin(vec) + l, begin(vec) + r + 1); int i = 0, j = mid + 1 - l, k = l; while (i & vec, int l, int r) { if (l > 1); _merge_sort(vec, l, mid); _merge_sort(vec, mid + 1, r); // 优化，当左边序列有比右边序列大的数才执行归并 if (vec[mid] > vec[mid + 1]) merge(vec, l, mid, r); } } // 对输入参数进行统一 void merge_sort(vector& vec) { int n = vec.size(); _merge_sort(vec, 0, n - 1); } 自底向上(迭代) // 自底向上的归并算法 void merge_sort_BU(vector& vec) { int n = vec.size(); for (int sz = 1; sz 快速排序 原理：分治，从序列中选一个基准数，将小于该数的移到序列左边，大于该数的移到右边， 该数就放在了正确的位置上；对左边序列和右边序列递归执行 优化：随机选择基准，避免在对接近有序序列排序的效率退化；序列中重复元素很多时可以选择三路快排 // 快速排序 // 划分操作 int partition(vector& vec, int l, int r) { // 优化1：随机选择基准 swap(vec[l], vec[rand() % (r - l + 1) + l]); int elem = vec[l]; int lt = l; for (int i = l + 1; i & vec, int l, int r) { // 优化1：随机选择基准 swap(vec[l], vec[rand() % (r - l + 1) + l]); int elem = vec[l]; // [l+1,lt]e int lt = l, gt = r + 1; for (int i = l + 1; i elem) { // gt-1处元素大小未知，交换之后继续处理 swap(vec[i], vec[--gt]); } else { i++; } } swap(vec[l], vec[lt]); return lt; } void _quick_sort(vector& vec, int l, int r) { if (l & vec) { int n = vec.size(); _quick_sort(vec, 0, n - 1); } 堆排序 原理： // 堆排序：（最大堆，有序区）。从堆顶把根卸出来放在有序区之前，再恢复堆。 void max_heapify(int arr[], int start, int end) { //建立父節點指標和子節點指標 int dad = start; int son = dad * 2 + 1; while (son arr[son]) //如果父節點大於子節點代表調整完畢，直接跳出函數 return; else { //否則交換父子內容再繼續子節點和孫節點比較 swap(arr[dad], arr[son]); dad = son; son = dad * 2 + 1; } } } void heap_sort(int arr[], int len) { //初始化，i從最後一個父節點開始調整 for (int i = len / 2 - 1; i >= 0; i--) max_heapify(arr, i, len - 1); //先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢 for (int i = len - 1; i > 0; i--) { swap(arr[0], arr[i]); max_heapify(arr, 0, i - 1); } } 计数排序 原理： /* 算法的步骤如下： 1. 找出待排序的数组中最大和最小的元素 2. 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项 3. 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加） 4. 反向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1 *****************/ // 计数排序 void CountSort(vector& vecRaw, vector& vecObj) { // 确保待排序容器非空 if (vecRaw.size() == 0) return; // 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小 int vecCountLength = (*max_element(begin(vecRaw), end(vecRaw))) + 1; vector vecCount(vecCountLength, 0); // 统计每个键值出现的次数 for (int i = 0; i 0; i--) // 此处逆序是为了保持相同键值的稳定性 vecObj[--vecCount[vecRaw[i - 1]]] = vecRaw[i - 1]; } 桶排序 原理：将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。 /***************** 桶排序：将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。 桶排序序思路： 1. 设置一个定量的数组当作空桶子。 2. 寻访序列，并且把项目一个一个放到对应的桶子去。 3. 对每个不是空的桶子进行排序。 4. 从不是空的桶子里把项目再放回原来的序列中。 假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序，然后把各个桶中的数据合并。 *****************/ const int BUCKET_NUM = 10; struct ListNode{ explicit ListNode(int i=0):mData(i),mNext(NULL){} ListNode* mNext; int mData; }; ListNode* insert(ListNode* head,int val){ ListNode dummyNode; ListNode *newNode = new ListNode(val); ListNode *pre,*curr; dummyNode.mNext = head; pre = &dummyNode; curr = head; while(NULL!=curr && curr->mDatamNext; } newNode->mNext = curr; pre->mNext = newNode; return dummyNode.mNext; } ListNode* Merge(ListNode *head1,ListNode *head2){ ListNode dummyNode; ListNode *dummy = &dummyNode; while(NULL!=head1 && NULL!=head2){ if(head1->mData mData){ dummy->mNext = head1; head1 = head1->mNext; }else{ dummy->mNext = head2; head2 = head2->mNext; } dummy = dummy->mNext; } if(NULL!=head1) dummy->mNext = head1; if(NULL!=head2) dummy->mNext = head2; return dummyNode.mNext; } void BucketSort(int n,int arr[]){ vector buckets(BUCKET_NUM,(ListNode*)(0)); for(int i=0;imData; head = head->mNext; } } 基数排序 原理：基数排序：一种多关键字的排序算法，可用桶排序实现。 int maxbit(int data[], int n) //辅助函数，求数据的最大位数 { int maxData = data[0]; ///= p) { //p *= 10; // Maybe overflow maxData /= 10; ++d; } return d; /* int d = 1; //保存最大的位数 int p = 10; for(int i = 0; i = p) { p *= 10; ++d; } } return d;*/ } void radixsort(int data[], int n) //基数排序 { int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for(i = 1; i = 0; j--) //将所有桶中记录依次收集到tmp中 { k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; } for(j = 0; j "},"2.数据结构与算法/2.数据结构/1.线性表.html":{"url":"2.数据结构与算法/2.数据结构/1.线性表.html","title":"2.1 线性表","keywords":"","body":" 顺序表 vector 链表 class Node{ public: Node(){}; } "},"2.数据结构与算法/2.数据结构/2.栈和队列.html":{"url":"2.数据结构与算法/2.数据结构/2.栈和队列.html","title":"2.2 栈和队列","keywords":"","body":""},"2.数据结构与算法/2.数据结构/3.树.html":{"url":"2.数据结构与算法/2.数据结构/3.树.html","title":"2.3 树","keywords":"","body":"二叉搜索树 B树：平衡多路查找树 "},"2.数据结构与算法/2.数据结构/4.堆.html":{"url":"2.数据结构与算法/2.数据结构/4.堆.html","title":"2.4 堆","keywords":"","body":"// TODO 索引堆 "},"2.数据结构与算法/2.数据结构/5.图.html":{"url":"2.数据结构与算法/2.数据结构/5.图.html","title":"2.5 图","keywords":"","body":""},"3.操作系统/":{"url":"3.操作系统/","title":"第三部分 操作系统","keywords":"","body":""},"3.操作系统/1.体系结构.html":{"url":"3.操作系统/1.体系结构.html","title":"1.体系结构","keywords":"","body":"操作系统体系结构 运行机制 两种指令 特权指令 如内存清零指令 非特权指令 如加减乘除运算指令 两种处理器状态 用程序状态寄存器(PSW)的标志位来标识处理器状态。如0为用户态，1为核心态 用户态（目态） 只能执行非特权指令。用户态→核心态的切换只能通过中断实现 核心态（管态） 特权指令、非特权指令都可以执行。核心态→用户态一种特权指令将程序状态字PSW设为用户态 两种程序 内核程序 运行在核心态，特权指令+非特权指令，是系统的管理者 应用程序 只能执行非特权指令，运行在用户态 操作系统内核 时钟管理 // TODO 时间片轮换 中断和异常 中断作用 引入中断机制，实现多道程序并发执行 本质：CPU收到中断信号，立即切换到核心态，对中断进行处理 中断是用户态→核心态的唯一途径 中断 外中断 狭义的中断。来自CPU外部的信号，与当前执行指令无关。 外设请求 如IO操作完成发出中断 人工干预 如用户强制终止进程 异常（内中断、例外、陷入） 信号来自当前执行的指令 自愿中断——指令中断(trap) 如系统调用使用的访管指令(也叫陷入、trap指令) 强迫中断 硬件故障(fault) 如缺页中断 软件中断(abort) 如整数除0 原语： 是一种特殊的程序，处于操作系统最底层，最接近硬件的部分 运行具有原子性，不可中断 运行时间短，调用频繁系统调用 系统资源管理 进程管理 存储管理 设备管理大内核与微内核 大内核 将操作系统主要功能模块都作为核心态 优点：高性能 缺点：代码庞大，结构混乱，难以维护微内核 只把最基本的功能保留在内核 优点：内核功能少，结构清晰，方便维护 缺点：性能低，需要在用户态和核心态频繁切换 "},"3.操作系统/2.进程与线程.html":{"url":"3.操作系统/2.进程与线程.html","title":"2.进程与线程","keywords":"","body":"进程与线程 进程 进程实体的运行过程（动态的） 系统进行资源分配和调度的独立单位进程实体 程序段：程序的代码等 数据段：程序处理的数据和变量 PCB（进程存在唯一标志） 进程描述信息：进程标识符PID，用户标识符UID 进程控制和管理信息 进程当前状态 进程优先级 资源分配清单 程序段指针 数据段指针 外设 处理机相关信息 各种寄存器的值 进程之间私有和共享的资源 私有：地址空间、堆、全局变量、栈、寄存器 共享：代码段，公共数据，进程目录，进程 ID 进程状态转换 就绪态-->运行态：程序被调度，CPU开始执行 运行态-->就绪态：时间片用完或者更高优先级的进程执行 运行态-->阻塞态：进程通过系统调用申请某种资源(如打印机等)，请求等待事件发生完才能继续执行（主动行为） 阻塞态-->就绪态：申请的资源被分配，可以继续执行（被动行为） 父进程与子进程 进程创建fork()函数 pid_t fork(); // 返回值0代表子进程，>0代表父进程，值为子进程PID，-1代表出错，在两个进程中返回两个值 复制父进程的资源需要大量的操作，十分浪费时间与系统资源，因此Linux内核采取了写时拷贝技术（copy on write）来提高效率 相同：子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息 区别：子进程与父进程的区别有进程号、资源使用情况和计时器等。 exec函数族 提供了让进程运行另一个程序的方法。exec函数族内的函数可以根据指定的文件名或目录名找到可执行程序，并加载新的可执行程序，替换掉旧的代码区、数据区、堆区、栈区与其他系统资源。这里的可执行程序既可以是二进制文件，也可以是脚本文件。在执行exec函数族函数后，除了该进程的进程号PID，其他内容都被替换了。 1.3.1 孤儿进程、僵尸进程和守护进程 守护进程 守护进程是一类在后台工作的特殊进程，通常情况下，守护进程用于执行特定的系统任务。守护进程却能够（或者说，必须）突破终端的限制，不受终端的影响在后台工作。许多的系统服务都是通过守护进程实现的 编写一个守护进程的步骤如下： 1.创建子进程，父进程退出 2.在子进程内创建新会话 3.改变工作目录 4.重设文件权限掩码 5.关闭文件描述符 孤儿进程 孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程，其会被init进程收养 一般情况下，子进程是由父进程创建，而子进程和父进程的退出是无顺序的，两者之间都不知道谁先退出。正常情况下父进程先结束会调用wait或者waitpid函数等待子进程完成再退出，而一旦父进程不等待直接退出，则剩下的子进程会被init(pid=1)进程接收，成会孤儿进程。（进程树中除了init都会有父进程） 解决：会被init进程收养，没有危害 僵尸进程 僵尸进程是指完成执行（通过 exit 系统调用，或运行时发生致命错误或收到终止信号所致）但在操作系统的进程表中仍然有一个表项（进程控制块PCB），处于\"终止状态 \"的进程 如果子进程先退出了，父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的状态信息，则子进程残留的状态信息（ task_struct 结构和少量资源信息）会变成僵尸进程 解决：kill父进程 进程通信 管道（PIPE） 有名管道 一种半双工的通信方式，它允许无亲缘关系进程间的通信 优点：可以实现任意关系的进程间的通信 缺点： 长期存于系统中，使用不当容易出错 缓冲区有限无名管道 一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程） 优点：简单方便 缺点： 局限于单向通信 只能创建在它的进程以及其有亲缘关系的进程之间 缓冲区有限 信号量（Semaphore） 一个计数器，可以用来控制多个线程对共享资源的访问 优点：可以同步进程 缺点：信号量有限信号（Signal） 一种比较复杂的通信方式，用于通知接收进程某个事件已经发生消息队列（Message Queue） 是消息的链表，存放在内核中并由消息队列标识符标识 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合共享内存（Shared Memory） 映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问 优点：无须复制，快捷，信息量大 缺点： 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信套接字（Socket） ：可用于不同及其间的进程通信 优点： 传输数据为字节级，传输数据可自定义，数据量小效率高 传输数据时间短，性能高 适合于客户端和服务器端之间信息实时交互 可以加密,数据安全性强 缺点：需对传输的数据进行解析，转化成应用级的数据。 线程 线程之间私有和共享的资源 私有：线程栈，寄存器，程序寄存器 共享：堆，地址空间，全局变量，静态变量 进程与线程区别 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU利用率低 占用内存少，切换简单，CPU利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 适应于多核分布式 进程占优 "},"3.操作系统/3.进程同步与互斥.html":{"url":"3.操作系统/3.进程同步与互斥.html","title":"3.进程同步与互斥","keywords":"","body":"进程同步与互斥 异步性：各并发执行的进程以各自独立、不可预知的速度向前推进 同步(直接制约关系)：进程直接因为资源，需要协调工作次序 进程同步 详细见Linux内核的同步机制1, Linux内核的同步机制2 同步方式 原子操作 信号量（semaphore） 读写信号量（rw_semaphore） 自旋锁（spinlock） 大内核锁（BKL，Big Kernel Lock） 读写锁（rwlock） 大读者锁（brlock-Big Reader Lock） 读-拷贝修改(RCU，Read-Copy Update) 顺序锁（seqlock） 进程互斥 对临界资源的访问，需要互斥进行 临界资源与临界区 临界资源：一个时间段内只允许一个进程使用，如：打印机等 临界区：进入临界资源的代码段进程互斥原则 空闲让进：临界区空闲时，可允许进程立即进入相应临界区 忙则等待：已有进程进入临界区时，其他进程应该等待 有限等待：不能让进程饥饿 让权等待：进程无法进入临界区时，应立即释放处理机，进入阻塞态信号量 机制：一对原语PV操作类型 整型信号量 用整数变量作为信号量，表示某种资源的数量 不满足让权等待，会一直占用处理机记录型型号量 P(S)如果剩余资源数不够，使用block原语将进程阻塞，并挂到信号量S的阻塞队列中；V(S)释放资源后，阻塞队列还有进程，便使用wakeup原语唤醒，变为就绪态 同步与互斥问题 实现进程互斥步骤： 确定临界区 设置互斥信号量mutex=1 进入临界区之前执行P操作 离开临界区时执行V操作 实现进程同步步骤： 找出同步关系 设置同步信号量初始值为0 在前置操作后执行V操作 在后置操作前执行P操作 生产者-消费者问题 互斥：只有一个进程能访问缓冲区mutex=1 同步：生产者需要空余缓冲区empty=n，消费者需要产品full=0 PV操作先后问题：互斥P操作必须在进入临界区之前，否则可能发生死锁，V操作先后顺序没影响(互斥PV在临界区前后)多生产者-消费者问题 互斥：只有一个进程能访问缓冲区mutex=1 同步：生产者A生产的产品a只能由α消费，生产者B生产的产品b只能由β消费，a=0, b=0, 缓冲区buffer=1// 生产者 A{ // 生产a P(buffer) P(mutex) // a放入缓冲区 V(mutex) V(a) } // 消费者 a{ P(a) P(mutex) // 从缓冲区取出a V(mutex) V(buffer) // 消费a } 抽烟者问题 读者-写者问题 互斥量：读-写进程互斥，写-写进程互斥，读-读进程互不干扰，mutex=1 处理方法：增加读进程cnt,cnt为0时对文件加锁P(mutex), cnt++，读完后cnt--，cnt为0时再解锁V(mutex)，同时应该对cnt变量的互斥操作mutex_count=1(cnt检查和赋值需要一气呵成，否则两个读进程可能cnt判断同时通过从而死锁) // 读者(读优先) P(mutex_count) if cnt==0: P(mutex) V(mutex_count) // 读文件 P(mutex_count) if cnt==0: V(mutex) V(mutex_count) 实现读写公平：增加互斥量w=1, 写者在先后进行互斥，读者在读文件之前进行互斥 哲学家进餐问题 问题：只有互斥关系，避免临界资源分配不当造成死锁 定义互斥信号量数组v(5,1),哲学家编号i=0~4，左边筷子编号为i，右边为(i+1)%5管程 作用：和信号量一样，实现进程的同步与互斥 特点：管程是特殊的软件模块，类似于类，有名字、共享数据、方法，每次只允许一个进程执行管程的方法 "},"3.操作系统/4.内存管理.html":{"url":"3.操作系统/4.内存管理.html","title":"4.内存管理","keywords":"","body":"内存管理 地址转换 操作系统实现逻辑地址到物理地址的转换 三种方式 绝对装入：编译器负责地址转换 可重定位装入：装入程序负责地址转换(早期阶段) 动态运行时装入：运行时才进行地址转换(现代操作系统)存储保护 保证进程不会越界访问 两种方式 上下限寄存器 重定位寄存器+界地址寄存器 内存空间的分配与回收 连续分配管理 系统为进程所分配的必须是连续的一块内存 单一连续分配 内存中只有一个用户程序 固定分区分配 将内存的用户控件划分为固定大小的分区，每个分区运行一个程序 动态分区分配(可变分区分配) 在进程装入内存，根据进程大小动态建立分区 首次适应算法：每次从低地址查找满足大小的空闲分区 最佳适应算法：优先分配满足要求的最小的空闲分区 缺点：会产生很多外部碎片 最坏适应算法：优先分配最大的连续空闲分区 会很快将大分区分配完，导致后续大进程没有内存空间 邻近适应算法：从上次分配完的地址开始查找满足大小的分区 非连续分配(离散分配方式) 基本分页存储管理 把内存分为大小相等的分区，按照分区大小把进程拆分开，一般为4kb=2^12 基本分段存储管理 区别：段的大小可以不相同，页的大小相同 分段是信息的逻辑单位，对用户是可见的；分页是信息的物理单位，用户不可见 段页式存储管理内存空间扩充(虚拟性) 覆盖技术 程序分成几个模块，按时间先后运行交换技术 进程在内存与磁盘间动态调度虚拟内存 定义和特征 特征 多次性 程序允许被分成多次调入内存 对换性 程序运行时无需常驻内存，可以在运行过程中换入换出 虚拟性 逻辑上扩充了内存的容量 容量 最大容量 CPU寻址范围确定，32位系统为4GB 实际容量 min(外存+内存，寻址范围) 局部性原理 时间局部性：因为程序存在循环，某条指令不久后可能再次执行 空间局部性：某个存储单元被访问后，附近的存储单元页很有可能被访问 高速缓存技术 将频繁访问数据放到更高速的存储器中，暂时用不到的放在低速存储器中 实现 建立在离散分配的内存管理方式上 请求分页管理 页表机制 缺页中断：内中断，属于故障 地址变换 页面置换算法 最佳置换算法OPT 每次淘汰以后最长时间不被访问的页面（理想化算法，无法实现） 先进先出置换算法FIFO 每次淘汰最早进入内存的页面 Belady异常：为进程分配的物理块增多时，缺页中断不减反增的异常现象 最近最久未使用置换算法LRU 将前面最久没有使用过的页面置换 性能最接近OPT算法，但是实现困难，需要硬件支持，开销大 时钟置换算法CLOCK 将页面链接成循环队列，并增加访问位。访问过的页面访问位置为1；缺页中断时遇到访问位为1则置0，为0则置换，循环扫描 改进时钟算法 思想：被淘汰的页面如果没被修改，不需要写回外存浪费I/O，因此优先置换没被修改、没被访问的页面(访问位，修改位)为(0,0) 在CLOCK算法基础上增加修改位。先扫描第一个(0,0)置换，不修改标志位；再扫描第一个(0,1)置换，访问位置0；再扫描第一个(0,0)置换，不修改标志位；再扫描第一个(0,1)置换 页面分配策略 驻留集：请求分页存储管理中给进程分配的物理块的集合 太大：并发度下降，资源利用率低 太小：频繁发生缺页中断 页面分配、置换策略 固定分配局部置换 驻留集大小不变，缺页时进程只能使用自己的驻留集置换 可变分配全局置换 驻留集大小可变，缺页时可以将别的进程物理块置换 可变分配局部置换 驻留集大小可变，但是只使用自己的驻留集置换 抖动(颠簸) 刚换入的页面马上被换出，刚换出的马上又要换入 工作集 一定时间内，进程实际访问的页面集合 "},"3.操作系统/5.死锁与处理.html":{"url":"3.操作系统/5.死锁与处理.html","title":"5.死锁与处理","keywords":"","body":"死锁的产生 死锁的产生(四个必要条件) 互斥条件：对临界区资源的争抢 不剥夺条件：资源只能由进程主动释放，不能被抢夺 请求和保持条件：进程拥有了至少一个临界区资源，同时对其他临界区资源进行请求 循环等待条件：存在资源的循环等待环，每个进程的已拥有资源被下一个进程所请求 死锁的处理 静态策略：预防死锁 破坏某个或多个必要条件 破坏互斥条件 方式：将互斥使用资源改为允许共享使用。例：用SPOOLing技术把独占设备改造成共享设备，如改造打印机。 缺点：不是所有资源都可以改造 破坏不剥夺条件 方式： 进程请求资源得不到满足时，主动释放已保持的资源 操作系统将优先级更高进程想要的资源强行剥夺 缺点： 1.实现复杂 2.重复请求释放资源导致低效 3.有可能会导致进程饥饿 破坏请求和保持条件 方式：静态分配，运行之前一次性分配需要的全部资源 缺点： 1.资源利用率低 2.会导致进程饥饿 破坏循环等待条件 方式：顺序资源分配，给系统资源编号，必须按编号递增的顺序请求资源，已持有大编号的进程就不能逆向申请小编号资源 缺点： 1.不方便增加新的设备 2.使用资源顺序和递增顺序可能不一致，导致资源浪费 3.用户编程实现比较麻烦 动态策略：避免死锁 银行家算法 思想：在资源分配之前先判断是否会导致系统进入不安全状态 步骤： 1.找出进程最大需求矩阵和已分配资源列表，计算各进程的need矩阵(待分配资源) 2.将系统可用资源列表和每个进程的need列表对比，将能够满足待分配的进程加入安全序列，同时将该进程所有资源回收 3.依次将各个进程加入安全序列 死锁的检测和解除 允许死锁发生，然后检测出死锁并采取措施接触死锁 死锁检测 死锁检测算法化简资源分配图 死锁解除 资源剥夺法 终止进程法 进程回退法 锁 重量级锁 如果你学过多线程，那么你肯定知道锁这个东西，至于为什么需要锁，我就不给你普及了，就当做你是已经懂的了。 我们知道，我们要进入一个同步、线程安全的方法时，是需要先获得这个方法的锁的，退出这个方法时，则会释放锁。如果获取不到这个锁的话，意味着有别的线程在执行这个方法，这时我们就会马上进入阻塞的状态，等待那个持有锁的线程释放锁，然后再把我们从阻塞的状态唤醒，我们再去获取这个方法的锁。 这种获取不到锁就马上进入阻塞状态的锁，我们称之为重量级锁。 自旋锁 我们知道，线程从运行态进入阻塞态这个过程，是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到用户态到内核态的转换。当然，把线程从阻塞态唤醒也是一样，也是非常消耗时间的。 刚才我说线程拿不到锁，就会马上进入阻塞状态，然而现实是，它虽然这一刻拿不到锁，可能在下 0.0001 秒，就有其他线程把这个锁释放了。如果它慢0.0001秒来拿这个锁的话，可能就可以顺利拿到了，不需要经历阻塞/唤醒这个花时间的过程了。 然而重量级锁就是这么坑，它就是不肯等待一下，一拿不到就是要马上进入阻塞状态。为了解决这个问题，我们引入了另外一种愿意等待一段时间的锁 --- 自旋锁。 自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看看这段时间有没其他人把这锁给释放了。怎么等呢？这个就类似于线程在那里做空循环，如果循环一定的次数还拿不到锁，那么它才会进入阻塞的状态。 至于是循环等待几次，这个是可以人为指定一个数字的。 自适应自旋锁 上面我们说的自旋锁，每个线程循环等待的次数都是一样的，例如我设置为 100次的话，那么线程在空循环 100 次之后还没拿到锁，就会进入阻塞状态了。 而自适应自旋锁就牛逼了，它不需要我们人为指定循环几次，它自己本身会进行判断要循环几次，而且每个线程可能循环的次数也是不一样的。而之所以这样做，主要是我们觉得，如果一个线程在不久前拿到过这个锁，或者它之前经常拿到过这个锁，那么我们认为它再次拿到锁的几率非常大，所以循环的次数会多一些。 而如果有些线程从来就没有拿到过这个锁，或者说，平时很少拿到，那么我们认为，它再次拿到的概率是比较小的，所以我们就让它循环的次数少一些。因为你在那里做空循环是很消耗 CPU 的。 所以这种能够根据线程最近获得锁的状态来调整循环次数的自旋锁，我们称之为自适应自旋锁。 轻量级锁 上面我们介绍的三种锁：重量级、自旋锁和自适应自旋锁，他们都有一个特点，就是进入一个方法的时候，就会加上锁，退出一个方法的时候，也就释放对应的锁。 之所以要加锁，是因为他们害怕自己在这个方法执行的时候，被别人偷偷进来了，所以只能加锁，防止其他线程进来。这就相当于，每次离开自己的房间，都要锁上门，人回来了再把锁解开。 这实在是太麻烦了，如果根本就没有线程来和他们竞争锁，那他们不是白白上锁了？要知道，加锁这个过程是需要操作系统这个大佬来帮忙的，是很消耗时间的，。为了解决这种动不动就加锁带来的开销，轻量级锁出现了。 轻量级锁认为，当你在方法里面执行的时候，其实是很少刚好有人也来执行这个方法的，所以，当我们进入一个方法的时候根本就不用加锁，我们只需要做一个标记就可以了，也就是说，我们可以用一个变量来记录此时该方法是否有人在执行。也就是说，如果这个方法没人在执行，当我们进入这个方法的时候，采用CAS机制，把这个方法的状态标记为已经有人在执行，退出这个方法时，在把这个状态改为了没有人在执行了。 之所以要用CAS机制来改变状态，是因为我们对这个状态的改变，不是一个原子性操作，所以需要CAS机制来保证操作的原子性。不知道CAS的可以看这篇文章：并发的核心：CAS 是什么？Java8是如何优化 CAS 的？。 显然，比起加锁操作，这个采用CAS来改变状态的操作，花销就小多了。 然而可能会说，没人来竞争的这种想法，那是你说的而已，那如果万一有人来竞争说呢？也就是说，当一个线程来执行一个方法的时候，方法里面已经有人在执行了。 如果真的遇到了竞争，我们就会认为轻量级锁已经不适合了，我们就会把轻量级锁升级为重量级锁了。 所以轻量级锁适合用在那种，很少出现多个线程竞争一个锁的情况，也就是说，适合那种多个线程总是错开时间来获取锁的情况。 偏向锁 偏向锁就更加牛逼了，我们已经觉得轻量级锁已经够轻，然而偏向锁更加省事，偏向锁认为，你轻量级锁每次进入一个方法都需要用CAS来改变状态，退出也需要改变，多麻烦。 偏向锁认为，其实对于一个方法，是很少有两个线程来执行的，搞来搞去，其实也就一个线程在执行这个方法而已，相当于单线程的情况，居然是单线程，那就没必要加锁了。 不过毕竟实际情况的多线程，单线程只是自己认为的而已了，所以呢，偏向锁进入一个方法的时候是这样处理的：如果这个方法没有人进来过，那么一个线程首次进入这个方法的时候，会采用CAS机制，把这个方法标记为有人在执行了，和轻量级锁加锁有点类似，并且也会把该线程的 ID 也记录进去，相当于记录了哪个线程在执行。 然后，但这个线程退出这个方法的时候，它不会改变这个方法的状态，而是直接退出来，懒的去改，因为它认为除了自己这个线程之外，其他线程并不会来执行这个方法。 然后当这个线程想要再次进入这个方法的时候，会判断一下这个方法的状态，如果这个方法已经被标记为有人在执行了，并且线程的ID是自己，那么它就直接进入这个方法执行，啥也不用做 你看，多方便，第一次进入需要CAS机制来设置，以后进出就啥也不用干了，直接进入退出。 然而，现实总是残酷的，毕竟实际情况还是多线程，所以万一有其他线程来进入这个方法呢？如果真的出现这种情况，其他线程一看这个方法的ID不是自己，这个时候说明，至少有两个线程要来执行这个方法论，这意味着偏向锁已经不适用了，这个时候就会从偏向锁升级为轻量级锁。 所以呢，偏向锁适用于那种，始终只有一个线程在执行一个方法的情况哦。 这里我作下说明，为了方便大家理解，我在将轻量级锁和偏向锁的时候，其实是简化了很多的，不然的话会涉及到对象的内部结构、布局，我觉得把那些扯出来，你们可能要晕了，所以我大致讲了他们的原理。 悲观锁和乐观锁 最开始我们说的三种锁，重量级锁、自旋锁和自适应自旋锁，进入方法之前，就一定要先加一个锁，这种我们为称之为悲观锁。悲观锁总认为，如果不事先加锁的话，就会出事，这种想法确实悲观了点，这估计就是悲观锁的来源了。 而乐观锁却相反，认为不加锁也没事，我们可以先不加锁，如果出现了冲突，我们在想办法解决，例如 CAS 机制，上面说的轻量级锁，就是乐观锁的。不会马上加锁，而是等待真的出现了冲突，在想办法解决。 "},"3.操作系统/6.文件管理.html":{"url":"3.操作系统/6.文件管理.html","title":"6.文件管理","keywords":"","body":"文件管理 文件的物理结构 连续分配(类似于顺序表) 每个文件在磁盘上占有一组连续的块 支持顺序访问和随机访问，在顺序读写时速度最快 存在大量磁盘碎片，存储空间利用率低，同时不方便拓展文件链接分配 隐式链接(类似于链表) 每个磁盘块保存指向下一个块的指针 只支持顺序访问，不支持随机访问 查找效率低，指针耗费少量空间，但是不会产生碎片，空间利用率高 显示链接 将链接文件物理块的指针存放在文件分配表(FAT)中 一个磁盘仅设置一张FAT，并常驻内存 块号转换不需要访问磁盘，因此支持顺序访问也支持随机访问索引分配 每个文件建立一张索引表(类似于页表)，记录文件各逻辑块对应的物理块。索引表存放的磁盘块成为索引块 一个文件对应一张索引表，支持随机访问，蛋索引表占据存储空间文件存储空间管理 几种管理方法 空闲表法 空闲链表法 空闲盘块链 空闲盘区链 位示图法 成组链接法文件共享 基于索引结点的共享(硬链接) 将除了文件名之外的其他信息放到索引结点中 删除文件时只删除了目录项，且cnt--, cnt为0时才真正删除基于符号链的共享(软链接) link类型文件，类似于\"快捷方式\"，记录了文件的存放路径 软链接指向的文件删除时，软链接仍存在 Linux文件系统 详见Linux文件系统 "},"3.操作系统/7.附：linux命令.html":{"url":"3.操作系统/7.附：linux命令.html","title":"附：Linux命令","keywords":"","body":"linux命令 资源查看 帮助命令man可以查看命令及系统函数的用法 文件及目录 命令 作用 mkdir 创建目录 rm 删除文件或目录 mv 移动 cp 查看内存使用量和交换区使用量 资源 命令 作用 free -m 查看内存使用量和交换区使用量 df -h 查看各分区使用情况 du -sh 查看指定目录的大小 top 动态查看内存与进程 kill 161 杀死PID为161的进程 uptime 查看系统运行时间、用户数、负载 cat /proc/loadavg 查看系统负载 磁盘和分区 命令 作用 `mount column -t` 查看挂接的分区状态 fdisk -l 查看所有分区 swapon -s 查看所有交换分区 hdparm -i /dev/hda 查看磁盘参数(仅适用于IDE设备) `dmesg grep IDE` 查看启动时IDE设备检测状况 网络 命令 作用 ifconfig 查看所有网络接口的属性 iptables -L 查看防火墙设置 route -n 查看路由表 netstat -lntp 查看所有监听端口 netstat -antp 查看所有已经建立的连接 netstat -s 查看网络统计信息 用户 命令 作用 w 查看活动用户 id 查看指定用户信息 last 查看用户登录日志 cut -d: -f1 /etc/passwd 查看系统所有用户 cut -d: -f1 /etc/group 查看系统所有组 crontab -l 查看当前用户的计划任务 系统信息 命令 作用 uname -a 查看内核/操作系统/CPU信息 head -n 1 /etc/issue 查看操作系统版本 cat /proc/cpuinfo 查看CPU信息 hostname 查看计算机名 lspci -tv 列出所有PCI设备 lsusb -tv 列出所有USB设备 lsmod 列出加载的内核模块 env 查看环境变量 rpm -qa 查看所有安装的软件包 chkconfig --list 列出所有系统服务 `chkconfig --list grep on` 列出所有启动的系统服务 内容分析工具 命令 作用 nm ldd 查看内核/操作系统/CPU信息 readelf 查看内核/操作系统/CPU信息 cmake基础命令 目的 命令 uname -a 查看内核/操作系统/CPU信息 head -n 1 /etc/issue 查看操作系统版本 cat /proc/cpuinfo 查看CPU信息 hostname 查看计算机名 lspci -tv 列出所有PCI设备 lsusb -tv 列出所有USB设备 lsmod 列出加载的内核模块 env 查看环境变量 rpm -qa 查看所有安装的软件包 chkconfig --list 列出所有系统服务 `chkconfig --list grep on` 列出所有启动的系统服务 "},"4.TCP-IP详解/":{"url":"4.TCP-IP详解/","title":"第四部分 TCP/IP详解","keywords":"","body":""},"4.TCP-IP详解/1.TCP-IP网络模型.html":{"url":"4.TCP-IP详解/1.TCP-IP网络模型.html","title":"1.TCP/IP网络模型","keywords":"","body":"网络协议模型 面试题：一次完整的HTTP请求过程 OSI参考模型是国际标准，TCP/IP模型是这一标准的具体实现 物理层：定义物理设备标准，如网线接口类型、介质传输速率。面向比特流(Bit) 数据链路层：主机间通信。数据链路层在不可靠的物理介质上提供可靠的传输。面向以太网帧(Frame) 网络层：网络层负责对子网间的数据包进行路由选择，以及实现拥塞控制、网络互连等功能。面向数据包(Packet) 传输层：传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话，即端口到端口的连接(Segment) 会话层、表示层、应用层：规定应用程序的数据格式 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS TCP/IP数据包封装 用户数据自顶向下层层封装，传输到目的主机再自底向上得到用户数据。 "},"4.TCP-IP详解/2.网络接口层.html":{"url":"4.TCP-IP详解/2.网络接口层.html","title":"2.网络接口层","keywords":"","body":"网络接口层 以太网帧首部 目的地址/源地址：通信双方的MAC地址，目的地址未知时用FF:FF:FF:FF:FF:FF填充 类型：协议类型编码 数据：不超过最大传输单元MTU(1500)字节，因此以太网帧范围为64~1518。MTU的选择是资源占用和效率的综合考量 CRC：尾部校验，提供差错控制 MAC地址： 网卡的硬件地址，6字节48位，前24位用于分配给不同厂商，后24位厂商自己分配，全球唯一。系统中的MAC地址是ARP协议ROM中记录的硬件地址，是可以修改的，因此可能有两个相同的MAC地址 ARP协议 作用：获取局域网中目标主机的物理地址(MAC地址) ARP协议流程 检查ARP缓存表，查看目的主机是否有IP地址对应的目的MAC； 目的地址未知时用FF:FF:FF:FF:FF:FF填充，并发送广播帧，交换机将广播帧转发 所有收到帧的主机会解析目的地址为FF:FF:FF:FF:FF:FF的以太帧，如果IP地址符合则接收，并将其IP和MAC记录到ARP缓存表，同时发送ARP应答 源主机收到应答后记录目的主机的MAC地址 RARP协议 作用：利用MAC地址获取目标主机的IP地址(已经被DHCP协议取代) RARP协议流程 发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址； 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址； 如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；如果不存在，RARP服务器对此不做任何的响应； 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。 "},"4.TCP-IP详解/3.网络层.html":{"url":"4.TCP-IP详解/3.网络层.html","title":"3.网络层","keywords":"","body":"IP协议 IP首部格式 4位版本：指明IPv4或IPv6 总长度字段：整个IP数据报的长度，字节为单位 16位标识：唯一标识主机发送的每一份数据报，通常每发送一份报文值就加1 3位标志：前1位保留，第2位DF不分片标志，DF=0表示已经分片；第3位MF更多分片，MF=0表示该数据报是最后一个分片 8位生存时间TTL：当前主机到目的主机的路由器间最大跳数，每经过一个路由器便减1，TTL=0则丢弃数据报。目的为了防止出现循环回路，且TTL=0时会发送不可达ICMP给源IP 13位偏移量：以8字节为单位，计算从数据报开始的片段偏移量 IP分片 作用：IP数据报最大长度65535字节，超过了链路层最大传输单元MTU的限制。 分片缺点： IP层没有超时重传机制，一个分片丢失，所有分片都要依赖传输层协议重传一遍，降低传输数据的成功率 分片、重组带来性能消耗 有安全隐患 因此IPv6不允许路由器执行分片，在发送数据包之前确定MTU 避免IP分片 TCP协议通过三次握手的过程，互相通告最大报文段长度MSS(MTU1500 - IP首部20 - TCP首部20 = 1460字节)，每次发送数据不会超过MSS UDP包在应用层限制每个包大小不超过MTU1500 - IP首部20 - UDP首部8 = 1472字节 IP选路 概念：搜索路由表并决定向哪个网络接口发送分组 相关命令 列出主机当前路由表netstat -rn 手动添加路由route 路由表 目的网络IP地址 子网掩码 下一跳IP地址 接口 路由表包含： 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。 子网掩码（subnet mask）：用来判断 IP 所属网络 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。 根据应用和执行的不同，路由表可能含有如下附加信息： 花费（Cost）：就是数据发送过程中通过路径所需要的花费。 路由的服务质量 路由中需要过滤的出/入连接列表 ICMP协议 作用：ICMP封装在IP数据报内部，用来发送网络控制消息，包括主机探测、路由维护、IP选路等 报文分类 应用： PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性 TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量 NAT协议 http://www.52im.net/thread-50-1-1.html NAT穿透 http://www.52im.net/thread-50-1-1.html "},"4.TCP-IP详解/4.传输层.html":{"url":"4.TCP-IP详解/4.传输层.html","title":"4.传输层","keywords":"","body":"1. UDP协议 UDP封装 UDP首部 特点： 无连接 尽最大努力交付 面向应用程序交付的报文(对报文不拆分不合并) 没有流量控制 支持一对一、多对多的交互通信(视频、语音等) 拓展：可靠UDP 如何让不可靠的UDP变的可靠？ https://www.jianshu.com/p/4d12ad2e7500 可靠的UDP协议KCP https://www.cnblogs.com/wetest/p/9190786.html 2. TCP协议 首部格式 TCP首部 序号seq：16位(4字节)，本报文段发送第一个字节的序号 确认号ack：16位，期望收到的下一个报文的seq 数据偏移：首部长度 ACK：只有ACK=1时，确认号ack才有效 复位RST：表明连接中出现严重差错，需要重新建立连接 同步SYN：仅用于建立连接时，SYN=1表示请求连接或接受连接 终止FIN：仅用于释放连接，FIN=1表示数据发送完毕，请求释放连接 窗口字段：向对方建议发送窗口的大小 选项字段：包括最大报文段长度MSS等 TCP连接特点： 面向连接 提供全双工通信 每个连接只能有两个端点(一对一) 提供可靠交付的服务 面向字节流连接控制 三次握手 面试官，不要再问我三次握手和四次挥手 四次挥手 面试官，不要再问我三次握手和四次挥手 请画出三次握手和四次挥手的示意图 为什么连接的时候是三次握手？ 什么是半连接队列？ ISN(Initial Sequence Number)是固定的吗？ 三次握手过程中可以携带数据吗？ 如果第三次握手丢失了，客户端服务端会如何处理？ 服务端状态为SYN_RECV,并且会根据TCP的超时重传机制，会等待1秒、2秒、4秒后重新发送SYN+ACK包，以便Client重新发送ACK包如果重传都一直失败，会在指数退避达64s后发RTS包，断开连接。 SYN攻击是什么？ 挥手为什么需要四次？ 四次挥手释放连接时，等待2MSL的意义?TIME_WAIT、CLOSE_WAIT 流量控制 滑动窗口 慢启动 拥塞避免 超时重传 快速重传 快速恢复 TCP黏包问题 原因：TCP为了保证可靠传输并减少额外的开销，采用基于字节流的传输服务（UDP 基于报文的），TCP所传输的数据是没有消息边界的，所以可能会出现两个数据包黏在一起的情况。 TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事： 只有上一个分组得到确认，才会发送下一个分组 收集多个小分组，在一个确认到来时一起发送 举例：客户端调用两次send()发送1k和2k大小的数据，服务端调用一次recv()读出3k大小的数据 解决： 发送方： 对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。 应用层 接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。 应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。 循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？ 格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。 发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。 "},"4.TCP-IP详解/5.应用层.html":{"url":"4.TCP-IP详解/5.应用层.html","title":"5.应用层","keywords":"","body":" 1. 域名解析DNS协议 域名系统（DNS）是一个分布的数据库，由它来提供IP地址和域名之间的映射信息 https://www.jianshu.com/p/766bef2f6470 名字空间 DNS指针查询 DNS缓存 2. FTP协议 工作模式 PASV PORT 指令和响应码 断点续传 匿名FTP 3. 超文本传输HTTP协议 面试题1：一次完整的HTTP请求过程 面试题2：你知道一个TCP连接上能发起多少个HTTP请求吗？ 报文格式 请求报文 请求行：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如：GET /index.html HTTP/1.1 请求头部：由关键字/值对组成，每行一对，关键字和值用:分隔。请求头部通知服务器有关于客户端请求的信息 空行：回车符和换行符，通知服务器不再有请求头 请求数据：不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合 请求方法： | 方法 | 意义 | | ------- | ------------------------------------------------------------------------------------------------------------------------------------- | | OPTIONS | 请求一些选项信息，允许客户端查看服务器的性能 | | GET | 请求指定的页面信息，并返回实体主体 | | HEAD | 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 | | POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 | | PUT | 从客户端向服务器传送的数据取代指定的文档的内容 | | DELETE | 请求服务器删除指定的页面 | | TRACE | 回显服务器收到的请求，主要用于测试或诊断 | 响应报文 HTTP状态码 4. HTTPS协议 https://www.jianshu.com/p/9b18791bc01b 详细握手过程 安全算法 HTTPS 是如何解决上面的三个风险的？ 对称加密和非对称加密结合的「混合加密」方式，解决了窃听的风险。 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。 将服务器公钥放入到数字证书中，解决了冒充的风险。 摘要算法 摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。 数字签名 数字证书 客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 这就存在些问题，如何保证公钥不被篡改和信任度？所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。 HTTP和HTTPS区别 HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。 HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。 HTTP 的端口号是 80，HTTPS 的端口号是 443。 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 附：常用端口号 端口号 服务 21端口 FTP 文件传输服务 22端口 SSH 端口 23端口 TELNET 终端仿真服务 25端口 SMTP 简单邮件传输服务 53端口 DNS 域名解析服务 80端口 HTTP 超文本传输服务 110端口 POP3 “邮局协议版本3”使用的端口 443端口 HTTPS 加密的超文本传输服务 1433端口 MS SQL*SERVER数据库 默认端口号 1521端口 Oracle数据库服务 1863端口 MSN Messenger的文件传输功能所使用的端口 3306端口 MYSQL 默认端口号 3389端口 Microsoft RDP 微软远程桌面使用的端口 5631端口 Symantec pcAnywhere 远程控制数据传输时使用的端口 5632端口 Symantec pcAnywhere 主控端扫描被控端时使用的端口 5000端口 MS SQL Server使用的端口 8000端口 腾讯QQ "},"4.TCP-IP详解/6.socket网络编程.html":{"url":"4.TCP-IP详解/6.socket网络编程.html","title":"6.socket网络编程","keywords":"","body":"Socket 网络编程(套接字编程)就是编写程序使两台联网的计算机互相交换数据，而套接字就是用来连接网络的工具。 网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用open –> write/read –> close模式来操作。 网络中进程之间如何通信？ socket是一个五元组 源IP：源端口 目的IP：目的端口 协议(UDP/TCP) 就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。 socket流程 Tips:在Linux上，可使用man命令去查询每一个函数或者头文件 生成套接字socket() #include int socket(int domain, int type, int protocol); 返回: 成功：套接字文件描述符 失败：-1 绑定地址bind() #include int bind(int socket, const struct sockaddr *address, socklen_t address_len); 返回： 成功：0 失败：-1 监听连接listen() #include int listen(int socket, int backlog); 返回： 成功：0 失败：-1 接受请求accept() #include int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 返回： 成功：返回请求连接端的套接字文件描述符 失败：-1 请求连接connect() #include int connect(int socket, const struct sockaddr *address, socklen_t address_len); 返回： 成功：0 失败：-1 Linux文件操作 在Linux里，socket也被认为是文件的一种，故在网络传输过程中亦可使用文件I/O的相关函数。 文件描述符(文件句柄) 文件描述符是系统分配给文件或套接字的整数。 系统文件描述符 文件描述符 对象 0 标准输入：Standard Input 1 标准输出：Standard Output 2 标准错误：Standard Error I/O函数 打开文件open() #include #include #include int open(const char *path, int flag); 返回： 成功：返回文件描述符 失败：-1 文件打开模式(flag)： 打开模式 含义 O_CREAT 必要时创建文件 O_TRUNC 删除全部现有数据 O_APPEND 追加到已有数据后面 O_RDONLY 只读打开 O_WRONLY 只写打开 O_RDWR 读写打开 关闭文件 使用文件后必须关闭close() #include int close(int fd); 返回： 成功：0 失败：-1 写文件write() #include ssize_t write(int fd, const void *buf, size_t nbytes); 返回： 成功：返回写入的字节数 失败：-1 读文件read() #include int read(int fd, void *buf, size_t nbytes); 返回： 成功：返回接收的字节数，遇到文件尾(EOF)则返回0 失败：-1 主机字节序与网络字节序 主机字节序 概念：主机字节序又叫CPU字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种： 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址 存储方式 32 位整数0x12345678是从起始位置为0x00的地址开始存放，则： 内存地址 0x00 0x01 0x02 0x03 大端 12 34 56 78 小端 78 56 34 12 大端 小端 判断大端、小端 // 判断大端、小端 int i = 0x12345678; if (*((char*)&i) == 0x12) cout 网络字节序 网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保重数据在不同主机之间传输时能够被正确解释。 网络字节顺序采用：大端（Big Endian）排列方式。 "},"4.TCP-IP详解/7.select、poll与epoll.html":{"url":"4.TCP-IP详解/7.select、poll与epoll.html","title":"7.selcet, poll与epoll","keywords":"","body":"// TODO poll epoll "},"4.TCP-IP详解/8.信息安全.html":{"url":"4.TCP-IP详解/8.信息安全.html","title":"8.信息安全","keywords":"","body":"// TODO SQL注入 "},"5.数据库/":{"url":"5.数据库/","title":"第五部分 数据库","keywords":"","body":""},"5.数据库/1.数据库原理.html":{"url":"5.数据库/1.数据库原理.html","title":"1.数据库原理","keywords":"","body":"数据库体系结构 数据（data）：描述事物的符号记录称为数据。 数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点（，数据库即是一个文件）。 数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。 数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。 数据库完整性 数据库的完整性是指数据的正确性和相容性。 完整性：为了防止数据库中存在不符合语义（不正确）的数据。 安全性：为了保护数据库防止恶意破坏和非法存取。 触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。 关系数据理论 数据依赖 数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。 最重要的数据依赖：函数依赖、多值依赖。 范式 第一范式（1NF）：属性（字段）是最小单位不可再分。 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）。 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。 事务 事务的 ACID 特性 A 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 C 一致性：要求同一事务中的SQL语句，必须保证同时成功或者失败。 I 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 D 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在MySQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务的隔离性 事务的隔离性可分为四种 ( 性能从高到低，安全性从低到高 ) ： READ UNCOMMITTED ( 读取未提交 ) 如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。 READ COMMITTED ( 读取已提交 ) 只能读取到其他事务已经提交的数据。 REPEATABLE READ ( 可被重复读 ) 如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。 SERIALIZABLE ( 串行化 ) 所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。 并发控制 事务隔离级别 脏读 不可重复读 幻读 读未提交（READ UNCOMMITTED） 是 是 是 不可重复读（READ COMMITTED） 否 是 是 可重复读（REPEATABLE READ） 否 否 是 串行化（SERIALIZABLE） 否 否 否 事务的并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 乐观锁与悲观锁 见操作系统死锁与处理 基本概念 实体：客观存在可相互区别的事物 属性：实体具有的某一特性 联系：实体之间的联系通常是指不同实体集之间的联系。 码：唯一标识实体的属性集。 实体型 比如学生 实体集 比如全体学生 模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。 常用数据模型 • 层次模型（hierarchical model） • 网状模型（network model） • 面向对象数据模型（object oriented data model） • 对象关系数据模型（object relational data model） • 半结构化数据模型（semistructure data model） • 关系模型（relational model） 关系模型 关系（relation）：一个关系对应通常说的一张表 元组（tuple）：表中的一行即为一个元组 属性（attribute）：表中的一列即为一个属性 码（key）：表中可以唯一确定一个元组的某个属性组 超码：能在关系中唯一标志一个元组 候选码：最小超码 主键：用户明确定义的候选码，通常用下划线标记 外码：关系R上的属性B在关系S上是主键，则R上的属性B是参照S的外码，R为外码依赖的参照关系 域（domain）：一组具有相同数据类型的值的集合$ D_1,D_2,...D_n $ 分量：元组中的一个属性值 关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, ..., 属性n) 笛卡儿积：每个域的基数相乘=行数，$ D_i $域的笛卡尔积$ {D_1}\\times{D_2}\\times{...}\\times{D_n} $ 关系操作 基本关系操作： 查询： 选择Select 运算符$\\sigma $，选择指定条件构成新关系 投影Project 运算符$\\Pi$，投影指定属性名构成新关系，去除其中数据重复 连接(等值连接 自然连接Natural join 外连接) 运算符$ \\bowtie $两个关系必须有同名属性，连接两个关系同名属性值相等的元组 除Division 并Union 运算符$\\cup$ 差set difference $r-s$，在r里去除s出现的元组 交Set intersection 运算符$\\cap$ 笛卡尔积Cartesian product 运算符$r\\times s$ 插入 删除 修改： 赋值Assignment $\\rho {_X(A1,...An)}(E)$返回E的结果，对关系E及属性重命名，也可以只重命名属性或关系名 重命名Rename 运算符示例： $\\sigma{A=C}(r \\times s) $ 选择属性A=C的 $\\Pi{A,C}(r)$ 投影关系r属性名AC的两列，并去除数据重复 "},"5.数据库/2.MySQL基础操作.html":{"url":"5.数据库/2.MySQL基础操作.html","title":"2.MySQL基础操作","keywords":"","body":"MySQL学习笔记 基本操作 登录和退出MySQL服务器 # 启动mysql服务器 sudo service mysql start # 登录MySQL $ mysql -u root -p12345612 # 退出MySQL数据库服务器 exit; # 停止mysql服务器 sudo service mysql stop 创建CREATE -- 创建数据库 CREATE DATABASE test; -- 创建数据表 CREATE TABLE pet ( name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE ); 显示SHOW -- 显示所有数据库 SHOW DATABASES; -- 创建数据库 CREATE DATABASE test; -- 切换数据库 use test; -- 显示数据库中的所有表 show tables; -- 创建数据表 CREATE TABLE pet ( name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE ); -- 查看数据表结构 -- describe pet; desc pet; -- 查询表 SELECT * from pet; -- 插入数据 INSERT INTO pet VALUES ('puffball', 'Diane', 'hamster', 'f', '1990-03-30', NULL); -- 修改数据 UPDATE pet SET name = 'squirrel' where owner = 'Diane'; -- 删除数据 DELETE FROM pet where name = 'squirrel'; -- 删除表 DROP TABLE myorder; 建表约束 主键约束 -- 主键约束 -- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。 CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20) ); -- 联合主键 -- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。 CREATE TABLE user ( id INT, name VARCHAR(20), password VARCHAR(20), PRIMARY KEY(id, name) ); -- 自增约束 -- 自增约束的主键由系统自动递增分配。 CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20) ); -- 添加主键约束 -- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）： ALTER TABLE user ADD PRIMARY KEY(id); ALTER TABLE user MODIFY id INT PRIMARY KEY; -- 删除主键 ALTER TABLE user drop PRIMARY KEY; 唯一主键 -- 建表时创建唯一主键 CREATE TABLE user ( id INT, name VARCHAR(20), UNIQUE(name) ); -- 添加唯一主键 -- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）： ALTER TABLE user ADD UNIQUE(name); ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE; -- 删除唯一主键 ALTER TABLE user DROP INDEX name; 非空约束 -- 建表时添加非空约束 -- 约束某个字段不能为空 CREATE TABLE user ( id INT, name VARCHAR(20) NOT NULL ); -- 移除非空约束 ALTER TABLE user MODIFY name VARCHAR(20); 默认约束 -- 建表时添加默认约束 -- 约束某个字段的默认值 CREATE TABLE user2 ( id INT, name VARCHAR(20), age INT DEFAULT 10 ); -- 移除非空约束 ALTER TABLE user MODIFY age INT; 外键约束 -- 班级 CREATE TABLE classes ( id INT PRIMARY KEY, name VARCHAR(20) ); -- 学生表 CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(20), -- 这里的 class_id 要和 classes 中的 id 字段相关联 class_id INT, -- 表示 class_id 的值必须来自于 classes 中的 id 字段值 FOREIGN KEY(class_id) REFERENCES classes(id) ); -- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的； -- 2. 主表中的记录被副表引用时，主表不可以被删除。 数据库的三大设计范式 1NF 只要字段值还可以继续拆分，就不满足第一范式。 范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。 2NF 在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下： -- 订单表 CREATE TABLE myorder ( product_id INT, customer_id INT, product_name VARCHAR(20), customer_name VARCHAR(20), PRIMARY KEY (product_id, customer_id) ); 实际上，在这张订单表中，product_name 只依赖于 product_id ，customer_name 只依赖于 customer_id 。也就是说，product_name 和 customer_id 是没用关系的，customer_name 和 product_id 也是没有关系的。 这就不满足第二范式：其他列都必须完全依赖于主键列！ CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT ); CREATE TABLE product ( id INT PRIMARY KEY, name VARCHAR(20) ); CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20) ); 拆分之后，myorder 表中的 product_id 和 customer_id 完全依赖于 order_id 主键，而 product 和 customer 表中的其他字段又完全依赖于主键。满足了第二范式的设计！ 3NF 在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。 CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT, customer_phone VARCHAR(15) ); 表中的 customer_phone 有可能依赖于 order_id 、 customer_id 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。 CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT ); CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20), phone VARCHAR(15) ); "},"5.数据库/3.MYSQL查询.html":{"url":"5.数据库/3.MYSQL查询.html","title":"3.MySQL查询","keywords":"","body":"查询 准备数据 -- 创建数据库 CREATE DATABASE select_test; -- 切换数据库 USE select_test; -- 创建学生表 CREATE TABLE student ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, -- 生日 class VARCHAR(20) -- 所在班级 ); -- 创建教师表 CREATE TABLE teacher ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, profession VARCHAR(20) NOT NULL, -- 职称 department VARCHAR(20) NOT NULL -- 部门 ); -- 创建课程表 CREATE TABLE course ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, t_no VARCHAR(20) NOT NULL, -- 教师编号 -- 表示该 tno 来自于 teacher 表中的 no 字段值 FOREIGN KEY(t_no) REFERENCES teacher(no) ); -- 成绩表 CREATE TABLE score ( s_no VARCHAR(20) NOT NULL, -- 学生编号 c_no VARCHAR(20) NOT NULL, -- 课程号 degree DECIMAL, -- 成绩 -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值 FOREIGN KEY(s_no) REFERENCES student(no), FOREIGN KEY(c_no) REFERENCES course(no), -- 设置 s_no, c_no 为联合主键 PRIMARY KEY(s_no, c_no) ); -- 查看所有表 SHOW TABLES; -- 添加学生表数据 INSERT INTO student VALUES('101', '曾华', '男', '1977-09-01', '95033'); INSERT INTO student VALUES('102', '匡明', '男', '1975-10-02', '95031'); INSERT INTO student VALUES('103', '王丽', '女', '1976-01-23', '95033'); INSERT INTO student VALUES('104', '李军', '男', '1976-02-20', '95033'); INSERT INTO student VALUES('105', '王芳', '女', '1975-02-10', '95031'); INSERT INTO student VALUES('106', '陆军', '男', '1974-06-03', '95031'); INSERT INTO student VALUES('107', '王尼玛', '男', '1976-02-20', '95033'); INSERT INTO student VALUES('108', '张全蛋', '男', '1975-02-10', '95031'); INSERT INTO student VALUES('109', '赵铁柱', '男', '1974-06-03', '95031'); -- 添加教师表数据 INSERT INTO teacher VALUES('804', '李诚', '男', '1958-12-02', '副教授', '计算机系'); INSERT INTO teacher VALUES('856', '张旭', '男', '1969-03-12', '讲师', '电子工程系'); INSERT INTO teacher VALUES('825', '王萍', '女', '1972-05-05', '助教', '计算机系'); INSERT INTO teacher VALUES('831', '刘冰', '女', '1977-08-14', '助教', '电子工程系'); -- 添加课程表数据 INSERT INTO course VALUES('3-105', '计算机导论', '825'); INSERT INTO course VALUES('3-245', '操作系统', '804'); INSERT INTO course VALUES('6-166', '数字电路', '856'); INSERT INTO course VALUES('9-888', '高等数学', '831'); -- 添加添加成绩表数据 INSERT INTO score VALUES('103', '3-105', '92'); INSERT INTO score VALUES('103', '3-245', '86'); INSERT INTO score VALUES('103', '6-166', '85'); INSERT INTO score VALUES('105', '3-105', '88'); INSERT INTO score VALUES('105', '3-245', '75'); INSERT INTO score VALUES('105', '6-166', '79'); INSERT INTO score VALUES('109', '3-105', '76'); INSERT INTO score VALUES('109', '3-245', '68'); INSERT INTO score VALUES('109', '6-166', '81'); -- 查看表结构 SELECT * FROM course; SELECT * FROM score; SELECT * FROM student; SELECT * FROM teacher; 1 到 10 -- 查询 student 表的所有行 SELECT * FROM student; -- 查询 student 表中的 name、sex 和 class 字段的所有行 SELECT name, sex, class FROM student; -- 查询 teacher 表中不重复的 department 列 -- department: 去重查询 SELECT DISTINCT department FROM teacher; -- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询） -- BETWEEN xx AND xx: 查询区间, AND 表示 \"并且\" SELECT * FROM score WHERE degree BETWEEN 60 AND 80; SELECT * FROM score WHERE degree > 60 AND degree 分组计算平均成绩 查询每门课的平均成绩。 -- AVG: 平均值 SELECT AVG(degree) FROM score WHERE c_no = '3-105'; SELECT AVG(degree) FROM score WHERE c_no = '3-245'; SELECT AVG(degree) FROM score WHERE c_no = '6-166'; -- GROUP BY: 分组查询 SELECT c_no, AVG(degree) FROM score GROUP BY c_no; 分组条件与模糊查询 查询 score 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。 SELECT * FROM score; -- c_no 课程编号 +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 分析表发现，至少有 2 名学生选修的课程是 3-105 、3-245 、6-166 ，以 3 开头的课程是 3-105 、3-245 。也就是说，我们要查询所有 3-105 和 3-245 的 degree 平均分。 -- 首先把 c_no, AVG(degree) 通过分组查询出来 SELECT c_no, AVG(degree) FROM score GROUP BY c_no +-------+-------------+ | c_no | AVG(degree) | +-------+-------------+ | 3-105 | 85.3333 | | 3-245 | 76.3333 | | 6-166 | 81.6667 | +-------+-------------+ -- 再查询出至少有 2 名学生选修的课程 -- HAVING: 表示持有 HAVING COUNT(c_no) >= 2 -- 并且是以 3 开头的课程 -- LIKE 表示模糊查询，\"%\" 是一个通配符，匹配 \"3\" 后面的任意字符。 AND c_no LIKE '3%'; -- 把前面的SQL语句拼接起来， -- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。 SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_no HAVING COUNT(c_no) >= 2 AND c_no LIKE '3%'; +-------+-------------+----------+ | c_no | AVG(degree) | COUNT(*) | +-------+-------------+----------+ | 3-105 | 85.3333 | 3 | | 3-245 | 76.3333 | 3 | +-------+-------------+----------+ 多表查询 - 1 查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree 。 SELECT no, name FROM student; +-----+-----------+ | no | name | +-----+-----------+ | 101 | 曾华 | | 102 | 匡明 | | 103 | 王丽 | | 104 | 李军 | | 105 | 王芳 | | 106 | 陆军 | | 107 | 王尼玛 | | 108 | 张全蛋 | | 109 | 赵铁柱 | +-----+-----------+ SELECT s_no, c_no, degree FROM score; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 通过分析可以发现，只要把 score 表中的 s_no 字段值替换成 student 表中对应的 name 字段值就可以了，如何做呢？ -- FROM...: 表示从 student, score 表中查询 -- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。 SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no; +-----------+-------+--------+ | name | c_no | degree | +-----------+-------+--------+ | 王丽 | 3-105 | 92 | | 王丽 | 3-245 | 86 | | 王丽 | 6-166 | 85 | | 王芳 | 3-105 | 88 | | 王芳 | 3-245 | 75 | | 王芳 | 6-166 | 79 | | 赵铁柱 | 3-105 | 76 | | 赵铁柱 | 3-245 | 68 | | 赵铁柱 | 6-166 | 81 | +-----------+-------+--------+ 多表查询 - 2 查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列。 只有 score 关联学生的 no ，因此只要查询 score 表，就能找出所有和学生相关的 no 和 degree ： SELECT s_no, c_no, degree FROM score; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 然后查询 course 表： +-------+-----------------+ | no | name | +-------+-----------------+ | 3-105 | 计算机导论 | | 3-245 | 操作系统 | | 6-166 | 数字电路 | | 9-888 | 高等数学 | +-------+-----------------+ 只要把 score 表中的 c_no 替换成 course 表中对应的 name 字段值就可以了。 -- 增加一个查询字段 name，分别从 score、course 这两个表中查询。 -- as 表示取一个该字段的别名。 SELECT s_no, name as c_name, degree FROM score, course WHERE score.c_no = course.no; +------+-----------------+--------+ | s_no | c_name | degree | +------+-----------------+--------+ | 103 | 计算机导论 | 92 | | 105 | 计算机导论 | 88 | | 109 | 计算机导论 | 76 | | 103 | 操作系统 | 86 | | 105 | 操作系统 | 75 | | 109 | 操作系统 | 68 | | 103 | 数字电路 | 85 | | 105 | 数字电路 | 79 | | 109 | 数字电路 | 81 | +------+-----------------+--------+ 三表关联查询 查询所有学生的 name 、课程名 ( course 表中的 name ) 和 degree 。 只有 score 表中关联学生的学号和课堂号，我们只要围绕着 score 这张表查询就好了。 SELECT * FROM score; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 只要把 s_no 和 c_no 替换成 student 和 srouse 表中对应的 name 字段值就好了。 首先把 s_no 替换成 student 表中的 name 字段： SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no; +-----------+-------+--------+ | name | c_no | degree | +-----------+-------+--------+ | 王丽 | 3-105 | 92 | | 王丽 | 3-245 | 86 | | 王丽 | 6-166 | 85 | | 王芳 | 3-105 | 88 | | 王芳 | 3-245 | 75 | | 王芳 | 6-166 | 79 | | 赵铁柱 | 3-105 | 76 | | 赵铁柱 | 3-245 | 68 | | 赵铁柱 | 6-166 | 81 | +-----------+-------+--------+ 再把 c_no 替换成 course 表中的 name 字段： -- 课程表 SELECT no, name FROM course; +-------+-----------------+ | no | name | +-------+-----------------+ | 3-105 | 计算机导论 | | 3-245 | 操作系统 | | 6-166 | 数字电路 | | 9-888 | 高等数学 | +-------+-----------------+ -- 由于字段名存在重复，使用 \"表名.字段名 as 别名\" 代替。 SELECT student.name as s_name, course.name as c_name, degree FROM student, score, course WHERE student.NO = score.s_no AND score.c_no = course.no; 子查询加分组求平均分 查询 95031 班学生每门课程的平均成绩。 在 score 表中根据 student 表的学生编号筛选出学生的课堂号和成绩： -- IN (..): 将筛选出的学生号当做 s_no 的条件查询 SELECT s_no, c_no, degree FROM score WHERE s_no IN (SELECT no FROM student WHERE class = '95031'); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 这时只要将 c_no 分组一下就能得出 95031 班学生每门课的平均成绩： SELECT c_no, AVG(degree) FROM score WHERE s_no IN (SELECT no FROM student WHERE class = '95031') GROUP BY c_no; +-------+-------------+ | c_no | AVG(degree) | +-------+-------------+ | 3-105 | 82.0000 | | 3-245 | 71.5000 | | 6-166 | 80.0000 | +-------+-------------+ 子查询 - 1 查询在 3-105 课程中，所有成绩高于 109 号同学的记录。 首先筛选出课堂号为 3-105 ，在找出所有成绩高于 109 号同学的的行。 SELECT * FROM score WHERE c_no = '3-105' AND degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105'); 子查询 - 2 查询所有成绩高于 109 号同学的 3-105 课程成绩记录。 -- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。 SELECT * FROM score WHERE degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105'); YEAR 函数与带 IN 关键字查询 查询所有和 101 、108 号学生同年出生的 no 、name 、birthday 列。 -- YEAR(..): 取出日期中的年份 SELECT no, name, birthday FROM student WHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108)); 多层嵌套子查询 查询 '张旭' 教师任课的学生成绩表。 首先找到教师编号： SELECT NO FROM teacher WHERE NAME = '张旭' 通过 sourse 表找到该教师课程号： SELECT NO FROM course WHERE t_no = ( SELECT NO FROM teacher WHERE NAME = '张旭' ); 通过筛选出的课程号查询成绩表： SELECT * FROM score WHERE c_no = ( SELECT no FROM course WHERE t_no = ( SELECT no FROM teacher WHERE NAME = '张旭' ) ); 多表查询 查询某选修课程多于5个同学的教师姓名。 首先在 teacher 表中，根据 no 字段来判断该教师的同一门课程是否有至少5名学员选修： -- 查询 teacher 表 SELECT no, name FROM teacher; +-----+--------+ | no | name | +-----+--------+ | 804 | 李诚 | | 825 | 王萍 | | 831 | 刘冰 | | 856 | 张旭 | +-----+--------+ SELECT name FROM teacher WHERE no IN ( -- 在这里找到对应的条件 ); 查看和教师编号有有关的表的信息： SELECT * FROM course; -- t_no: 教师编号 +-------+-----------------+------+ | no | name | t_no | +-------+-----------------+------+ | 3-105 | 计算机导论 | 825 | | 3-245 | 操作系统 | 804 | | 6-166 | 数字电路 | 856 | | 9-888 | 高等数学 | 831 | +-------+-----------------+------+ 我们已经找到和教师编号有关的字段就在 course 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 score 表来查询： -- 在此之前向 score 插入一些数据，以便丰富查询条件。 INSERT INTO score VALUES ('101', '3-105', '90'); INSERT INTO score VALUES ('102', '3-105', '91'); INSERT INTO score VALUES ('104', '3-105', '89'); -- 查询 score 表 SELECT * FROM score; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ -- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。 SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5; +-------+ | c_no | +-------+ | 3-105 | +-------+ 根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号： SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5 ); +------+ | t_no | +------+ | 825 | +------+ 在 teacher 表中，根据筛选出来的教师编号找到教师姓名： SELECT name FROM teacher WHERE no IN ( -- 最终条件 SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5 ) ); 子查询 - 3 查询 “计算机系” 课程的成绩表。 思路是，先找出 course 表中所有 计算机系 课程的编号，然后根据这个编号查询 score 表。 -- 通过 teacher 表查询所有 `计算机系` 的教师编号 SELECT no, name, department FROM teacher WHERE department = '计算机系' +-----+--------+--------------+ | no | name | department | +-----+--------+--------------+ | 804 | 李诚 | 计算机系 | | 825 | 王萍 | 计算机系 | +-----+--------+--------------+ -- 通过 course 表查询该教师的课程编号 SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department = '计算机系' ); +-------+ | no | +-------+ | 3-245 | | 3-105 | +-------+ -- 根据筛选出来的课程号查询成绩表 SELECT * FROM score WHERE c_no IN ( SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department = '计算机系' ) ); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-245 | 86 | | 105 | 3-245 | 75 | | 109 | 3-245 | 68 | | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 103 | 3-105 | 92 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | | 109 | 3-105 | 76 | +------+-------+--------+ UNION 和 NOTIN 的使用 查询 计算机系 与 电子工程系 中的不同职称的教师。 -- NOT: 代表逻辑非 SELECT * FROM teacher WHERE department = '计算机系' AND profession NOT IN ( SELECT profession FROM teacher WHERE department = '电子工程系' ) -- 合并两个集 UNION SELECT * FROM teacher WHERE department = '电子工程系' AND profession NOT IN ( SELECT profession FROM teacher WHERE department = '计算机系' ); ANY 表示至少一个 - DESC ( 降序 ) 查询课程 3-105 且成绩 至少 高于 3-245 的 score 表。 SELECT * FROM score WHERE c_no = '3-105'; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 103 | 3-105 | 92 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | | 109 | 3-105 | 76 | +------+-------+--------+ SELECT * FROM score WHERE c_no = '3-245'; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-245 | 86 | | 105 | 3-245 | 75 | | 109 | 3-245 | 68 | +------+-------+--------+ -- ANY: 符合SQL语句中的任意条件。 -- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件， -- 最后根据降序查询结果。 SELECT * FROM score WHERE c_no = '3-105' AND degree > ANY( SELECT degree FROM score WHERE c_no = '3-245' ) ORDER BY degree DESC; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 102 | 3-105 | 91 | | 101 | 3-105 | 90 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | | 109 | 3-105 | 76 | +------+-------+--------+ 表示所有的 ALL 查询课程 3-105 且成绩高于 3-245 的 score 表。 -- 只需对上一道题稍作修改。 -- ALL: 符合SQL语句中的所有条件。 -- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。 SELECT * FROM score WHERE c_no = '3-105' AND degree > ALL( SELECT degree FROM score WHERE c_no = '3-245' ); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 103 | 3-105 | 92 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | +------+-------+--------+ 复制表的数据作为条件查询 查询某课程成绩比该课程平均成绩低的 score 表。 -- 查询平均分 SELECT c_no, AVG(degree) FROM score GROUP BY c_no; +-------+-------------+ | c_no | AVG(degree) | +-------+-------------+ | 3-105 | 87.6667 | | 3-245 | 76.3333 | | 6-166 | 81.6667 | +-------+-------------+ -- 查询 score 表 SELECT degree FROM score; +--------+ | degree | +--------+ | 90 | | 91 | | 92 | | 86 | | 85 | | 89 | | 88 | | 75 | | 79 | | 76 | | 68 | | 81 | +--------+ -- 将表 b 作用于表 a 中查询数据 -- score a (b): 将表声明为 a (b)， -- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。 SELECT * FROM score a WHERE degree 子查询 - 4 查询所有任课 ( 在 course 表里有课程 ) 教师的 name 和 department 。 SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course); +--------+-----------------+ | name | department | +--------+-----------------+ | 李诚 | 计算机系 | | 王萍 | 计算机系 | | 刘冰 | 电子工程系 | | 张旭 | 电子工程系 | +--------+-----------------+ 条件加组筛选 查询 student 表中至少有 2 名男生的 class 。 -- 查看学生表信息 SELECT * FROM student; +-----+-----------+-----+------------+-------+ | no | name | sex | birthday | class | +-----+-----------+-----+------------+-------+ | 101 | 曾华 | 男 | 1977-09-01 | 95033 | | 102 | 匡明 | 男 | 1975-10-02 | 95031 | | 103 | 王丽 | 女 | 1976-01-23 | 95033 | | 104 | 李军 | 男 | 1976-02-20 | 95033 | | 105 | 王芳 | 女 | 1975-02-10 | 95031 | | 106 | 陆军 | 男 | 1974-06-03 | 95031 | | 107 | 王尼玛 | 男 | 1976-02-20 | 95033 | | 108 | 张全蛋 | 男 | 1975-02-10 | 95031 | | 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 | | 110 | 张飞 | 男 | 1974-06-03 | 95038 | +-----+-----------+-----+------------+-------+ -- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。 SELECT class FROM student WHERE sex = '男' GROUP BY class HAVING COUNT(*) > 1; +-------+ | class | +-------+ | 95033 | | 95031 | +-------+ NOTLIKE 模糊查询取反 查询 student 表中不姓 \"王\" 的同学记录。 -- NOT: 取反 -- LIKE: 模糊查询 mysql> SELECT * FROM student WHERE name NOT LIKE '王%'; +-----+-----------+-----+------------+-------+ | no | name | sex | birthday | class | +-----+-----------+-----+------------+-------+ | 101 | 曾华 | 男 | 1977-09-01 | 95033 | | 102 | 匡明 | 男 | 1975-10-02 | 95031 | | 104 | 李军 | 男 | 1976-02-20 | 95033 | | 106 | 陆军 | 男 | 1974-06-03 | 95031 | | 108 | 张全蛋 | 男 | 1975-02-10 | 95031 | | 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 | | 110 | 张飞 | 男 | 1974-06-03 | 95038 | +-----+-----------+-----+------------+-------+ YEAR 与 NOW 函数 查询 student 表中每个学生的姓名和年龄。 -- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。 SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student; +-----------+------+ | name | age | +-----------+------+ | 曾华 | 42 | | 匡明 | 44 | | 王丽 | 43 | | 李军 | 43 | | 王芳 | 44 | | 陆军 | 45 | | 王尼玛 | 43 | | 张全蛋 | 44 | | 赵铁柱 | 45 | | 张飞 | 45 | +-----------+------+ MAX 与 MIN 函数 查询 student 表中最大和最小的 birthday 值。 SELECT MAX(birthday), MIN(birthday) FROM student; +---------------+---------------+ | MAX(birthday) | MIN(birthday) | +---------------+---------------+ | 1977-09-01 | 1974-06-03 | +---------------+---------------+ 多段排序 以 class 和 birthday 从大到小的顺序查询 student 表。 SELECT * FROM student ORDER BY class DESC, birthday; +-----+-----------+-----+------------+-------+ | no | name | sex | birthday | class | +-----+-----------+-----+------------+-------+ | 110 | 张飞 | 男 | 1974-06-03 | 95038 | | 103 | 王丽 | 女 | 1976-01-23 | 95033 | | 104 | 李军 | 男 | 1976-02-20 | 95033 | | 107 | 王尼玛 | 男 | 1976-02-20 | 95033 | | 101 | 曾华 | 男 | 1977-09-01 | 95033 | | 106 | 陆军 | 男 | 1974-06-03 | 95031 | | 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 | | 105 | 王芳 | 女 | 1975-02-10 | 95031 | | 108 | 张全蛋 | 男 | 1975-02-10 | 95031 | | 102 | 匡明 | 男 | 1975-10-02 | 95031 | +-----+-----------+-----+------------+-------+ 子查询 - 5 查询 \"男\" 教师及其所上的课程。 SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex = '男'); +-------+--------------+------+ | no | name | t_no | +-------+--------------+------+ | 3-245 | 操作系统 | 804 | | 6-166 | 数字电路 | 856 | +-------+--------------+------+ MAX 函数与子查询 查询最高分同学的 score 表。 -- 找出最高成绩（该查询只能有一个结果） SELECT MAX(degree) FROM score; -- 根据上面的条件筛选出所有最高成绩表， -- 该查询可能有多个结果，假设 degree 值多次符合条件。 SELECT * FROM score WHERE degree = (SELECT MAX(degree) FROM score); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | +------+-------+--------+ 子查询 - 6 查询和 \"李军\" 同性别的所有同学 name 。 -- 首先将李军的性别作为条件取出来 SELECT sex FROM student WHERE name = '李军'; +-----+ | sex | +-----+ | 男 | +-----+ -- 根据性别查询 name 和 sex SELECT name, sex FROM student WHERE sex = ( SELECT sex FROM student WHERE name = '李军' ); +-----------+-----+ | name | sex | +-----------+-----+ | 曾华 | 男 | | 匡明 | 男 | | 李军 | 男 | | 陆军 | 男 | | 王尼玛 | 男 | | 张全蛋 | 男 | | 赵铁柱 | 男 | | 张飞 | 男 | +-----------+-----+ 子查询 - 7 查询和 \"李军\" 同性别且同班的同学 name 。 SELECT name, sex, class FROM student WHERE sex = ( SELECT sex FROM student WHERE name = '李军' ) AND class = ( SELECT class FROM student WHERE name = '李军' ); +-----------+-----+-------+ | name | sex | class | +-----------+-----+-------+ | 曾华 | 男 | 95033 | | 李军 | 男 | 95033 | | 王尼玛 | 男 | 95033 | +-----------+-----+-------+ 子查询 - 8 查询所有选修 \"计算机导论\" 课程的 \"男\" 同学成绩表。 需要的 \"计算机导论\" 和性别为 \"男\" 的编号可以在 course 和 student 表中找到。 SELECT * FROM score WHERE c_no = ( SELECT no FROM course WHERE name = '计算机导论' ) AND s_no IN ( SELECT no FROM student WHERE sex = '男' ); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 104 | 3-105 | 89 | | 109 | 3-105 | 76 | +------+-------+--------+ 按等级查询 建立一个 grade 表代表学生的成绩等级，并插入数据： CREATE TABLE grade ( low INT(3), upp INT(3), grade char(1) ); INSERT INTO grade VALUES (90, 100, 'A'); INSERT INTO grade VALUES (80, 89, 'B'); INSERT INTO grade VALUES (70, 79, 'C'); INSERT INTO grade VALUES (60, 69, 'D'); INSERT INTO grade VALUES (0, 59, 'E'); SELECT * FROM grade; +------+------+-------+ | low | upp | grade | +------+------+-------+ | 90 | 100 | A | | 80 | 89 | B | | 70 | 79 | C | | 60 | 69 | D | | 0 | 59 | E | +------+------+-------+ 查询所有学生的 s_no 、c_no 和 grade 列。 思路是，使用区间 ( BETWEEN ) 查询，判断学生的成绩 ( degree ) 在 grade 表的 low 和 upp 之间。 SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp; +------+-------+-------+ | s_no | c_no | grade | +------+-------+-------+ | 101 | 3-105 | A | | 102 | 3-105 | A | | 103 | 3-105 | A | | 103 | 3-245 | B | | 103 | 6-166 | B | | 104 | 3-105 | B | | 105 | 3-105 | B | | 105 | 3-245 | C | | 105 | 6-166 | C | | 109 | 3-105 | C | | 109 | 3-245 | D | | 109 | 6-166 | B | +------+-------+-------+ 连接查询 准备用于测试连接查询的数据： CREATE DATABASE testJoin; CREATE TABLE person ( id INT, name VARCHAR(20), cardId INT ); CREATE TABLE card ( id INT, name VARCHAR(20) ); INSERT INTO card VALUES (1, '饭卡'), (2, '建行卡'), (3, '农行卡'), (4, '工商卡'), (5, '邮政卡'); SELECT * FROM card; +------+-----------+ | id | name | +------+-----------+ | 1 | 饭卡 | | 2 | 建行卡 | | 3 | 农行卡 | | 4 | 工商卡 | | 5 | 邮政卡 | +------+-----------+ INSERT INTO person VALUES (1, '张三', 1), (2, '李四', 3), (3, '王五', 6); SELECT * FROM person; +------+--------+--------+ | id | name | cardId | +------+--------+--------+ | 1 | 张三 | 1 | | 2 | 李四 | 3 | | 3 | 王五 | 6 | +------+--------+--------+ 分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。 内连接 要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。 -- INNER JOIN: 表示为内连接，将两张表拼接在一起。 -- on: 表示要执行某个条件。 SELECT * FROM person INNER JOIN card on person.cardId = card.id; +------+--------+--------+------+-----------+ | id | name | cardId | id | name | +------+--------+--------+------+-----------+ | 1 | 张三 | 1 | 1 | 饭卡 | | 2 | 李四 | 3 | 3 | 农行卡 | +------+--------+--------+------+-----------+ -- 将 INNER 关键字省略掉，结果也是一样的。 -- SELECT * FROM person JOIN card on person.cardId = card.id; 注意：card 的整张表被连接到了右边。 左外连接 完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。 -- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。 SELECT * FROM person LEFT JOIN card on person.cardId = card.id; +------+--------+--------+------+-----------+ | id | name | cardId | id | name | +------+--------+--------+------+-----------+ | 1 | 张三 | 1 | 1 | 饭卡 | | 2 | 李四 | 3 | 3 | 农行卡 | | 3 | 王五 | 6 | NULL | NULL | +------+--------+--------+------+-----------+ 右外链接 完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。 SELECT * FROM person RIGHT JOIN card on person.cardId = card.id; +------+--------+--------+------+-----------+ | id | name | cardId | id | name | +------+--------+--------+------+-----------+ | 1 | 张三 | 1 | 1 | 饭卡 | | 2 | 李四 | 3 | 3 | 农行卡 | | NULL | NULL | NULL | 2 | 建行卡 | | NULL | NULL | NULL | 4 | 工商卡 | | NULL | NULL | NULL | 5 | 邮政卡 | +------+--------+--------+------+-----------+ 全外链接 完整显示两张表的全部数据。 -- MySQL 不支持这种语法的全外连接 -- SELECT * FROM person FULL JOIN card on person.cardId = card.id; -- 出现错误： -- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause' -- MySQL全连接语法，使用 UNION 将两张表合并在一起。 SELECT * FROM person LEFT JOIN card on person.cardId = card.id UNION SELECT * FROM person RIGHT JOIN card on person.cardId = card.id; +------+--------+--------+------+-----------+ | id | name | cardId | id | name | +------+--------+--------+------+-----------+ | 1 | 张三 | 1 | 1 | 饭卡 | | 2 | 李四 | 3 | 3 | 农行卡 | | 3 | 王五 | 6 | NULL | NULL | | NULL | NULL | NULL | 2 | 建行卡 | | NULL | NULL | NULL | 4 | 工商卡 | | NULL | NULL | NULL | 5 | 邮政卡 | +------+--------+--------+------+-----------+ "},"5.数据库/面试题：SQL语句执行很慢的原因.html":{"url":"5.数据库/面试题：SQL语句执行很慢的原因.html","title":"面试题：SQL语句执行很慢的原因","keywords":"","body":"一个 SQL 执行的很慢，我们要分两种情况讨论： 1、大多数情况下很正常，偶尔很慢，则有如下原因 (1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。 (2)、执行的时候，遇到锁，如表锁、行锁。 2、这条 SQL 语句一直执行的很慢，则有如下原因。 (1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。 (2)、数据库选错了索引。 开始装逼：分类讨论 一条 SQL 语句执行的很慢，那是每次执行都很慢呢？还是大多数情况下是正常的，偶尔出现很慢呢？所以我觉得，我们还得分以下两种情况来讨论。 1、大多数情况是正常的，只是偶尔会出现很慢的情况。 2、在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。 针对这两种情况，我们来分析下可能是哪些原因导致的。 针对偶尔很慢的情况 一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得这条SQL语句的书写本身是没什么问题的，而是其他原因导致的，那会是什么原因呢？ 数据库在刷新脏页我也无奈啊 当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在内存中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到磁盘中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到磁盘中去。 不过，redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，就会导致我们平时正常的SQL语句突然执行的很慢，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。 拿不到锁我能怎么办 这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的表，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。 如果要判断是否真的在等待锁，我们可以用 show processlist这个命令来查看当前的状态哦，这里我要提醒一下，有些命令最好记录一下，反正，我被问了好几个命令，都不知道怎么写，呵呵。 下来我们来访分析下第二种情况，我觉得第二种情况的分析才是最重要的 针对一直都这么慢的情况 如果在数据量一样大的情况下，这条 SQL 语句每次都执行的这么慢，那就就要好好考虑下你的 SQL 书写了，下面我们来分析下哪些原因会导致我们的 SQL 语句执行的很不理想。 我们先来假设我们有一个表，表里有下面两个字段,分别是主键 id，和两个普通字段 c 和 d。 mysql> CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; 扎心了，没用到索引 没有用上索引，我觉得这个原因是很多人都能想到的，例如你要查询这条语句 select * from t where 100 字段没有索引 刚好你的 c 字段上没有索引，那么抱歉，只能走全表扫描了，你就体验不会索引带来的乐趣了，所以，这回导致这条查询语句很慢。 字段有索引，但却没有用索引 好吧，这个时候你给 c 这个字段加上了索引，然后又查询了一条语句 select * from t where c - 1 = 1000; 我想问大家一个问题，这样子在查询的时候会用索引查询吗？ 答是不会，如果我们在字段的左边做了运算，那么很抱歉，在查询的时候，就不会用上索引了，所以呢，大家要注意这种字段上有索引，但由于自己的疏忽，导致系统没有使用索引的情况了。 正确的查询应该如下 select * from t where c = 1000 + 1; 有人可能会说，右边有运算就能用上索引？难道数据库就不会自动帮我们优化一下，自动把 c - 1=1000 自动转换为 c = 1000+1。 不好意思，确实不会帮你，所以，你要注意了。 函数操作导致没有用上索引 如果我们在查询的时候，对字段进行了函数操作，也是会导致没有用上索引的，例如 select * from t where pow(c,2) = 1000; 这里我只是做一个例子，假设函数 pow 是求 c 的 n 次方，实际上可能并没有 pow(c,2)这个函数。其实这个和上面在左边做运算也是很类似的。 所以呢，一条语句执行都很慢的时候，可能是该语句没有用上索引了，不过具体是啥原因导致没有用上索引的呢，你就要会分析了，我上面列举的三个原因，应该是出现的比较多的吧。 呵呵，数据库自己选错索引了 我们在进行查询操作的时候，例如 select * from t where 100 我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是整行字段的数据，而非主键索引上存放的值不是整行字段的数据，而且存放主键字段的值。不大懂的可以看我这篇文章：面试小知识：MySQL索引相关 里面有说到主键索引和非主键索引的区别 也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。 好吧扯了这么多，其实我就是想告诉你，就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 为什么会这样呢？ 其实是这样的，系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。 如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c 所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？ 判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。 那么问题来了，系统是怎么预测判断的呢？这里我给你讲下系统是怎么判断的吧，虽然这个时候我已经写到脖子有点酸了。 系统是通过索引的区分度来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为基数，即区分度越高，基数越大。所以呢，基数越大，意味着符合 100 所以呢，一个索引的基数越大，意味着走索引查询越有优势。 那么问题来了，怎么知道这个索引的基数呢？ 系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过采样的方式，来预测索引的基数的。 扯了这么多，重点的来了，居然是采样，那就有可能出现失误的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。然后就呵呵，系统就不走 c 索引了，直接走全部扫描了。 所以呢，说了这么多，得出结论：由于统计的失误，导致系统没有走索引，而是走了全表扫描，而这，也是导致我们 SQL 语句执行的很慢的原因。 这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。 不过呢，我们有时候也可以通过强制走索引的方式来查询，例如 select * from t force index(a) where c 我们也可以通过 show index from t; 来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令 analyze table t; 来重新统计分析。 既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦，这也可能是 SQL 执行的很慢的一个原因。 好吧，就先扯这么多了，你到时候能扯出这么多，我觉得已经很棒了，下面做一个总结。 "},"6.常见算法题/":{"url":"6.常见算法题/","title":"第六部分 常见算法题","keywords":"","body":""},"6.常见算法题/1.数组.html":{"url":"6.常见算法题/1.数组.html","title":"1.数组","keywords":"","body":""},"6.常见算法题/2.字符串.html":{"url":"6.常见算法题/2.字符串.html","title":"2.字符串","keywords":"","body":"字符串子串(两个字符串) KMP算法 字符串子序列 排列组合 滑动窗口 无重复字符最长子串 最小覆盖子串 至多包含2个不同字符的最长子串 至多包含K个字符的最长子串 "},"6.常见算法题/3.链表.html":{"url":"6.常见算法题/3.链表.html","title":"3.链表","keywords":"","body":"跳跃表 "},"6.常见算法题/4.栈与队列.html":{"url":"6.常见算法题/4.栈与队列.html","title":"4.栈与队列","keywords":"","body":"单调栈和单调队列 "},"6.常见算法题/5.二叉树树与递归.html":{"url":"6.常见算法题/5.二叉树树与递归.html","title":"5.二叉树与递归","keywords":"","body":""},"6.常见算法题/6.DFS与BFS.html":{"url":"6.常见算法题/6.DFS与BFS.html","title":"6.DFS与BFS","keywords":"","body":""},"6.常见算法题/7.贪心与回溯.html":{"url":"6.常见算法题/7.贪心与回溯.html","title":"7.贪心与回溯","keywords":"","body":""},"6.常见算法题/8.动态规划.html":{"url":"6.常见算法题/8.动态规划.html","title":"8.动态规划","keywords":"","body":"动态规划 应用：最值问题(具有最优子结构，即子问题拥有最值) dp数组的遍历方向 遍历的终点是最终存储的结果 点击查看示例图片 动态规划的步骤： 定义数组元素的含义(关键，不一定是直接最后的结果，但是和子问题间的关系较为简单) 找出数组元素之间的关系式(状态转移方程，难点) 找出边界初始值 例题1：不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ dp数组定义：dp[i][j]为机器人到达[i,j]处的路径个数 机器人可以从上边以及左边到达[i,j]处，状态转移方程dp[i][j] = dp[i-1][j] + dp[i][j-1] 初始值在左边界和上边界为1，代码如下： 点击查看Python代码实现 class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [[0]*n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 例题2：编辑距离 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1: 输入: word1 = \"horse\", word2 = \"ros\" 输出: 3 解释: horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e') dp[i][j]定义为word1的前i个字母到word2的前j个字母的操作数 第[i,j]个字母相同时，dp[i][j] = dp[i-1][j-1](不执行任何操作)，不相同时dp[i-1][j]+1代表插入元素，dp[i][j-1]+1代表删除当前元素，dp[i-1][j-1]+1代表替换当前元素，转移方程dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1或dp[i][j] = dp[i-1][j-1] (w1[i]==w2[j]时) 初始值dp[0][0...n]=0...n，dp[0...m][0]=0...m，表示从0到n需要插入的元素个数，以及从0到m需要删除的元素个数 点击查看Python代码实现 class Solution: def minDistance(self, word1: str, word2: str) -> int: m, n = len(word1), len(word2) dp = [[0] * (n+1) for _ in range(m+1)] # 初始值 for i in range(m+1): dp[i][0] = i for j in range(n+1): dp[0][j] = j for i in range(m): for j in range(n): # 状态转移 if word1[i] == word2[j]: dp[i+1][j+1] = dp[i][j] else: dp[i+1][j+1] = min(dp[i][j+1], dp[i+1][j], dp[i][j]) + 1 return dp[-1][-1] 动态规划的优化步骤 例题1 对于dp矩阵，在计算第三行的值时，第一行的值实际上是没有利用到的，因此dp矩阵可以优化为只保存矩阵的一行，而状态转移方程也从dp[i][j] = dp[i-1][j] + dp[i][j-1] → dp[j] = dp[j] + dp[j-1](dp[j]保存的是上一行dp[i-1][j]的值，dp[j-1]为当前行dp[i][j-1]的值) 优化代码如下： 点击查看Python代码实现 class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1]*n for i in range(1, m): # 相当于初始化矩阵第0列 dp[0] = 1 for j in range(1, n): dp[j] = dp[j] + dp[j-1] return dp[-1] 例题2 点击查看Python代码实现 class Solution: def minDistance(self, word1: str, word2: str) -> int: m, n = len(word1), len(word2) # 矩阵第0行，初始化 dp = list(range(n+1)) for i in range(m): # 保存上一列第0个元素 tmp = dp[0] # 相当于初始化矩阵第0列，即当前行第0个元素 dp[0] = i+1 for j in range(n): # 使用上一列保存的元素 pre = tmp # 保存[i,j+1]供下一列元素使用 tmp = dp[j+1] if word1[i] == word2[j]: dp[j+1] = pre else: dp[j+1] = min(dp[j+1], dp[j], pre) + 1 return dp[-1] "},"6.常见算法题/9.哈希.html":{"url":"6.常见算法题/9.哈希.html","title":"9.哈希","keywords":"","body":""},"6.常见算法题/10.算法思想.html":{"url":"6.常见算法题/10.算法思想.html","title":"10.算法思想","keywords":"","body":"查找 双指针 快慢指针 滑动窗口法 二分查找 位运算 地图着色 "},"6.常见算法题/11.附：高频算法题.html":{"url":"6.常见算法题/11.附：高频算法题.html","title":"附：高频算法题","keywords":"","body":" 1. 无重复字符的最长子串 描述：不含重复字符最长子串的长度 2. 寻找两个有序数组的中位数 要求时间复杂度为O(log(m+n)) 十亿个没排序的数找出中位数 3. 合并K个有序链表 4. 合并区间 描述：给出区间的集合，合并所有重叠的区间 LRU算法 "},"7.常见面试题/":{"url":"7.常见面试题/","title":"第七部分 常见面试题","keywords":"","body":""},"7.常见面试题/1.100道C++面试题.html":{"url":"7.常见面试题/1.100道C++面试题.html","title":"100道C/C++面试题","keywords":"","body":"第一部分：C++与C语言的差异（1-16） 1. C和C++中struct有什么区别？ C/C++ Protection行为 能否定义函数 C 无 否，但可以有函数指针 C++ 有 可以，默认是public 2. C++中的struct和class有什么区别？ 从语法上讲，class和struct做类型定义时只有两点区别： 默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理； 成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。 除了这两点，class和struct基本就是一个东西，没有任何其它区别。3. 如何判断一段程序是由C编译程序还是由C++编译程序编译的？ #ifdef __cplusplus cout 4. C和C++有什么不同? 从机制上：C是面向过程的（但C也可以编写面向对象的程序）；C++是面向对象的，提供了类。但是，C++编写面向对象的程序比C容易。 从适用的方向：C适合要求代码体积小的，效率高的场合，如嵌入式；C++适合更上层的，复杂的; linux核心大部分是C写的，因为它是系统软件，效率要求极高。 从名称上也可以看出，C++比C多了+，说明C++是C的超集；那为什么不叫C+而叫C++呢，是因为C++比C来说扩充的东西太多了，所以就在C后面放上两个+；于是就成了C++。 C语言是结构化编程语言，C++是面向对象编程语言。 C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。5. 引用与指针的区别？ 引用的底层实现是常量指针，但是从语言层面来讲引用和指针是完全不同的东西 可以用=, +=, -=, ++, --改变指针变量的值(内置类型的运算操作不支持重载)，引用永远对应同一个对象，不可变 指针可以为空，引用不能(指针是一个实体，引用是一个别名) 引用会有类型检查，是类型安全的 6. int id[sizeof(unsigned long)];对吗？为什么？ 正确sizeof是编译时运算符，编译时就确定了 可以看成和机器有关的常量。 7. 某文件中定义的静态全局变量(或称静态外部变量)其作用域是? A.只限某个函数 B.本文件 C.跨文件 D.不限制作用域 静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。 由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。 8. C++函数中值的传递方式有哪几种？ C++函数的三种传递方式为：值传递、指针传递和引用传递。 9. 对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现？ C用宏定义，C++用inline 10. C++中virtual与inline的含义分别是什么？ 在基类成员函数的声明前加上virtual关键字，意味着将该成员函数声明为虚函数。 inline与函数的定义体放在一起，使该函数称为内联。inline是一种用于实现的关键字，而不是用于声明的关键字。 虚函数的特点； 如果希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚方法，这样可以启用动态联编。 内联函数的特点； 使用内联函数的目的是为了提高函数的运行效率。 内联函数体的代码不能过长，因为内联函数省去调用函数的时间是以代码膨胀为代价的。 内联函数不能包含循环语句，因为执行循环语句要比调用函数的开销大。 11. VC 中，编译工具条内的 Debug 与 Release 选项是什么含义？ Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。 Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。 Debug 带有大量的调试代码，运行时需要相应的运行库，发布模式程序紧凑不含有调试代码和信息，直接可以运行（如果不需要运行库） 12. 断言函数assert的用法? 断言assert是仅在debug版本起作用的宏，用于检查“不应该“发生的情况。 程序员可以把assert看成一个在任何系统状态下都可以安全使用的无害测试手段。 13. const 与#define 的比较 ，const有什么优点? const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。 14. 请你谈谈引用和指针的区别。 （1）引用被创建的同时必须被初始化（指针则可以在任何时候被初始化） 。 （2）不能有 NULL 引用，引用必须与合法的存储单元关联（指针则可以是 NULL） 。 （3）一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象） 。 15. 有了 malloc/free 为什么还要 new/delete？ malloc 与 free 是 C++/C 语言的标准库函数，new/delete是 C++的运算符。它们都可用于申请动态内存和释放内存。 对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。 由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free 因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。 注意 new/delete不是库函数。 16. 如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。你是怎么处理内存耗尽的？ 判断指针是否为nullptr，如果是则马上用return语句终止本函数。 判断指针是否为nullptr，如果是则马上用exit(1)终止整个程序的运行 为new和malloc设置异常处理函数。例如 Visual C++可以用_set_new_hander 函数为new设置用户自己定义的异常处理函数， 也可以让malloc享用与new相同的异常处理函数。 第二部分：数据类型、关键字（17-34） 17. C++是不是类型安全的？ 不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。 18. const符号常量； const char *p; // 1 char const *p; // 2 char * const p; // 3 说明上面三种描述的区别； p是一个指向const char的指针，p是可以改变指向的，但是p指向的值是不能改变的; p指向的恰好是一个指向const的char的普通指针； p是一个指针，这个指针是指向char的const指针。(1)和(2)的定义是一样的。19. 用C++写个程序，如何判断一个操作系统是16位还是32位的？ 使用sizeof()：定义一个指针p，打印出sizeof(p),如果节后是4，则表示该操作系统是32位，打印结果是2，表示是16位。 不使用sizeof：unsigned int a = -1; cout 20. 识别函数或指针 分别表示什么意思？ void *(*(*fp1)(int))[10]; // fp1是一个指针，指向一个函数，这个函数的参数为int型， // 函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void*型指针。 float (*(*fp2)(int,int,int))(int); // fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数 // 这个函数的参数为int型，函数的返回值是float型。 int (*(*fp3)())[10](); // fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组 // 这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型 int ((fp3)())10; 多态类中的虚函数表是 Compile-Time，还是 Run-Time 时建立的？ 虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.而对象的隐藏成员--虚拟函数表指针是 在运行期--也就是构造函数被调用时进行初始化的,这是实现多态的关键。 错误的转义字符是？ A、'\\091' B、'\\' C、'\\0' D.'\\'' A 若数组名作实参而指针变量作形参，函数调用实参传给形参的是？ A、数组的长度 B.数组第一个元素的值 C、数组所有元素的值 D、数组第一个元素的地址 D 变量的指针含意是指变量的？ A.值 B.地址 C.存储 D.名字 B 内存的分配方式有几种？ 一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。 二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效 率很高，但是分配的内存容量有限。 三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们 决定，使用非常灵活，但问题也最多。 float a,b,c , 问等式 (a+b)+c==(b+a)+c 和 (a+b)+c==(a+c)+b 能否成立？ 两者都不行。在比较float或double时，不能简单地比较。由于计算误差，相等的概率很低。应判断两数之差是否落在区间（-e,e)内。 这个e应比浮点数的精度大一个数量级。 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？ 生命周期不同： 全局变量随主程序创建和创建，随主程序销毁而销毁； 局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在； 内存中分配在全局数据 区。 使用方式不同： 通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。 Heap 与 Stack 的差别 Heap是堆，stack是栈。 Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。 Stack空间有限，Heap是很大的自由存储区 C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。 程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行 In C++, what does \"explicit\" mean? what does \"protected\" mean? C++中的 explicit 关键字用来修饰类的构造函数，表明该构造函数是显式的，在某些情况下，我们要求类的使用者必须显示调用类的构造函数时就需要使用 explicit，反之默认类型转换可能会造成无法预期的问题。 protected 控制的是一个函数对一个类的成员（包括成员变量及成员方法）的访问权限。protected成员只有该类的成员函数及其派生类的成员函数可以访问。 重复多次 fclose 一个打开过一次的 FILE *fp 指针会有什么结果，并请解释。 考察点：导致文件描述符结构中指针指向的内存被重复释放，进而导致一些不可预期的异常。 为什么数组名作为参数，会改变数组的内容，而其它类型如int却不会改变变量的值？ 当数组名作为参数时，传递的实际上是地址。 而其他类型如int作为参数时，由于函数参数值实质上是实参的一份拷贝，被调函数内部对形参的改变并不影响实参的值。 你觉得如果不使用常量，直接在程序中填写数字或字符串，将会有什么麻烦？ （1） 程序的可读性（可理解性）变差。程序员自己会忘记那些数字或字符串是什么意思，用户则更加不知它们从何处来、表示什么。 （2） 在程序的很多地方输入同样的数字或字符串，难保不发生书写错误。 （3） 如果要修改数字或字符串，则会在很多地方改动，既麻烦又容易出错。 为什么需要使用堆，使用堆空间的原因？ 直到运行时才知道一个对象需要多少内存空间；不知道对象的生存期到底有多长。 const关键字？有哪些作用？ const关键字至少有下列n个作用： （1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了； （2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const； （3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值； （4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量； （5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。 注: 这个题可以考查面试者对程序设计知识的掌握程度是初级、中级还是比较深入，没有一定的知识广度和深度，不可能对这个问题给出全面的解答。大多数人只能回答出 static 和 const 关键字的部分功能。 第三部分：C++面向对象的特性（38-61） 是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态? virtual修饰符会被隐形继承的。virtual可加可不加。子类的空间里有父类的所有变量(static除外)。同一个函数只存在一个实体(inline除外)。子类覆盖它的函数不加virtual ,也能 实现多态。在子类的空间里，有父类的私有变量。私有变量不能直接访问。 面向对象的三个基本特征，并简单叙述之？ 封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected, public) 继承：广义的继承有三种实现形式： 实现继承（指使用基类的属性和方法而无需额外编码的能力）、 可视继承（子窗体使用父窗体的外观和实现代码）、 接口继承（仅使用属性和方法，实现滞后到子类实现）。 前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。 多态：是将父对象设置成为和一个或更多的与他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别？ 重载 同一名字空间 是指允许存在多个同名函数，而这些函数的参数表不同。 重定义/隐藏 不同名字空间 用于继承，派生类与基类的函数同名，屏蔽基类的函数 重写/覆盖 不同名字空间 用于继承，子类重新定义父类虚函数的方法 多态的作用？ 主要是两个： 隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用； 接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。当一个类A 中没有声命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。 sizeof(A) = 1； 如果 classA 中定义并实现虚函数 int func(void)，classB 中也实现该函数，那么上述变量 a->func() 将调用哪个类里面的函数？如果 int func(void) 不是虚函数，情况又如何？为什么？ 第一问调用的是B的。第二问调用A的。 虚函数的一个典型应用，虚函数只能借助于指针或者引用来达到多态的效果。 C++里面是不是所有的动作都是main()引起的？如果不是，请举例。 比如全局变量的初始化，就不是由 main 函数引起的。举例： class A{ }; A a; //a的构造函数限执行 int main() { } 复制代码 内联函数在编译时是否做参数类型检查 内联函数要做参数类型检查, 这是内联函数跟宏相比的优势。 请讲一讲析构函数和虚函数的用法和作用？ 析构函数是特殊的类成员函数，它没有返回类型，没有参数，不能随意调用，也没有重载，只有在类对象的生命期结束的时候，由系统自动调用。 有适放内存空间的作用。 虚函数是C++多态的一种表现, 使用虚函数，我们可以灵活的进行动态绑定，当然是以一定的开销为代价。 “new”in c++ is a？ A. library function like malloc in c B. key word C. operator D. none of the above C。 malloc是库函数，不在编译器控制范围之内；new是运算符，在编译器控制范围之内。调用malloc时，从堆中申请内存；调用new时，从堆中申请内存并为内存调用构造函数。 对于C++中类(class) 与结构(struct)的描述正确的为： A、类中的成员默认是private的,但是可以声明public,private 和 protected,结构中定义的成员默认的都是public; B、结构中不允许定义成员函数,但是类中可以定义成员函数; C、结构实例使用malloc() 动态创建,类对象使用new 操作符动态分配内存; D、结构和类对象都必须使用new 创建; E、结构中不可以定义虚函数,但是类中可以定义虚函数. F、结构不可以存在继承关系,但是类可以存在继承关系. A,D 两个互相独立的类：classA 和 classB，都各自定义了非静态的公有成员函数 PublicFunc() 和非静态的私有成员函数 privateFunc(); 现在要在classA 中增加定义一个成员函数classA::AdditionalPunction(classA a,classB b);则可以在AdditionalPunction(classA x,classB y)的实现部分(函数功能体内部)出现的合法的表达是最全的是： A、x.privateFunc();x.PublicFunc();y.privateFunc();y.PublicFunc(); B、x.privateFunc();x.PublicFunc();y.PublicFunc(); C、x.privateFunc();y.privateFunc();y.PublicFunc(); D、x.PublicFunc();y.PublicFunc(); B C++程序下列说法正确的有: A、对调用的虚函数和模板类都进行迟后编译. B、基类与子类中函数如果要构成虚函数,除了要求在基 类中用virtual 声名,而且必须名字相同且参数类型相同返回类型相同。 C、重载的类成员函数都必须要:或者返回类型不同,或者参数数目不同,或者参数序列的类型不同. D、静态成员函数和内联函数不能是虚函数,友员函数和构造函数也不能是虚函数,但是析构函数可以是虚函数. A 在C++中有没有纯虚构造函数？ 构造函数不能是虚的。只能有虚的析构函数。 下面的 throw 表达式哪些是错误的？ (a) class exceptionType { }; throw exceptionType { }; (b) enum mathErr { overflow, underflow, zeroDivide }; throw zeroDivide(); (a) class exceptionType { }; throw exceptionType(); (b) enum mathErr { overflow, underflow, zeroDivide }; throw zeroDivide; 谈谈你是怎么认识 C++ 中的模板的？ 模板使程序员能够快速建立具有类型安全的类库集合和函数集合，它的实现，方便了大规模的软件开发。（结合stl更好） 在 C++的一个类中声明一个 static 成员变量有没有用？ 在C++类的成员变量被声明为 static（称为静态成员变量），意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量， 也就是说不管创建多少对象，static修饰的变量只占有一块内存。其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。static是加了访问控制的全局变量，不被继承。 C++中为什么用模板类？ (1)可用来创建动态增长和减小的数据结构 (2)它是类型无关的，因此具有很高的可复用性。 (3)它在编译时而不是运行时检查数据类型，保证了类型安全（4）它是平台无关的，可移植性（5）可用于基本数据类型 函数模板与类模板有什么区别？ 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。 请你谈谈你在类中如何使用 const 的。 有时我们希望某些常量只在类中有效。由于#define 定义的宏常量是全局的，不能达到目的，于是想当然地觉得应该用 const 修饰数据成员来实现。 const 数据成员的确是存在的，但其含义却不是我们所期望的。const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的，因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。 不能在类声明中初始化 const 数据成员。 const 数据成员的初始化只能在类构造函数的初始化表中进行。 函数重载，我们靠什么来区分调用的那个函数？靠返回值判断可以不可以？ 如果同名函数的参数不同（包括类型、顺序不同） ，那么容易区别出它们是不同的。如果同名函数仅仅是返回值类型不同，有时可以区分，有时却不能。例如： void Function(void); int Function (void); 上述两个函数，第一个没有返回值，第二个的返回值是 int 类型。如果这样调用函数： int x = Function (); 则可以判断出 Function 是第二个函数。问题是在 C++/C 程序中，我们可以忽略函数的返回值。在这种情况下，编译器和程序员都不知道哪个 Function 函数被调用。 所以只能靠参数而不能靠返回值类型的不同来区分重载函数。 所有的运算符都能重载吗？ 不能被重载的运算符 在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。 （1）不能改变 C++内部数据类型（如 int,float 等）的运算符。 （2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。 （3）不能重载目前 C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。 （4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。 基类的析构函数不是虚函数，会带来什么问题？ 派生类的析构函数用不上，会造成资源的泄漏。 第四部分：程序阅读题（62-90） main 函数执行以前，还会执行什么代码？ 全局对象的构造函数会在main 函数之前执行。 There are two int variables: a and b, don't use“if”, “? :”, “switch”or other judgement statements, find out the biggest one of the two numbers. ( ( a + b ) + abs( a - b ) ) / 2 如何打印出当前源文件的文件名以及源文件的当前行号？ cout FILE ; coutLINE ; FILE和LINE是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。（C也有） 下面两种if语句判断方式。请问哪种写法更好？为什么？ int n; if (n == 10) // 第一种判断方式 if (10 == n) // 第二种判断方式 这是一个风格问题，第二种方式如果少了个=号,编译时就会报错,减少了出错的可能行,可以检测出是否少了=。 写出运行结果： { // test1 char str[] = \"world\"; cout } 复制代码 6：4：1：4 在不用第三方参数的情况下，交换两个参数的值。 a = a + b; b = a – b; a = a – b; 以下代码如果有错，请该正，并写出输出结果？ void main(void) { int nArrLength(400), i = 546; for (int i = 0; i} 复制代码 void main(void) { int nArrLength(400), i = 546; /*主要是考看对C++的基础知识是否了解这里的int nArrLength(400)是对整数的定义，当然，明名上有问题，这里是故意这样的， 但是，最好是变量名改为 ....[还是您自己看着办了]*/ for (int i = 0; i } 复制代码 int i = 5, b = 7; cout 结果是12。 写一个能做左值的函数(方法有很多)。 如：max(x, y) += 2874 + 55; drwline(x, y)++; int &max(int & x, int & y) { return x > y? x : y; } int x = 55, y = 77; max(x, y) += 12 + 11; // 此时 y = 92; cout 复制代码 程序输出 class human { public: ~human() { cout }; class man : public human { public: ~man() { cout }; int main() { human* p = new human; p->Disp(); delete p; return 0; } 复制代码 human disp ... ... human over ...... 下面的函数实现在一个固定的数上加上一个数，有什么错误，改正： int add_n(int n) { static int i = 100; i += n; return i; } 复制代码 因为static使得i的值会保留上次的值。以后的i会一直更新，使得第二次调用出现错误， 去掉static就可了 写出打印结果 unsigned short array[]={1,2,3,4,5,6,7}; int i = 3;*(array + i) = ？ 4 写一个函数计算当参数为n(n很大)时的值 1-2+3-4+5-6+7......+n。 long fn(long n) { if(n { printf(\"error: n must > 0); exit(1); } if(0 == n % 2) return (n / 2) * (-1); else return (n / 2) * (-1) + n; 复制代码 字符指针、浮点数指针、以及函数指针这三种类型的变量哪个占用的内存最大？为什么？ 指针变量也占用内存单元，而且所有指针变量占用内存单元的数量都是相同的。 就是说，不管是指向何种对象的指针变量，它们占用内存的字节数都是一样的，并且要足够把程序中所能用到的最大地址表示出来（通常是一个机器字长）。 以下三条输出语句分别输出什么？ char str1[] = \"abc\"; char str2[] = \"abc\"; const char str3[] = \"abc\"; const char str4[] = \"abc\"; const char* str5 = \"abc\"; const char* str6 = \"abc\"; cout cout cout 复制代码 分别输出 false,false,true。 str1和str2都是字符数组，每个都有其自己的存储区，它们的值则是各存储区首地址，不等； str3和str4同上，只是按const语义，它们所指向的数据区不能修改。 str5和str6并非数组而是字符指针，并不分配存储区，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指向该区首地址的指针，相等。 以下代码有什么问题？ cout 复制代码 三元表达式“？:”问号后面的两个操作数必须为同一类型。 以下代码能够编译通过吗，为什么？ unsigned int const size1 = 2; char str1[ size1 ]; unsigned int temp = 0; cin >> temp; unsigned int const size2 = temp; char str2[ size2 ]; 复制代码 str2定义出错，size2非编译器期间常量，而数组定义要求长度必须为编译期常量。 以下代码中的输出语句输出0吗，为什么？ struct CLS { int m_i; CLS( int i ) : m_i(i) {} CLS() { CLS(0); } }; CLS obj; cout 复制代码 不能。在默认构造函数内部再调用带参的构造函数属用户行为而非编译器行为，亦即仅执行函数调用，而不会执行其后的初始化表达式。 只有在生成对象时，初始化表达式才会随相应的构造函数一起调用。 How do you code an infinite loop in Cplus plus ? while(1){} or for(;1;) What are the values of a, b, and c after the following instructions: int a=5, b=7, c; c = a+++b; 复制代码 a=6,b=7,c=12 在排序方法中，关键码比较次数与记录地初始排列无关的是（） A. Shell排序B. 归并排序 C. 直接插入排序D. 选择排序 D 代码： void func() { static int val; } 中，变量 val 的内存地址位于： A. 已初始化数据段 B.未初始化数据段C.堆 D.栈 A 一个栈的入栈序列是 A，B，C，D，E，则栈的不可能的输出序列是？ A、EDCBA； B、DECBA；C、DCEAB； D、ABCDE C 写出判断ABCD四个表达式的是否正确, 若正确, 写出经过表达式中 a 的值。 int a = 4; (A)、a += (a++); (B)、a += (++a) ; (C)、(a++) += a; (D)、(++a) += (a++); a = ? 复制代码 C错误，左侧不是一个有效变量，不能赋值，可改为 (++a) += a; 改后答案依次为 9,10,10,11 请你谈谈你是如何使用 return 语句的。 （1）return 语句不可返回指向“栈内存”的“指针”或者“引用” ，因为该内存在函数体结束时被自动销毁。 （2）要搞清楚返回的究竟是“值”、“指针”还是“引用” 。 （3）如果函数返回值是一个对象，要考虑 return 语句的效率。 ① return String(s1 + s2); 和 ②String temp(s1 + s2); return temp; 一样吗？ ①这是临时对象的语法，表示“创建一个临时对象并返回它” 。 ②将发生三件事。首先，temp 对象被创建，同时完成初始化；然后拷贝构造函数把 temp 拷贝到保存返回值的外部存储单元中； 最后，temp 在函数结束时被销毁（调用析构函数） 。然而“创建一个临时对象并返回它”的过程是不同的， 编译器直接把临时对象创建并初始化在外部存储单元中，省去了拷贝和析构的化费，提高了效率。 下列程序的运行结果是？ include const char *str = \"vermeer\"; int main() { const char *pstr = str; cout } 复制代码 The address of pstr is: vermeer 下列程序输出结果是？ inline void max_out( int val1, int val2 ) { cout val2 ) ? val1 : val2; } int main() { int ix = 10, jx = 20; cout } 复制代码 The larger of 10, 20 is 0 ， 为什么不是20呢？问题在于输出操作符的优先级高于条件操作符 所以输出 val1 和 val2 比较结果的 true/false int max( int *ia, int sz ); int max( int *, int = 10 ); 算函数重载？还是重复声明？ 如果在两个函数的参数表中只有缺省实参不同则第二个声明被视为第一个的重复声明 。 第六部分：编程练习（比C要难）（91-100） 请编写一个 C++函数，该函数给出一个字节中被置 1 的位的个数。 unsigned int TestAsOne0(char log) { int i; unsigned int num = 0, val; for (i = 0; i > i; //移位 val &= 0x01; //与1相与 if (val) num++; } return num; } 复制代码 编写一个函数，函数接收一个字符串,是由十六进制数组成的一组字符串,函数的功能是把接到的这组字符串转换成十进制数字.并将十进制数字返回。 BOOL HexToDec(LPCTSTR shex, int& idec) { int i, mid; int len = lstrlen(shex); if (len > 8) return FALSE; mid = 0; idec = 0; for (i = 0; i = '0'&&shex[i] = 'a'&&shex[i] = 'A'&&shex[i] } 复制代码 输入一个字符串，将其逆序后输出 。 void main() { char a[50]; memset(a, 0, sizeof(a)); int i = 0, j; char t; cin.getline(a, 50, '\\n'); for (i = 0, j = strlen(a) - 1; i } 复制代码 编写一个算法frequency，统计在一个输入字符串中各个不同字符出现的频度。用适当的测试数据来验证这个算法。 void frequency(String& s, char& A[], int& C[], int &k) { int i, j, len = s.length(); if (!len) { cout } 复制代码 假设以数组Q[m]存放循环队列中的元素, 同时以rear和length分别指示环形队列中的队尾位置和队列中所含元素的个数。试给出该循环队列的队空条件和队满条件, 并写出相应的插入(enqueue)和删除(dlqueue)元素的操作。 循环队列类定义 include template class Type> class Queue { //循环队列的类定义 public: Queue ( int=10 ); ~Queue ( ) { delete [ ] elements; } void EnQueue ( Type & item ); Type DeQueue ( ); Type GetFront ( ); void MakeEmpty ( ) { length = 0; } //置空队列 int IsEmpty ( ) const { return length == 0; } //判队列空否 int IsFull ( ) const { return length == maxSize; } //判队列满否 private: int rear, length; //队尾指针和队列长度 Type *elements; //存放队列元素的数组 int maxSize; //队列最大可容纳元素个数 }； 复制代码 template class Type> Queue::Queue(int sz) : rear(maxSize - 1), length(0), maxSize(sz) { //建立一个最大具有maxSize个元素的空队列。 elements = new Type[maxSize];//创建队列空间 assert(elements != 0);//断言: 动态存储分配成功与否 } templateclass Type> void Queue::EnQueue(Type &item) { assert(!IsFull());//判队列是否不满，满则出错处理 length++;//长度加1 rear = (rear + 1) % maxSize;//队尾位置进1 elements[rear] = item;//进队列 } templateclass Type> Type Queue ::DeQueue() { assert(!IsEmpty());//判断队列是否不空，空则出错处理 length--;//队列长度减1 return elements[(rear - length + maxSize) % maxSize];//返回原队头元素值 } templateclass Type> Type Queue ::GetFront() { assert(!IsEmpty()); return elements[(rear - length + 1 + maxSize) % maxSize];//返回队头元素值 } 复制代码 已知A[n]为整数数组，试写出实现下列运算的递归算法： (1) 求数组A中的最大整数。 (2) 求n个整数的和。 (3) 求n个整数的平均值。 include class RecurveArray { //数组类声明 private: int *Elements; //数组指针 int ArraySize; //数组尺寸 int CurrentSize; //当前已有数组元素个数 public : RecurveArray ( int MaxSize =10 ) : ArraySize ( MaxSize ), Elements ( new int[MaxSize] ){ } ~RecurveArray ( ) { delete [ ] Elements; } void InputArray(); //输入数组的内容 int MaxKey ( int n ); //求最大值 int Sum ( int n ); //求数组元素之和 float Average ( int n ); //求数组元素的平均值 }; void RecurveArray :: InputArray ( ) { //输入数组的内容 cout > Elements[i]; } int RecurveArray :: MaxKey ( int n ) { //递归求最大值 if ( n == 1 ) return Elements[0]; int temp = MaxKey ( n - 1 ); if ( Elements[n-1] > temp ) return Elements[n-1]; else return temp; } int RecurveArray :: Sum ( int n ) { //递归求数组之和 if ( n == 1) return Elements[0]; else return Elements[n-1] + Sum (n-1); } float RecurveArray :: Average ( int n ) { //递归求数组的平均值 if ( n == 1) return (float) Elements[0]; else return ( (float) Elements[n-1] + ( n - 1) * Average ( n - 1 ) ) / n; } int main ( int argc, char* argv [ ] ) { int size = -1; cout > size; RecurveArray ra ( size ); ra.InputArray(); cout} 复制代码 已知f为单链表的表头指针, 链表中存储的都是整型数据，试写出实现下列运算的递归算法： (1) 求链表中的最大整数。 (2) 求链表的结点个数。 (3) 求所有整数的平均值。 include //定义在头文件\"RecurveList.h\"中 class List; class ListNode { //链表结点类 friend class List; private: int data; //结点数据 ListNode *link; //结点指针 ListNode ( const int item ) : data(item), link(NULL) { } //构造函数 }; class List { //链表类 private: ListNode *first, current; int Max ( ListNode *f ); int Num ( ListNode *f ); float Avg ( ListNode *f, int& n ); public: List ( ) : first(NULL), current (NULL) { } //构造函数 ~List ( ){ } //析构函数 ListNode* NewNode ( const int item ); //创建链表结点, 其值为item void NewList ( const int retvalue ); //建立链表, 以输入retvalue结束 void PrintList ( ); //输出链表所有结点数据 int GetMax ( ) { return Max ( first ); } //求链表所有数据的最大值 int GetNum ( ) { return Num ( first ); } //求链表中数据个数 float GetAvg ( ) { return Avg ( first ); } //求链表所有数据的平均值 }; ListNode* List :: NewNode ( const int item ) { //创建新链表结点 ListNode *newnode = new ListNode (item); return newnode; } void List :: NewList ( const int retvalue ) { //建立链表, 以输入retvalue结束 first = NULL; int value; ListNode *q; cout > value; //输入 while ( value != retvalue ) { //输入有效 q = NewNode ( value ); //建立包含value的新结点 if ( first == NULL ) first = current = q;//空表时, 新结点成为链表第一个结点 else { current->link = q; current = q; } //非空表时, 新结点链入链尾 cin >> value; //再输入 } current->link = NULL; //链尾封闭 } void List :: PrintList ( ) { //输出链表 cout data link; } cout } int List :: Max ( ListNode *f ) { //递归算法 : 求链表中的最大值 if ( f ->link == NULL ) return f ->data; //递归结束条件 int temp = Max ( f ->link ); //在当前结点的后继链表中求最大值 if ( f ->data > temp ) return f ->data; //如果当前结点的值还要大, 返回当前检点值 else return temp; //否则返回后继链表中的最大值 } int List :: Num ( ListNode *f ) { //递归算法 : 求链表中结点个数 if ( f == NULL ) return 0; //空表, 返回0 return 1+ Num ( f ->link ); //否则, 返回后继链表结点个数加1 } float List :: Avg ( ListNode *f , int& n ) { //递归算法 : 求链表中所有元素的平均值 if ( f ->link == NULL ) //链表中只有一个结点, 递归结束条件 { n = 1; return ( float ) (f ->data ); } else { float Sum = Avg ( f ->link, n ) * n; n++; return ( f ->data + Sum ) / n; } } include \"RecurveList.h\" //定义在主文件中 int main ( int argc, char* argv[ ] ) { List test; int finished; cout > finished; //输入建表结束标志数据 test.NewList ( finished ); //建立链表 test.PrintList ( ); //打印链表 cout } 复制代码 字符串的替换操作 replace(String &s, String &t, String &v) 是指： 若t是s的子串，则用串v替换串t在串s中的所有出现；若t不是s的子串，则串s不变。例如，若串s为“aabbabcbaabaaacbab”，串t为“bab”，串v为“abdc”，则执行replace操作后，串s中的结果为“aababdccbaabaaacabdc”。试利用字符串的基本运算实现这个替换操作。 String & String::Replace(String & t, String &v) { if ((int id = Find(t)) == -1) //没有找到，当前字符串不改，返回 { cout } 复制代码 试编写一个求解Josephus问题的函数。用整数序列1, 2, 3, ……, n表示顺序围坐在圆桌周围的人，并采用数组表示作为求解过程中使用的数据结构。然后使用n = 9, s = 1, m = 5，以及n = 9, s = 1, m = 0，或者n = 9, s = 1, m = 10作为输入数据，检查你的程序的正确性和健壮性。 void Josephus(int A[], int n, int s, int m) { int i, j, k, tmp; if (m == 0) { cout 1; i--) { /*逐个出局，执行n-1次*/ if (i == k) i = 0; i = (i + m - 1) % k; /*寻找出局位置*/ if (i != k - 1) { tmp = A[i]; /*出局者交换到第k-1位置*/ for (j = i; j } 复制代码 编写类 String 的构造函数、析构函数和赋值函数已知类 String 的原型为： class String { public: String(const char *str = NULL); // 普通构造函数 String(const String &other); // 拷贝构造函数 ~String(void); // 析构函数 String & operate = (const String &other); // 赋值函数 private: char *m_data; // 用于保存字符串 }; 复制代码 请编写 String 的上述 4 个函数。 // String 的析构函数 String::~String(void) { delete[] m_data; // 由于 m_data 是内部数据类型，也可以写成 delete m_data; } // String 的普通构造函数 String::String(const char *str) { if (str == NULL) { m_data = new char[1]; // 若能加 NULL 判断则更好 *m_data = ‘\\0’; } else { int length = strlen(str); m_data = new char[length + 1]; strcpy(m_data, str); } } // 拷贝构造函数 String::String(const String &other) { int length = strlen(other.m_data); m_data = new char[length + 1]; // 若能加 NULL 判断则更好 strcpy(m_data, other.m_data); } // 赋值函数 String & String::operate = (const String &other) { if (this == &other) return *this; delete[] m_data; int length = strlen(other.m_data); m_data = new char[length + 1]; strcpy(m_data, other.m_data); return *this; } "},"7.常见面试题/5.智力题.html":{"url":"7.常见面试题/5.智力题.html","title":"智力题","keywords":"","body":" 扑克牌问题 问题：一付54张扑克牌，其中有十张是翻过来的。现在把你的眼睛蒙上（绝对没有偷看的可能），让你把扑克牌分成两叠（两叠的多少可以不一样）。要求在两叠中翻过来的扑克牌是相等的。请问该怎么做？除了扑克牌的数目，其它因数（扑克牌大小，重量，颜色，表面触摸的感觉，等等）不参与题目之中。扑克牌可以任意次重新排序、翻转。10张翻过来的扑克牌是随机分布在扑克牌中。 答案：第一步，你在这54张牌中任意取出10张，现在，扑克牌分成了两叠。44张和10张；第二步，44张那叠不动，将10张这叠每张都翻过来，便得到了符合条件的两叠牌。 解释：第一步之后，设44张那叠中正面牌x张，10张那叠中正面牌则为10-x张。第二步之后，44张那叠中正面牌保持x张，10张那叠反过来了：反面牌为10-x张，正面牌x张。 分金条问题 问题：有个商人雇用了一位手艺高超的工匠了为他做一个精致产品，工作一星期七天的代价是一条金条。商人手头上有一条金条，刚好有可以付工匠一星期的工钱。但工匠要求工钱要按每天来付。虽然他并不急着用钱，每天有钱进账，老人心里总是踏实一些。但商人家中有个规矩，金条每星期只能切二刀。后来商人想出以了个切割金条的办法，满足了工匠的要求。你知道商人是怎么切割金条才能满足工匠的吗？ 答案：两刀平均切成1、2、4大小的，可以组合成任意一天。 解释：这三个二进制数的组合能表示0-7中的任何一个。 送花瓶 问题：古时候有一位商人要让伙计将一个精致的花瓶送到买主的手里。只要把花瓶锁在箱子里就可以安全地送到目的地。商人还准备了一把精致的铁锁将花瓶锁在箱子里。这把铁锁的钥匙是独一无二的，没有这把钥匙，按照当时的技术箱子是绝对打不开的。但问题来了，土匪只要见到钥匙就会没收。钥匙都是没法安全地送到买主的手里的。买主也不能把自己的锁送给卖主用。在几经周折后，买主终于得到了他心爱的花瓶。请问这花瓶是如何送到买主的手里的？ 这是一个故事，但故事里的技术是实在的，也确实运用到了如今的高科技中。在互联网中怎样将信息安全地送到目的地而不被黑客在中途截获，也是成功地运用了类似的方法。你知道故事的答案吗？ 答案：(只要让箱子一直处在锁着的安全状态)，商人先上锁把箱子运给买主，买主再上锁送回来，商人再把自己的锁打开再运给买主 切蛋糕 问题描述：有一个长方形的蛋糕，中间已被挖去了一个长方形的坑。这长方形的坑不在蛋糕的中央，也不与蛋糕的周边平行。两位小朋友想平分这个蛋糕，请问如何一刀将但蛋糕分成两个体积相等的部分？条件：只能切直的一刀，而且不能拦腰将蛋糕分成上下两个部分（因为蛋糕上面有好吃的糖果。 答案：沿着两个矩形的中心连线切下去即可。 解释：两份蛋糕图形的面积相等，都等于大矩形面积的一半减去小矩形面积的一半。 iPhone 四位数密码 问题描述：一个朋友打开了他的iPhone，我一把把它抓过来说：‘嗯，9、6、0，和1，对吧？’。因为有浓重的手指印在这四个数字上面，我正确地推定这与他的密码相关。他吓了一跳，因为如果我是一个贼，我可以很容易解开他的电话。因为所有的四个数字在四位数字代码中只有一次出现（据我所知，这只有4 x 3 x 2 x 1 = 24种可能）。因而，取四个不同数字作代码不是非常安全的。所以，当我设定密码时，我选择了重复的数字（如1-2-3-1）。这样一来，如果有人会看我的手机，即使他们能够探测到我的手指印，他们要么在猜想第四个数字（不存在），或者，他们如果弄清楚我只用三个独立数字，他们将不得不尝试在一个四位数代码中，列出这三个不同数字所有可能的排列。问题是：1．在一个四位数的代码中，只使用三个数字对安全是否确实有帮助？2．如果只重复使用两个独立的数字会不会更好呢？ 答案：用三个数字最安全，两个数字最不安全，四个数字居中。 解释：1)、4个位置不同时,排列数=4321=24；2)、3个位置不同时,排列数=C(4,2)23=36；选择三个数中哪个数重复3种情况，再进行排列12中，总共312=36种 3)、2个位置不同时,排列数=3个重复情况（4+4）+两两重复情况（6）=14。 书有多少页 问题描述：一本书有N页厚。书的页数是从1 到N。所知道的是，所有的页数总共用了1095个数码字。请问这本书有多少页？ 答案：401页 解释：有9页个位数的书页，每页用一个数码字。90页两位数的书页，每页用2个数码字。首先假设没有四位数的书页，而三位数书页的数目为x。因为总共用了1095个数字，所以列出x的方程：9+290+3x=1095。解出x=302，总的书页数=302+9+90=401。 左轮枪 问题描述：某公司招聘员工面试时提的问题：“让我们来玩个游戏”，招聘人开始了。“你现在被牢牢地绑在椅子上不能动。这是一把枪，一把六星左轮抢，六个弹槽都空着。现在，我把两颗子弹装入弹槽。看到我把子弹装入两个相邻的弹槽了吗？我把轮子合上，然后用手拨动让轮子转动几圈。我把枪对着你的头，扣动了扳机，…，叭。你真幸运！第一枪撞针没打中子弹。然后，我要再扣一次扳机。”招聘人接着说：“我可以直接扣动扳机，或旋转轮子一下再扣扳机，你可以选择其中一种，请问，你选哪一种方法呢？”庆幸的是这只是一把想象中的枪。招聘人只是用手势做出旋转轮子和扣动扳机的样子。但不幸的是你的前程却掌握在挥舞着‘手枪’的家伙的手里。 当然，这两种方法都不是你要的，但其中一种方法的生存的机会会大一些。你到底应该选择哪一种方法呢？ 答案：选择‘不转’，因为被打死的概率更小。 解释：题中说：子弹是装入两个相邻的弹槽，左轮枪是一格一格往下转的，如右图所示。1) 第一枪没有打出子弹，因此，第一枪的位置只可能是A、B、C、D。那么，接连第二枪的位置就会是第一枪的下面一个，也就是：B、C、D、E，这4个位置中，只有E有子弹。所以，如果直接扣动扳机，几率=1/4。2) 如果重新把轮子转一下，左轮枪将处于随机的位置，6个格子有2颗子弹，这时挨枪的机率为2/6=1/3。3. )1/4 导火索 问题描述：有两根导火索，它们的长度都是正好1分钟烧完。但是它们燃烧的速度是不均匀的。也就是说，你不能用一小段的长度与总长度的比值来确定燃烧完这一小段的时间。用这两根导火索和一只打火机，没有其它计时器的帮助，请你给我报告两次时间信号：开始的时间t1、结束的时间t2。时间t1和t2准确地相差45秒。 答案：将其中一根的两头，以及另一根的一头，同时点燃，这个时刻定为t1。当第一根烧完时，立即后点燃第二根的另一端，第二根烧完的时刻便是t2。 解释:见下图：第一根两头点燃，直到烧完，时间是30秒。这时第二根也烧了30秒，因第二根只点了一端，因而只烧完了一半时间，剩下的部分还能烧30秒，这时马上点燃它的另一端，变成从两头同时烧，因而烧完的时间是15 秒，加上开始的30秒，总共历时45秒。 计时沙漏 问题描述：沙漏（hourglass）是最早使用的计时仪器之一。如下图（a）中所示的沙漏，是上下对称的，可以倒来倒去地计时。比如说，如果有一个2分钟的沙漏，你便可以漏一次得到2分钟，漏完后立即倒过来，再漏完，总共得到4分钟的时间。 现在，给你一个4分钟的沙漏，和一个7分钟的沙漏，它们都是可以倒来倒去的对称沙漏。如何将它们配合使用，才能得到准确的、从开始到结束总共9分钟的时间？ 用图形，我们可以更方便地说明这个问题。一个沙漏某时刻的状态可以用上下重叠的两个带数字的方格表示，例如，上图（b）所表示的是7分钟沙漏的初始状态和漏了2分钟后的状态。上图中的（c）则是要请你回答的问题。 解释：设7分钟的沙漏为A，4分钟的为B，A，B同时漏，4分钟后， 状态为 （A ： 3，4）；（ B：0，4）；B倒过来， 3分钟A漏完全后， 状态为（A ： 0，7）； （B：1，3）；A倒过来， 1分钟B漏完全后， 状态为（A ： 1，6）； （B：0，4），A倒过来, 1分钟后，状态为（A ： 0，7）； 测量砖头的对角线 问题描述：单凭三个砖块和一把尺子，不使用任何公式，怎样才能测量一个砖头的立体对角线？就是穿过砖头内部的那条对角线。 答案：将三块砖头如图迭起来，就可测量。 毒药老鼠 问题描述：有100只一模一样的瓶子，编号1-100。其中99瓶是水，一瓶是看起来像水的毒药。只要老鼠喝下一小口毒药，一天后则死亡。现在，你有7只老鼠和一天的时间，如何检验出哪个号码瓶子里是毒药？ 答案：首先，将瓶子的10进制编号数改成7位的2进制码。然后，让第1只老鼠喝所有2进制码第1位是1的瓶子中的水；让第2只老鼠喝所有2进制码第2位是1的瓶子中的水；以此类推下去。这样，每个老鼠第二天的死活情况就决定了毒水瓶子二进制码这一位的数字：老鼠死，对应1，反之为0。 这儿把它叫做‘问题1’，解决此题的方法可谓二进制应用的经典： 首先，将瓶子的10进制编号数改成7位的2进制码。然后，让第1只老鼠喝所有2进制码第1位是1的瓶子中的水；让第2只老鼠喝所有2进制码第2位是1的瓶子中的水；以此类推下去。这样，每个老鼠第二天的死活情况就决定了毒水瓶子二进制码这一位的数字：老鼠死，对应1，反之为0。换言之，将7只老鼠死活情况排成一排。比如说结果是“死活死死活活死”的话，毒水瓶子的二进制标签就是：1011001，转换成10进制，得到89。 距离问题 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以第 小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞 行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？ 参考答案:答案很容易计算的： 假设洛杉矶到纽约的距离为s 那小鸟飞行的距离就是(s/(15+20))*30。 概率问题 你有两个罐子，50个红色弹球，50个蓝色弹球，随机选出一个罐子，随机 选取出一个弹球放入罐子，怎么给红色弹球最大的选中机会？在你的计划中，得到 红球的准确几率是多少？ 参考答案:一个罐子放一个红球,另一个罐子放49个红球和50个蓝球,概率接近75%. 这是所能达到的最大概率了。实际上，只要一个罐子放 重量问题 你有四个装药丸的罐子，每个药丸都有一定的重量，被污染的药丸是没被 污染的重量+1. 只称量一次，如何判断哪个罐子的药被污染了？ 参考答案:从第一盒中取出一颗，第二盒中取出2 颗，第三盒中取出三颗。 依次类推，称其总量。再根据总重量增加多少判断污染的药罐。 夸脱的水问题 如果你有无穷多的水，一个3夸脱的和一个5夸脱的提桶，你如何准确称出 4夸脱的水？ 参考答案: 思路：4夸脱最后必定是在大桶桶中，3+1=4只要能称出1就行，3+3-5=1，只要小桶往大桶倒两次水，满了后小桶就剩1，再加一小桶水就是4夸脱了。 "},"8.Python/":{"url":"8.Python/","title":"第八部分 Python","keywords":"","body":""},"8.Python/附：Python速查表.html":{"url":"8.Python/附：Python速查表.html","title":"Python速查表","keywords":"","body":"Python Cheatsheet "}}