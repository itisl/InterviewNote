# 拷贝和移动
## 1. 浅拷贝和深拷贝
当利用已存在对象初始化新对象时，调用新对象的拷贝构造函数进行初始化，这个过程叫做拷贝
**浅拷贝**：将已存在对象的内存内容直接复制到新对象的内存。如果成员中有指针变量时会复制其指向的地址，新对象可能会访问到已存在对象的指针成员指向的堆上内存空间

**深拷贝**：将整个已存在对象的完整状态拷贝到新对象，如果有指针指向堆上内存，会重新在堆上开辟新的内存，并将指针变量指向新的内存

### 1.1 浅拷贝构造函数
**作用**：类内成员变量含指针、动态分配的内存时，必须定义拷贝构造函数进行深拷贝，否则编译器会生成默认浅拷贝构造函数。
**规则**：
1. 用法：
    ```cpp
    A(const A &a); //拷贝构造函数的声明，注意参数不能为值传递
    A(const A &a)=delete;//指示编译器不生成默认复制构造函数
    A a2 = a;   // 等价于A a2(a); 调用拷贝构造函数初始化
    a2 = a; //调用拷贝赋值函数operator =
    ```
2. 没有定义拷贝构造函数时，编译器**自动生成浅拷贝构造函数**
3. 拷贝构造函数和**拷贝赋值操作**`operator =`需要同时给出，如果没有定义，编译器会**自动生成浅拷贝赋值函数**
4. 可以在`private`中加入拷贝构造的声明或使用`=delete`，防止生成默认拷贝函数
5. 拷贝构造函数参数**不能使用值传递**，否则形参会继续调用拷贝构造函数创建临时对象，陷入死循环
6. 如果不加`const`限制，将不能拷贝`const`修饰的对象



### 1.2 深拷贝构造函数
**作用**：不指定拷贝构造函数时，编译器默认执行浅拷贝。为了实现深拷贝，需要定义拷贝构造函数

```cpp
// String对象的深拷贝构造函数
inline String::String(const String& str){
    data_=new char[strlen(str.data_) + 1];
    strcpy(data_, str.data_);
}
```

存在继承时，父类的拷贝部分应该在初始化列表中调用父类的拷贝构造函数
### 1.3 拷贝赋值函数
动态分配成员的类除了深拷贝构造函数时，还必须定义**拷贝赋值函数**，即`operator=`，为了连续赋值，需要返回引用
> ==定义拷贝赋值函数的步骤：==
> 1. 先判断是否自我赋值
> 2. `delete`掉当前对象数据的内存（如果继续指向原空间可能有空间大小不一致等问题，更改指向而不`delete`会造成内存泄漏）
> 3. `new`申请一块与被复制对象数据相等的内存空间，并复制内容
```cpp
// String对象的拷贝赋值函数
inline String &String::operator=(const String& str){
    if(this == &str){ //先判断是否是自我赋值
        return *this;
    }
    delete[] this.data_; //先delete已存在的字符串
    this.data_ = new char[strlen(str.m_data) + 1]; //+1是末尾的'\0'
    strcpy(this.data_, str.data_);
    return *this;
}
String s2{s1}; // 调用拷贝构造函数
String s3 = s1; // 调用拷贝赋值函数
```

## 2. 移动操作
和拷贝构造一样，移动构造函数和移动赋值操作`operator=`必须同时给出，移动操作可以代替深拷贝，最小化拷贝量而不会增加复杂性。

### 2.1 移动构造函数
- 以自身为参数时，不会调用移动构造函数，因此不用判断是否自我构造
- 必须要把右值的内容更改掉，把传入的内容指针置空，因此参数不能为`const`
```cpp
String::String(String&& s):data_(s.data_){
    s.data = nullptr;
}
```


### 2.2 移动赋值函数

- 为了连续赋值，移动赋值函数应该返回引用
- 应该判断是否自我移动
- 原先指向的堆空间应该先释放，被移动的对象指针应该置空`nullptr`
- 对传入的参数有改动，参数不能为`const`修饰

```cpp
String& String::operator=(String&& s){
    if(&s != this){
        delete data_;
        data_ = s.data;
        s.data_ = nullptr;
    }
    return *this
}

```