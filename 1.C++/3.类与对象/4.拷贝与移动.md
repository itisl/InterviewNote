## 浅拷贝和深拷贝
当利用已存在对象初始化新对象时，调用新对象的拷贝构造函数进行初始化，这个过程叫做拷贝
**浅拷贝**：将已存在对象的内存内容直接复制到新对象的内存。如果成员中有指针变量时会复制其指向的地址，新对象可能会访问到已存在对象的指针成员指向的堆上内存空间

**深拷贝**：将整个已存在对象的完整状态拷贝到新对象，如果有指针指向堆上内存，会重新在堆上开辟新的内存，并将指针变量指向新的内存

### 拷贝构造函数
**作用**：类内成员变量含指针、动态分配的内存时，必须定义拷贝构造函数进行深拷贝，否则编译器会生成默认浅拷贝构造函数。
**规则**：
1. 用法：
    ```cpp
    A(const A &a); //拷贝构造函数的声明，注意参数不能为值传递
    A(const A &a)=delete;//指示编译器不生成默认复制构造函数
    A a2 = a;   // 等价于A a2(a); 调用拷贝构造函数初始化
    a2 = a; //调用拷贝赋值函数operator =
    ```
2. 没有定义拷贝构造函数时，编译器**自动生成浅拷贝构造函数**
3. 拷贝构造函数和**拷贝赋值操作**`operator =`需要同时给出，如果没有定义，编译器会**自动生成浅拷贝赋值函数**
4. 可以在`private`中加入拷贝构造的声明或使用`=delete`，防止生成默认拷贝函数
5. 拷贝构造函数参数**不能使用值传递**，否则形参会继续调用拷贝构造函数创建临时对象，陷入死循环
6. 如果不加`const`限制，将不能拷贝`const`修饰的对象



### 深拷贝构造函数
**作用**：不指定拷贝构造函数时，编译器默认执行浅拷贝。为了实现深拷贝，需要定义拷贝构造函数

```cpp
// String对象的深拷贝构造函数
inline String::String(const String& str){
    data_=new char[strlen(str.data_) + 1];
    strcpy(data_, str.data_);
}
```

存在继承时，父类的拷贝部分应该在初始化列表中调用父类的拷贝构造函数
### 拷贝赋值函数
动态分配成员的类除了深拷贝构造函数时，还必须定义**拷贝赋值函数**，即`operator=`
> ==定义拷贝赋值函数的步骤：==
> 1. 先判断是否自我赋值
> 2. `delete`掉当前对象数据的内存（如果继续指向原空间可能有空间大小不一致等问题，更改指向而不`delete`会造成内存泄漏）
> 3. `new`申请一块与被复制对象数据相等的内存空间，并复制内容
```cpp
// String对象的拷贝赋值函数
inline String&String::operator=(const String& str){
    if(this == &str){ //先判断是否是自我赋值
        return *this;
    }
    delete[] this.data_; //先delete已存在的字符串
    this.data_ = new char[strlen(str.m_data) + 1]; //+1是末尾的'\0'
    strcpy(this.data_, str.data_);
    return *this;
}
String s2{s1}; // 调用拷贝构造函数
String s3 = s1; // 调用拷贝赋值函数
```

## 移动操作

### 移动构造函数
和拷贝构造一样，移动构造函数和移动赋值操作`operator=`必须同时给出
代替深拷贝，最小化拷贝量而不会增加复杂性
