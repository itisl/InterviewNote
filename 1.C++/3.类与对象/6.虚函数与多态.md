## 多态
**概念**：同一种操作可以作用于不同的对象，可以有不同的解释，产生不同的执行结果
父类指针可以指向父类对象，也可以指向子类对象，并且能够正确执行相对应类的函数。多态定义了统一的接口，使一个函数能够同时处理子类和父类的对象，并完成相对应类的功能，同一个函数在父类和子类中可以实现不同功能

**规则**：
1. 父类指针**允许访问的范围**只限于父类定义的成员
2. 父类指针可以指向子类对象，子类指针不能指向父类对象（父类指针允许访问内存范围小，安全；子类指针访问范围更大，访问父类对象可能会访问越界）
3. 继承方式必须为`public`
4. 构成多态的要素：
   - 子类覆盖`override`父类的成员函数
   - 父类指针指向子类对象
   - 利用父类指针调用子类覆盖的成员函数
5. 多态是利用虚函数表实现的，详见内存模型的[虚函数表与虚指针](../7.内存模型/6.虚函数表与虚指针.md)

> - 指针和引用都能实现多态，但是引用没有指针灵活


## 虚函数 
**作用**：默认情况下不存在多态，编译器只会根据指针类型调用对应的函数，不存在多态。**虚函数的作用就是构成运行时的多态。**

**规则**：
1. 虚函数使用`virtual`声明，`virtual func() 虚说明符序列{}; `，虚说明符序列，必须是 `override`/`final`/`override final`之一
    ```cpp
    
    class A{
    public:
    virtual ~A(); //将析构函数声明为虚函数
    ...
    };
    ```
2. 虚函数是可在子类中覆盖其行为的成员函数，即使没有关于该类实际类型的编译时信息，仍保留被覆盖的行为（纯虚函数）
3. [重载和覆盖的区别](../4.函数/3.函数重载.md)
4. 对于`virtual`函数，必须形参列表相同才能`override`，否则编译器会认为相互独立而遮蔽
5. 

> **虚函数注意事项**：
- 只有类的**成员函数**才能声明为虚函数。
- **构造函数**不能是虚函数，因为构造函数不能被继承
- 父类的**析构函数**应该声明为虚函数（防止父类指针只析构父类部分而不析构子类）
- 只需要在虚函数的声明处加上`virtual` 键字，函数定义处可以加也可以不加(最好加上以及使用`override`，使程序更加清晰)。
- 在父类中定义了虚函数时，如果**子类没有**定义新的函数来覆盖此函数，那么子类对象将用父类的虚函数。
- **静态成员函数**不能使用虚函数，因为它不受限于某个对象。
- **内联函数**不能是虚函数。


### 纯虚函数和抽象类
**作用**：没有函数体且声明为`= 0`的虚函数，用来定义接口规范
有时候父类希望子类拥有统一的功能（例如People都要工作），但是父类无法给出具体的定义（不同的职业工作内容不一样），父类就可以定义纯虚函数自己不定义虚函数，交给子类完成定义
**规则**：
1. 纯虚函数的声明，使用` = 0`:
    ```cpp
    virtual type FunName(para_list) = 0; //在结尾加上=0告诉编译器这是纯虚函数
    ```
2. 纯虚函数没有函数体
3. **含有纯虚函数的类是抽象类**
    - 抽象类不可实例化，没有构造函数
    - 抽象类可以有其他非纯虚函数成员
4. 纯虚函数为子类提供约束，子类必须覆盖所有的纯虚函数，否则子类依然是抽象类
5. 只有类中的虚函数才能被声明为纯虚函数



