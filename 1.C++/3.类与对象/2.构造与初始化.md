## 构造函数
**作用**：对象创建时自动调用，用于初始化对象。
**规则**：
1. 用法：
    ```cpp
    class A{
    public:
        A(); //构造函数
        ~A(); //析构函数 
    };
    ```
2. 名字和类名相同，无返回值
3. 构造函数没有名字且无法被直接调用。它们在发生初始化时调用，且它们按照初始化的规则进行选择
4. 存在自定义构造函数时，必须选择其中之一进行对象初始化
5. 单参数的构造函数应该声明为`explicit`，避免编译器做类型转换
6. 使用`A()=default;`并不实现，编译器会自动生成默认构造函数
7. 有`constexpr`说明符的构造函数令其类型成为字面类型(LiteralType)

### 默认构造函数
**作用**：构造对象时默认调用的构造函数
**规则**
> - 不能定义两个带初始值的默认构造函数（会报错）。
> - 程序中已定义构造函数，编译器不会再隐含生成
> - 调用没有参数的构造函数可以省略括号：`Clock today;`


#### 参数初始化列表
**作用**：在构造函数中对成员变量赋值，等价于逐个变量`=`（语法糖）。同时可以为`const`类型变量初始化(也可以使用类内初始化器)
**规则**：
1. 只能用于构造函数：
    ```cpp
    A::A(int a,int b,int c):
    a_(a),b_(b), c_(c){}
    ```
2. 只能初始化非静态数据成员（也就是属于对象的部分）
3. 使用构造函数初始化`const`成员变量、引用时，只能用参数初始化列表，否则使用类内初始化
4. 参数初始化顺序只与成员变量在类中声明的顺序有关，与初始化表列出的变量的顺序无关（**低位地址先初始化**）
5. 如果声明和实现分离，初始化列表只能用于实现，**不能用于声明**
6. 可以和函数默认参数配合使用
7. 初始化列表的构造函数，会先执行初始化，再执行函数体

如果自定义了构造函数，全局区对象会把未指定初值的成员变量初始化为`0`，其他内存空间的对象成员变量不会被初始化，需要显式初始化

构造函数和析构函数都为`public`，对象才能正常使用

#### 类内初始化(C++11起)
**规则**：
1. 用法：
    ```cpp
    class A{
        int a{1};// 或int a = 1; 注意这里不能使用()初始化
        const int b{2}; // const int b = 2;
    }
    ```
2. 直接在类内初始化成员变量，与构造函数是等价的，没有构造函数时编译器会生成默认构造函数
3. 类内初始化不能初始化`static`成员变量，必须在类外初始化（C++17可以使用`inline`在类内初始化`static`成员变量）


## 其他构造函数
> 拷贝构造函数和移动构造函数见[拷贝与移动](./4.拷贝与移动.md)

### 转换构造(隐式构造)函数
编译器会隐式调用单参数的构造函数
> 不希望编译器隐式调用单参数构造函数时，可以使用`explicit`禁止隐式调用

[转换构造函数](../4.函数/4.转换函数.md)还作为用户定义的转换序列中的一部分，在复制初始化中受到考虑
隐式声明的及用户定义的非`explicit`复制构造函数与移动构造函数也是转换构造函数
```cpp
// 加上默认参数，构成单参数构造函数
Fraction(int numerator, int denomirator=1)
:numerator_(numerator), denomirator_(denomirator){ }
Fraction operator+(...){ //重载operator+
    return Fraction(...);
}
// 运算时，会将整数当做一个参数
Fraction f(3, 5);
double d = 4 + f; // 调用构造函数将4转换为F(4,1), 然后调用operator+
```

### 委托构造函数
**作用**：使用类的其他构造函数执行初始化过程(两个构造函数功能相似时，可以调用减少代码量)
**规则**：
1. 用法：
    ```cpp
    A::A():
        a_(0),b_(0), c_(0){} //默认构造函数
    A::A():A(){...}; //使用委托构造函数，先调用默认构造函数A()
    ```
2. 只能在初始化列表调用其他构造函数

### 编译器默认生成的构造函数
编译器会在下面情况自动生成默认构造函数
- 成员变量声明时进行了初始化（类内初始化）
- 有定义虚函数
- 虚继承了其他类
- 成员有其他对象类型，且这个成员构造函数
- 父类有构造函数
总结：创建对象时，需要进行内存操作（初始化、生成虚表指针等，以及成员的初始化和构造）时，编译器才会自动生成构造函数