## 析构函数
**作用**：用于销毁对象，释放内存。对象内部申请的堆空间，需要由析构函数回收
**规则**：
1. 类外自定义析构函数：
    ```cpp
    Clock::~Clock(){
        delete[] arr_; //释放申请的数组的内存
    } //析构函数定义
    ```
2. 一个类只有一个析构函数
3. 析构函数在销毁对象时自动执行，，**没有参数和返回值**
4. 当类中不存在指针、动态分配内存时，可以不指定析构函数；否则必须指定用来释放掉指针所指向内存，避免内存泄漏
5. 存在**父类指针指向子类对象时**，父类的析构函数必须为`virtual`，否则父类指针不会调用子类析构函数，会部分析构而内存泄漏



## 子类的构造与析构
### 子类构造函数
**规则**：
1. 用法：子类构造函数**在初始化列表**指明父类构造函数（和委托构造函数一样）
    ```cpp
    People(std::string name,int age);//父类构造函数声明
    Student(std::string name,int age,float score);//子类构造函数声明
    Student::Student(std::string name,int age,float score):
    People(name, age), score_(score){
        ... //单继承子类构造函数的初始化列表
    }
    ```
2. 如果初始化列表没有指定父类构造函数，**就默认调用父类的无参构造函数**；如果父类没有无参构造函数（但是有其他构造函数），编译失败；如果父类没有构造函数，就不调用父类构造函数，只执行子类的构造函数
3. 构造函数不能直接继承，即使继承也不是子类构造函数（使用`using`，不推荐）
4. 多继承调用父类构造函数，顺序按照继承时声明的顺序
5. 子类构造函数中只能调用直接父类的构造函数，不能调用间接父类的构造函数


### 子类析构函数
**规则**：
1. 析构函数也不能被继承，与构造函数不同的是，在子类的析构函数中不用显式地调用父类的析构函数，子类会自动调用父类析构函数
2. 父类的析构函数应该为`virtual`，并且子类存在需要手动释放的内存时，子类必须`override`该虚函数，否则使用父类指针指向子类对象时，会造成只析构父类部分


#### 构造、析构的顺序

> 在内存中，父类的成员在前（低位），子类的成员在后（高位），申请和释放内存像栈一样（这是单个对象的内存布局，永远是从低到高，和栈多个对象从高位到低位生长没关系）

子类(或复合)对象**构造由内到外**： Derivrd构造函数先调用Base的默认构造函数，然后调用Component的默认构造函数，然后执行自己
```cpp
Derived::Derived(...):Base(), Component(){ ... }
```
子类(或复合)对象**析构由外到内**：Derived析构函数先执行自己，然后调用Component的析构函数，然后再调用Base析构函数(顺序相反)
```cpp
Derived::~Derived(...):{ ... ~Component(), ~Base() }
```
![子类对象与父类对象关系](https://i.loli.net/2020/04/07/LMjbBPWaoyeUwpI.png)


