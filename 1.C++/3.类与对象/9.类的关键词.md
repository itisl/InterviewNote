

### `this`指针
**作用**：
1. `this`是一个指针，指向当前调用函数的对象的地址
   - 在类的非静态成员函数中需要返回类对象本身的时候，使用 `return *this;`
   - 当参数与成员变量名相同时，如`this->n = n;` （不能写成`n = n`）

**规则**：
1. 用在类的内部，是一个`const`指针，指向当前对象，可以用`->`来访问当前对象的成员变量或成员函数
2. `this`通过指针常量`T* const this`形参传入，在成员函数中不能被修改指向，**只能在非静态成员函数内部使用**
3. `this`实质上是成员函数的一个隐藏形参，在调用成员函数时将对象地址作为实参传递给`this`, 在编译阶段由编译器自动将其添加到参数列表
4. `this`是一个右值，不能取得`this`的地址(不能`&this`)

### `const`成员
`const`可以用来修饰成员变量、**非静态成员函数**、对象
> **注意：`const`用于函数名前面用于修饰返回值，只有用于后面才是`const`成员函数，注意区分**

- `const`**成员变量**：和普通变量用法一样，必须初始化
  - 参数初始化列表
  - 或类内初始化
- `const`**成员函数**：`int A::func_() const{}`
  - 可以访问类中所有成员变量，但是不能修改除**静态成员**以外的变量
  - 在定义和声明的时候都要使用`const`
  - `static`成员函数不能使用`const`
  - 只能调用`const`或`static`成员函数
  - `const`成员函数可以和非`const`构成重载，非`const`对象优先调用相对应类型的函数

- `const`**对象**：
  - `const`对象只能使用`const`或`static`成员函数，可以访问`public`变量，但不能修改
  - 

> **注意**：`const`成员函数中，实际上`const`修饰的是`*this`，因此`const`成员函数不可以修改非`static`成员(可以修改`static`和`mutable`修饰的成员变量，因为`static`不属于子对象)

```cpp
int gethour() const; //类内
void Clock::gethour() const{
    return m_hour;
}
```
> 1. `const`成员函数可以使用类中所有成员变量，但是不能修改它们的值
> 2. `const`成员函数声明和定义都必须使用`const`后缀
> 3. `const`对象只能调用`const`成员函数，不能调用非`const`成员函数

### `mutable`
**`mutable`**：容许在即便包含它的对象被声明为`const`时仍可修改声明为`mutable`的类成员。如果需要一部分成员变量能在`const`成员函数中修改(用于改变`const`对象)，可以加上`mutable`修饰：

```cpp
mutable bool flag;
```

### `override`与`final`
**作用**：
1. `override`为虚函数覆盖，用来防止出现意外的继承行为。`override`说明编译器会检查该函数是否为虚函数，是否会覆盖父类中的虚函数，如果不是虚函数会报错。
    > ```cpp
    > void func() override{}; // 子类中使用
    > ```
    > 1. 是在**成员函数声明符**之后使用时拥有特殊含义的标识符，其他情况下它不是保留的关键词，如果不能覆盖（不是虚函数、形参不对）会出错
    > 2. 如果没有用`overide`关键字，当虚函数返回类型或参数不一样时将会造成函数的隐藏而不是覆盖
    > 3. 覆盖的方法不能为`private`
2. `final`用来防止类被继承(用于类定义类名后面)或成员函数被覆盖(用于成员函数后)
    ```cpp
    class base final{};
    void setname() final;
    ```

### `explicit`
**作用**：禁止隐式调用单参数的构造函数，包括：
1. 禁止隐式调用拷贝构造函数
```cpp
complex c1(1, 2);
complex c2 = c1 + 5; // 此时会隐式调用构造函数complex(5, imag=0)
```
2. 禁止类对象之间的隐式转换(见转换函数)
> - 一般而言，只有单参数的构造函数会用到`explicit`关键字
> - `explicit`指明构造函数不能作隐式类型转换，只能进行初始化和显式类型转换
> - 用`=`进行初始化可看作拷贝初始化，初始化器是右值时可能会采取移动操作。省略`=`会将初始化变为显式初始化
> - ==单参数的构造函数应声明为`explicit`==，避免发生不必要的类型转换，更多可见转换函数
```cpp
class Clock{
public:
	explicit Clock(int d);
};
```


### `using`
**作用**：`using`可以在子类中使用本来无法使用的父类的成员，无论继承方式为`private`/`protected`，包括构造函数和析构函数
> 如果成员原本是公共的，可以直接使用`B::func()`

用`using`可以继承父类构造函数`using A::A;`，但是只能初始化继承的成员，即使继承了也不能成为子类构造函数，

### `=default`和`=delete`
- `=default`用于要求编译器生成一个默认构造函数，`=default` 可以写在声明处也可以写在定义处，也可以只声明
- `=delete`用于指定编译器禁止该函数调用
  > 在C++11之前，为了防止调用特定函数，需要把函数声明到`private`域并且不实现
  - 禁止编译器使用默认生成的构造函数
  - 也可用于类的成员函数，防止隐式类型转换
  - 重载`operator 操作符`并指定`=delete`可以禁止该操作符，比如重载`new`可以禁止堆上初始化。
  - 在模板特化中，用`=delete`过滤特定的形参类型

```cpp
// 这两种类型可以只声明不实现
class A{
    A()=default;
    void get(double)=delete;
}
```
