## 指针
**说明**：指针Pointer是C++中用于存放地址的变量，其值为内存地址，表示其指向变量或对象，并可以通过解引用`*`引用该对象

**规则**：

1. 指针的定义：
```cpp
int n = 0;
int* ptr = &n; //ptr为指向变量n地址的指针
```
2. `&`为取地址，可以得到变量的地址（`&`用在变量定义）；`*`用于声明指针并代表解引用，`*ptr`表示对对象的解引用，可以通过指针执行操作
3. 指针指向类/结构体的对象时，可以直接用`ptr->mem`访问成员(等价于`*ptr.mem`)
4. `void*`是一种无类型指针，任何类型指针都可以转为`void*`，它无条件接受各种类型。如果期望接口能够接受任何类型的参数，可以使用void*类型。使用`void*`必须清楚原始传入的是什么类型，在函数里使用时要转换成对应类型
5. 避免使用悬空的野指针，当指针定义没指向对象或对象内存已释放时，应当设为空指针`nullptr`

### 指针类型和指针指向的类型
#### 指针类型
**说明**：指针类型是指针定义时的数据类型，不代表其指向内存地址的数据类型
```cpp
int* p = nullptr
```
> 指针类型只指示指针的动作，不说明指针本身的类型

1. 指针的大小是固定的，在x86系统中为4个字节，x64位系统中为8个字节
2. 指针类型决定了指针运算的内存偏移量(包括`+`, `-`, `++`, `--`)，以及解引用`*`时操作的内存大小
3. 指针类型为类时，动作（调用的函数）只取决于指针的类型，和指针指向地址的类型无关（多态例外，多态利用虚表指向调用的函数）



#### 指针指向的类型
指针指向的类型是指针指向的内存地址的数据结构类型
1. 指针类型通常与所指对象的类型一致。例外：
   - 可以用常量指针指向非常量对象
      ```cpp
      int n = 0;
      const int *p = &n;//n的值可以改变，但是不能通过指针*p修改
      ```
   - 指针指向强制类型转换的地址
   - [父类指针可以指向子类对象](../3.类与对象/6.虚函数与多态.md)


### 空指针
空指针`nullptr`是C++11标准的关键字，指针指向`nullptr`代表指针为空。C语言类型空指针`NULL`和`0`可能会造成歧义，代码如下：

```cpp
void f(int);
void f(void*);
f(0); // 调用f(int)
f(NULL); // 实际调用f(int)，与目标调用不符
f(nullptr); // 调用f(void*)
```
空指针类型`nullptr_t`
- 所有定义为`nullptr_t`类型的数据都是等价的，行为也是完全一致。
- `nullptr_t`类型数据可以隐式转换成任意一个指针类型。
式也是不可以的。
- `nullptr_t`类型数据不适用于算术运算表达式。
- `nullptr_t`类型数据可以用于关系运算表达式，但仅能与`nullptr_t`类型数据或者指针类型数据进行比较，当且仅当关系运算符为`==`、`<=`、`>=`等时返回`true`。

## 数组
数组名可以看做指向数组首元素的指针，数组名`arr`是数组首元素的指针，`&arr`是数组指针，但是`sizeof(arr)`是整个数组的大小而不是该指针大小
数组名是一个指针常量
数组的空间是静态分配的
### 数组与指针

`&arr`数组指针，指向整个数组，`int (*p)[3] = &arr;` 指针偏移量为`int[3]`
`arr`数组元素指针`int* p = arr;`，指针偏移量为`int`
数组名`arr`是一个指针常量，无法通过引用非常量指针来引用，详见[引用](./9.引用.md)







