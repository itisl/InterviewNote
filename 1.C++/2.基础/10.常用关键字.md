## 1. 类型说明符
### 1.1 `alignas`说明符
### 1.2 `decltype()`说明符
**作用**：获取变量声明的类型(包括顶层`const`和引用)
```cpp
decltype(f()) sum = x;//sum的类型是f的返回类型
decltype((i)) n = a; //编译器认为(i)为表达式，得到左值引用，如果i为普通变量，最终结果n也是a的引用
```
1. 若实参是指名某个结构化绑定的无括号的标识表达式，则`decltype`产生被引用类型（在关于结构化绑定声明的说明中有所描述）。(C++17 起)
2. 若实参是指名某个非类型模板形参的无括号的标识表达式，则`decltype`生成该模板形参的类型（当该模板形参以占位符类型声明时，则为进行任何所需的类型推导后的类型）。(C++20 起)
3. 若实参为无括号的标识表达式或无括号的类成员访问表达式，则`decltype`产生以此表达式命名的实体的类型。若无这种实体，或该实参指名某个重载函数，则程序非良构。
4. 若实参是其他类型为 T 的任何表达式，且
   - 若 表达式 的值类别为亡值，则`decltype`产生 T&&；
   - 若 表达式 的值类别为左值，则`decltype`产生 T&；
   - 若 表达式 的值类别为纯右值，则`decltype`产生 T。
若 表达式 是返回类类型纯右值的函数调用，或是右操作数为这种函数调用的逗号表达式，则不对该纯右值引入临时量。(C++17 前)
若 表达式 是除了（可带括号的）立即调用以外的 (C++20 起)纯右值，则不从该纯右值实质化临时对象。(C++17 起)
不需要该类型完整或拥有可用的析构函数，而且类型可以是抽象的。此规则不适用于其子表达式：`decltype`(f(g()))中，g()必须有完整类型，但f()不必。
注意如果对象的名字带有括号，则它被当做通常的左值表达式，从而`decltype(x)`和 `decltype((x))`通常是不同的类型。
在难以或不可能以标准写法进行声明的类型时，`decltype` 很有用，例如`lambda`相关类型或依赖于模板形参的类型。
## 占位符类型说明符

### `auto`说明符
`auto`让编译器通过初始值来推算变量类型，`auto`定义的变量必须有初始值
```cpp
auto item1 = var1, item2 = var2;//若var1和var2类型不一样将会报错
```
> 1. 对于**变量**，指定要从其初始化器自动推导出其类型。
> 2. 对于**函数**，指定要从其 return 语句推导出其返回类型。(C++14 起)
> 3. 对于**非类型模板形参**，指定从实参推导出其类型。(C++17 起)

不允许使用`auto`的场景
不能作为函数形参；
不能用于类的非静态成员
不能定义数组


## 2. 限定符
### 2.1 cv-限定符

### 2.2 `constexpr`
**作用**：`constexpr`说明符声明可以在编译时求得函数或变量的值
> 1. 将变量声明为`constexpr`类型，可以让编译器验证变量值是否为常量表达式（编译过程就能得到结果的表达式），必须用常量表达式初始化。
> 2. 普通函数不能作为`constexpr`变量的初始值，但是可以通过定义`constexpr`函数（足够简单）来初始化`constexpr`变量
> 3. constexpr int *p = nullptr; // p是常量指针（顶层const,和const定义的不同）
### 2.3 `constexpr`函数
`constexpr`函数可以在编译时求值，从而可以用`constexpr`函数来初始化constexpr变量
```cpp
constexpr int Fac(int n){
    return (n>1)? n*Fac(n-1):1;
} 
constexpr int kf9 = Fac(9); //必须在编译时求值
```

> `constexpr`函数必须是一个==纯函数==：必须包含一条独立的return语句(return 常量表达式)，不能有==循环==、==条件判断==、==局部变量==、不能有==副作用==(修改变量的值)，允许递归和条件表达式
```cpp
int kGlob;
constexpr void Bad1(int a){ //错误：函数类型不能是void，必须有返回值
    kGlob = a; // 错误：不能有副作用（修改变量的值）
}
constexpr int Bad2(int a){
    if(a>0)
        return a; // 错误：不能有if语句
    else
        return -a;
}
```

## 3. 属性
`[[...]]`被称为属性，可以置于C++语法的任何位置，
### `[[noreturn]]`
**作用**：`[[noreturn]]`放在函数声明开始位置表示不希望任何返回结果。

```cpp
[[noreturn]] void exit(int); //exit永远不会返回任何结果
```
### `using`
> 1. `using`可以用于`namespace`和`namespace`中的成员
> 2. `using`可以用于类型别名和模板别名
> 3. [`using`用于类的成员中](..\3.类与对象\3.成员类型关键词.md)，可以在派生类中指定使用基类的某个成员(即使该成员为`private`/`protected`，包括基类的构造函数)

### `noexcept`
**作用**：表明一个函数不会抛出异常
```cpp
void swap(int, int) noexcept{};
// 也可以加上判断
void swap(int, int) noexcept(if a>b){};
```

### `decltype`

### `sizeof()`
**作用**：返回类型或其对象在内存中所占的字节数
`sizeof()`是一个占位符，其值在编译时期就已经确定