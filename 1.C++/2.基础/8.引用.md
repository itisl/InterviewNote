## 引用Reference
**作用**：引用相当于变量的别名，可以像指针一样传递地址的同时，和变量一样使用。一般引用不用于声明变量，而用于函数传递参数和返回类型（左值引用），可以和指针一样提高程序效率的同时，比指针安全且形式更加优美。

**规则**：
1. 用法
    ```cpp
    // 引用不会生成中间变量传递值，而是传递地址，但是用法和普通变量一样，形式上比指针更加优美直观
    int sum(const int& a,const int& b){
      return a + b;
    }
    cout << sum(1 + 2) << endl; // const引用可以绑定到右值
    ```
2. 引用**仅在**定义时需要`&`，对引用做计算，相当于对变量做计算
3. 引用必须被初始化，初始化类型必须和引用变量相同（**多态除外**），引用初始化后，不能再引用其他变量
4. 可以用引用初始化另一个引用，相当于多个别名
5. 引用本身不是对象，不存在[`void`的引用，引用的引用，指向引用的指针、引用数组]
6. 常引用(如函数参数中`const int&`)可以绑定到临时量(右值)，如上文代码，详见[`const`与引用](./10.const详解.md)
7. 引用作为返回类型时，可以作为左值被赋值，但是不能绑定临时对象（常引用也不能，需要返回临时对象使用值传递返回类型）
    ```cpp
    int n = 0;
    int& get_num(int &n){
        cout << n << endl;
        int n_temp = 0;
        return n;//返回不需要&
        //return n_temp; //Error引用不能绑定到临时对象
    };
    get_num(n) = 3; //n = 3
    ```

### 右值引用`&&`(C++11)
**作用**：引用对象为临时对象(函数返回值，未命名的自由空间等)，判断对象为临时对象后，可以用廉价的移动操作代替拷贝操作。右值引用可以延长临时对象的生存期到该右值引用消亡
不可返回局部数据的引用
> - 右值引用可用于为临时对象延长生存期
> - 当函数同时具有右值引用和左值引用的重载时，右值引用重载绑定到右值（包含纯右值和亡值），而左值引用重载绑定到左值
```cpp
T&& rr = 1;
T&& rr = a + b;
```



### 指针与引用
#### 指针与引用的区别


1. 引用的底层实现是指向不可更改的指针，但是从语言层面来讲引用和指针是完全不同的东西
   - 从汇编代码角度分析，引用和指针的汇编代码相同，且都调用了`lea`指令对地址操作
   - 将`int&`放在结构体中，结构体大小与指针一样有8字节(x64系统)，`int`为4字节
2. 可以用`=`, `+=`, `-=`, `++`, `--`改变指针变量的值，引用指向不可更改
3. 指针可以为`nullptr`或野指针，引用必须初始化
4. 引用会有类型检查，是类型安全的


#### 指针的引用
离变量名最近的符号是变量的类型（引用），其余部分确定引用的类型（从右往左阅读）
```cpp
int*& p_ref = p; 
```

#### 数组的引用
可以有数组的引用，但不能有引用数组（数组元素全为引用）
```cpp
int arr[3]{1,2,3};
int (&arr_ref)[3] = arr;
int* const &arr_ref2 = arr; //引用指向一个指针常量(顶层const)，即指向不可更改的指针，等价于数组
```