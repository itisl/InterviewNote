# 1. `const`
**作用**：`const`用于告诉编译器，`const`修饰的变量不会在代码中显式修改，如果代码会修改就报错(`const`不能保证变量在内存中的值不被修改)
`const`修饰的是其右边的内容
## 1.1 `const`与指针
- 底层`const`常量指针：`p`是变量（指向另一个变量），但是`*p`是常量，不能通过`*p`间接修改变量
- 顶层`const`指针常量：`p`是常量，`*p`是变量，指针的指向不可修改，但是*p可以间接改变变量
> 底层`const`常量指针用于函数参数时和引用[规则](#jump1)相同
```cpp
// 底层const，p是变量（指向另一个变量），但是*p是常量(不能通过*p改变变量)。下面两种等价
const int* p1 = &i;
int const* p1 = &i;
p1 = &j; //正确 
*p1 = 0; //错误 

// 顶层const，p是常量，*p是变量
int* const p2 = &i;
p2 = &j; //错误
*p2 = 0; //正确

// p和*p都是常量，下面两种等价
const int* const p3 = &i;
int const* const p3 = &i;
```
## 1.2 `const`与引用
**作用**：防止通过引用修改变量，常用于通过引用传递函数实参同时防止修改实参，或传入临时量和`const`常量（`const`常量无法使用非`const`形参的函数）
**规则**：
1. `const`必须在`&`符号的左边
    ```cpp
    const int& r = a;
    ```
2. `const`引用可以绑定临时对象（常量、表达式、函数实参），不可绑定函数返回值（返回值虽然是临时对象，但是在函数内已经构造，不能用于初始化）
3. `const`引用可以引用**不同类型的数据**，此时会**产生临时变量**，引用**指向的不是初始化时的对象**（指针不能指向不同类型）
4. `const`引用作为函数参数时：<span id="jump1"></span>
  - 可以同时接受`const`实参和非`const`实参（非`const`引用只能接受非`const`实参）
  - 可以跟非`const`引用构成重载


## 1.3 `const`与函数
### 1.3.1 `const`修饰函数的参数

`const`用作函数参数，可以与不用`const`的函数构成重载

### `const`修饰函数的返回值
- 值传递/引用传递方式：不用加`const`修饰，没有意义
- 指针传递：必须用底层`const`指针接收

### 1.4 `const`成员函数
**作用**：`const`对象可以调用`const`成员函数，而不能调用非`const`修饰的函数
**规则**：
  - 可以访问类中所有成员变量，但是不能修改除**静态成员**以外的变量
  - 在定义和声明的时候都要使用`const`
  - `static`成员函数不能使用`const`
  - 只能调用`const`或`static`成员函数
  - `const`成员函数可以和非`const`构成重载，非`const`对象优先调用相对应类型的函数
```cpp
void A::func() const; //
```

## 2. `constexpr`
**作用**：`constexpr`修饰的变量/函数，会在编译期就确定表达式的值，和`const`不同，该值不会在程序运行期间被更改。根据这个特征可以在编译时求值，虽然会增加编译时间，但是会加快执行效率。
- 修饰函数可以在编译期确定值，代替模板元编程