
## 列表初始化

**说明**：在C++11之前，初始化可能发生在`()`, `{}`或者`=`上，C++11标准提供了一个**统一的初始化方法**，使用`{}`列表初始化

**规则**：
1. 用法：
    ```cpp
    int arr[] {1, 2, 3}; // 初始化一个数组
    vector<int> v{4, 5, 6}; // 初始化一个容器
    int* p = new int[3]{}; //堆上初始化{0,0,0}
    complex<double> c{1.0, 2.0}; // 调用构造函数 ==complex<double> c(1.0, 2.0)
    ```
2. 如果不指定初始值`{}`，编译器将变量和对象成员变量都设为`0`，<u>除非对象的类有自定义构造函数</u>
3. 使用列表初始化能避免函数声明`int i();`和无参数初始化`int i{};`的混淆
4. 列表初始化避免和`auto`结合使用，除非目的就是为了得到一个`initializer_list<T>`
5. 如果初始化的对象本身有一个接受`initializer_list<T>`的构造函数(如`vector`)，那么整个`initializer_list<T>`将作为参数传入，如果要使用其他的构造函数，应该使用`()`
   ```cpp
   vector<int> v1{5, 1}; // {5,1}
   vector<int> v2(5, 1); // {1,1,1,1,1}
   ```
6. 使用列表初始化，可以避免发生窄化转换，如果没有参数，还会初始化为`0`(指针为`nullptr`)
   ```cpp
   int i = 3.14;  // 会发生窄化转换，丢失0.14
   int i = {3.14};  // 编译器不通过，或者warning
   int* p; // 未定义的值
   int* q{};  // 初始化为nullptr
   ```

**实现**：编译器将`{t1, t2, ..., tn}`当做`initializer_list<T>`，关联到一个`array<T, n>`(类中包含`array`)，编译器将`array`内的元素逐一分解传给函数(如构造函数)

不指定参数的`()` `{}`自动初始化，编译器会调用`memset`初始化为`0`

堆空间初始化

将较大数据结构内存清零较快的方法
void *memset(void *str, int c, size_t n)
复制字节 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字节(按字节赋值)。
void *memcpy(void *dest, const void *src, size_t n)
从 src 复制 n 个字符到 dest

## 匿名变量（临时对象）
没有变量名、没有被指针指向的对象，用完后马上销毁
匿名对象用作函数参数时，会直接成为形参的局部变量