## 1. 作用域
**说明**：作用域是指一个标识符能独立、合法出现的区域
**规则**：
1. 一般而言，使用`{}`包围的区域是一个独立的作用域
2. 作用域在栈中申请的内存，随着离开作用域回收，因此作用域中局部变量只能在当前作用域使用
3. 在同一作用域不允许定义同名变量，同名函数则



### 1.1 命名空间`namespace`
**作用**：命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突

**规则**：
1. 新增命名空间：
  ```cpp
  namespace myspace{
    // 该名字空间下的成员和函数
    ...
  }
  ```
2. 使用命名空间的成员
  - 位于相同的作用域中，无须特殊符号可以访问
  - 名字空间外访问需要域解析符`myspace::func();`
3. 存在默认的全局命名空间，所有命名空间嵌套在里面，指定默认命名空间使用`::func();`
4. 命名空间不影响内存布局，命名空间在全局的，其中变量都是全局变量
5. 同一命名空间可以在多个位置和文件共同实现，例如`std`在多个文件中同时定义
6. `namespace`作用域可以定义类、函数、变量，但类和函数内部不能声明`namespace`
7. 在一个`namespace`可以自由访问另一个`namespace`的成员
8. `namespace`内部可以嵌套另一个`namespace`，使用`A::B::fun();`
9. 可以为命名空间长名起一个别名：
    ```cpp
    namespace Glib = Graph_lib;
    ```


#### 1.1.1 `using namespace`
**作用**： `using`声明可以使一个`namespace`的成员在当前作用域下使用，不必使用域解析符`::`
```cpp
 using namespace std;
 {
    cout << "cout可以不适用std::cout";
 } // namespace std
```
tips：这样做相当于取消了名字空间的定义，使发生名称冲突的机会增多，可以单独为某个函数设置`using std::cout;`

## 2. 生命期
