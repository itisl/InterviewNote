
# 1. 数组


# 2. 指针
**概念**：指针是一个变量，其值为另一个变量的内存地址
#### 指针类型
#### 指针指向的类型
> 1. 指针的大小是固定的，在32为系统中为4个字节，64位系统中为8个字节
> 2. 指针的类型决定了指针运算的内存偏移量(包括`*`, `+`, `-`, `++`, `--`)
> 3. 指针的类型必须与所指对象的类型一致。两个例外：
>    1. 可以用指向常量的指针指向非常量对象
>       ```cpp
>       int n = 0;
>       const int *p = &n;//n的值可以改变，但是不能通过指针*p修改
>       ```
>    2. 类的多态
#### 空指针`nullptr`与`NULL`和`0`
`nullptr`是C++11标准的关键字，指针指向`nullptr`代表指针为空
```cpp
void f(int);
void f(void*);
f(0); // 调用f(int)
f(NULL); // 实际调用f(int)，与目标调用不符
f(nullptr); // 调用f(void*)
```
### 2.1 指针与数组
### 2.2 指针与`const`
#### 顶层`const`：常量指针
```cpp
int *const p = &n; //p不能改变，*p和n可以改变
```
#### 底层`const`：指向常量的指针
```cpp
const int *p = &n; //p和n可以改变，但是不能通过*p改变n
int const *p = &n; //意义相同
```



# 3. 引用
**作用**：引用是已存在对象的别名，通常不用于声明变量，而用于参数类型(parameters type)和返回类型(return type)的描述
> **指针与引用的关系与区别**
> ![指针与引用](https://i.loli.net/2020/04/07/31cZgtMdOSzXquk.png)
> 
> 1. 引用的底层实现是常量指针，但是从语言层面来讲引用和指针是完全不同的东西
> 2. 可以用`=`, `+=`, `-=`, `++`, `--`改变指针变量的值(内置类型的运算操作不支持重载)，引用永远对应同一个对象，不可变
> 3. 指针可以为空，引用不能(指针是一个实体，引用是一个别名)
> 4. 引用会有类型检查，是类型安全的
### 3.1 左值引用`&`
> 1. 引用必须被初始化为指代一个有效的对象或函数，引用被初始化后，就不能再代表其他对象
> 2. 引用在定义时需要添加`&`，在使用时不能添加`&`。`&`表示取地址。 
> 3. 使用引用/指针作为函数参数或返回值，需要的内存较小，可以提高程序的效率。
> 4. 如果不希望通过引用来修改原始的数据，那么可以在定义时用`const`限制
> 5. 引用本身不是对象，不存在 void 的引用，也不存在引用的引用不能定义引用
> 6. 常量左值引用(如函数参数中`const int&`)可以绑定到临时量(右值)
```cpp
int &name = data;
```


#### 左值引用作为函数参数
引用传参可以传地址，形式上比指针更加优美直观
```cpp
void swap(int& a,int& b){
    int temp = a;
    a = b;
    b = temp;
}
```
#### 左值引用作为函数返回值
注意：不可返回局部数据的引用
```cpp
int& plus(int &n){
    n += 10;
    return n;//不需要&
};
```
#### 指针的引用
离变量名最近的符号是变量的类型（引用），其余部分确定引用的类型（从右往左阅读）
```cpp
int*& pnum = p; 
```
### 3.2 右值引用`&&`
**作用**：引用对象为临时对象(函数返回值，未命名的自由空间等)，判断对象为临时对象后，可以用廉价的移动操作代替拷贝操作
> - 右值引用可用于为临时对象延长生存期
> - 当函数同时具有右值引用和左值引用的重载时，右值引用重载绑定到右值（包含纯右值和亡值），而左值引用重载绑定到左值
```cpp
T&& rr = 1;
T&& rr = a + b;
```
> **左值引用与右值引用的转换**
> - 将左值强制转换为右值
>   ```cpp
>   // 等价于static_cast<T&&>()
>   std::move()
>   ```
> - 将右值转换成左值
>   ```cpp
>   // 等价于static_cast<T&>()
>   std::forward()
>   ```