> 每个表达式恰属于三种基本值类别之一：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue)

## 左值
**性质**：
1. 可以通过左值到右值、数组到指针或函数到指针隐式转换转换成纯右值
2. 可以是多态的：其所标识的对象的动态类型不必是该表达式的静态类型
3. 可以由内建的取址运算符取左值的地址
4. 可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数
5. 左值可用于初始化左值引用

以下均为左值表达式：
- 变量、函数、模板形参对象 (C++20 起)或数据成员，不论其类型，即使变量的类型是右值引用，由其**名字**构成的表达式仍是左值表达式
- 常用
- **字符串常量**，例如 "Hello, world!"；
- 转换为左值引用类型的**转型表达式**，例如 `static_cast<int&>(x)`
- 返回类型是到**函数的右值引用**的**函数调用表达式**或重载的**运算符表达式**
- 转换为**函数的右值引用**类型的转型表达式，如 `static_cast<void (&&)(int)>(x)`

### 泛左值
泛左值表达式包括左值、**亡值**。
亡值：
- 返回类型为对象的右值引用的函数调用或重载运算符表达式，例如 `std::move(x)`
- `a[n]`，内建的下标表达式，其操作数之一是数组右值
- `a.m`，对象成员表达式，其中 a 是右值且 m 是非引用类型的非静态数据成员
- `a.*mp`，对象的成员指针表达式，其中 a 为右值且 mp 为数据成员指针
- 转换为对象的右值引用类型的转型表达式，例如 `static_cast<char&&>(x)`

性质：
- 泛左值可以通过左值到右值、数组到指针或函数到指针隐式转换转换成纯右值。
- 泛左值可以是多态的：其所标识的对象的动态类型不必是该表达式的静态类型。
- 泛左值可以具有不完整类型，只要表达式中容许。


## 右值
右值分为纯右值和亡值（亡值也是泛左值）
**性质**：
1. 右值不能由内建的取址运算符取地址
2. 右值不能用作内建赋值运算符及内建复合赋值运算符的左操作数
3. 右值可以用于初始化 `const `左值引用（`const&`）
4. 右值可以用于初始化右值引用，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾
5. 当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 `const`左值引用的形参时，右值将被绑定到右值引用的重载之上（右值引用优先于`const`左值引用绑定）

以下均为右值表达式：
- 字面量（字符串字面量之外的），例如 `5`、`true` 或 `nullptr`
- 返回临时对象的操作符
- 转换为非引用类型的转型表达式，例如 `static_cast<double>(x)`、`std::string{}` 或 `(int)42`
- `this` 指针
- 枚举项
- 非类型模板形参，除非其类型为类或 (C++20 起)左值引用类型
- `lambda` 表达式，例如 `[](int x){ return x * x; }`
## 移动语义与完美转发
### `std::move`
**作用**：`std::move()`将左值强制转换为右值引用，等价于`static_cast<T&&>()`  `std::move()`实现到右值的无条件转换

### `std::forward<T>()`
**作用**：完美转发，使参数在传递过程中保持其值的属性。即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。`std::forward<T>()`实现到右值的有条件转换
```cpp
template<typename T>
void temp(T r){
  test(r);
  // test(std::forward<T>(r))
}
temp<int>(5);
```
上述代码，传入的字面量`5`是右值，在函数`temp()`中形参却是左值，当我们希望调用`temp(T&&)`时就会出现问题，此时可以使用`std::forward<T>()`完美转发


### 引用折叠
函数的参数绑定以及类型推导时，遵从任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。
```cpp
& &   --> &
& &&  --> &
&& &  --> &
&& && --> &&
```


- 非`const`左值引用只能绑定到非`const`左值；
- `const`左值引用可绑定到`const`左值、非`const`左值、`const`右值、非`const`右值；
- 非`const`右值引用只能绑定到非`const`右值，但不适用于函数模板的形参；
- `const`右值引用可绑定到`const`右值和非`const`右值，它没有现实意义（毕竟右值引用的初衷在于移动语义，而移动就意味着修改）；