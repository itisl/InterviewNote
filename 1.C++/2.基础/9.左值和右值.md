# 左值和右值
> 每个表达式恰属于三种基本值类别之一：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue)

## 1. 左值
**性质**：
1. 可以通过左值到右值、数组到指针或函数到指针隐式转换转换成纯右值
2. 可以是多态的：其所标识的对象的动态类型不必是该表达式的静态类型
3. 可以由内建的取址运算符取左值的地址
4. 可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数
5. 左值可用于初始化左值引用

以下均为左值表达式：
- 变量、函数、模板形参对象 (C++20 起)或数据成员，不论其类型，即使变量的类型是右值引用，由其**名字**构成的表达式仍是左值表达式
- 常用
- **字符串常量**，例如 "Hello, world!"；
- 转换为左值引用类型的**转型表达式**，例如 `static_cast<int&>(x)`
- 返回类型是到**函数的右值引用**的**函数调用表达式**或重载的**运算符表达式**
- 转换为**函数的右值引用**类型的转型表达式，如 `static_cast<void (&&)(int)>(x)`

### 1.1 泛左值
泛左值表达式包括左值、**亡值**。
亡值：
- 返回类型为对象的右值引用的函数调用或重载运算符表达式，例如 `std::move(x)`
- `a[n]`，内建的下标表达式，其操作数之一是数组右值
- `a.m`，对象成员表达式，其中 a 是右值且 m 是非引用类型的非静态数据成员
- `a.*mp`，对象的成员指针表达式，其中 a 为右值且 mp 为数据成员指针
- 转换为对象的右值引用类型的转型表达式，例如 `static_cast<char&&>(x)`

性质：
- 泛左值可以通过左值到右值、数组到指针或函数到指针隐式转换转换成纯右值。
- 泛左值可以是多态的：其所标识的对象的动态类型不必是该表达式的静态类型。

**非右值**：左值、右值引用、`const`右值引用、`const`左值引用

## 2. 右值
右值分为纯右值和亡值（亡值也是泛左值）
**性质**：
1. 右值不能由内建的取址运算符取地址
2. 右值不能用作内建赋值运算符及内建复合赋值运算符的左操作数
3. 右值可以用于初始化 `const `左值引用（`const&`）
4. 右值可以用于初始化右值引用，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾
5. 当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 `const`左值引用的形参时，右值将被绑定到右值引用的重载之上（右值引用优先于`const`左值引用绑定）

以下均为右值表达式：
- 字面量（字符串字面量之外的），例如 `5`、`true` 或 `nullptr`
- 返回临时对象的操作符
- 转换为非引用类型的转型表达式，例如 `static_cast<double>(x)`、`std::string{}` 或 `(int)42`
- `this` 指针
- 枚举项
- 非类型模板形参，除非其类型为类或 (C++20 起)左值引用类型
- `lambda` 表达式，例如 `[](int x){ return x * x; }`

## 3. 引用的传递
### 3.1 引用类型推导
**只有右值引用推导到右值时，结果才为右值引用**
| 引用传递  | 结果 |
| --------- | ---- |
| `&` `&`   | `&`  |
| `&` `&& ` | `&`  |
| `&&` `&`  | `&`  |
| `&&` `&&` | `&&` |

```cpp
int a1 = 1;
int&& a2 = 1;
auto&& b1 = a1; // b1推导为左值引用
auto&& b2 = 2; // 右值引用
auto&& b3 = a2; // 右值引用
```

### 3.2 在函数参数中传递 
**说明**：右值引用具名化后，使用`=`传递时(包括在函数参数中绑定、传递)，会被视为左值引用，此时左值、右值语义可能会发生变化，可能导致不能调用正确参数类型的函数。


- 非`const`左值引用只能绑定到非`const`左值；
- `const`左值引用可绑定到`const`左值、非`const`左值、`const`右值、非`const`右值；
- 非`const`右值引用只能绑定到非`const`右值，但不适用于函数模板的形参；
- `const`右值引用可绑定到`const`右值和非`const`右值，它没有现实意义（毕竟右值引用的初衷在于移动语义，而移动就意味着修改）；
## 4. 转移语义与完美转发
### `std::move`转移
**作用**：`std::move()`将左值强制转换为右值引用，等价于`static_cast<T&&>()`  `std::move()`实现到右值的无条件转换


### `std::forward<T>()`完美转发
**作用**：保持参数传递过程中的右值语义。即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。
**注意**：`std::forward<T>()`的实现基于模板参数的特化，**在非模板函数中不会生效**，此时如果需要传递右值应该使用`std::move`
> 和std::move()区别：
  - `std::forward<T>()`实现到右值的有条件转换，在模板中不确定实际传递的值时使用完美转发，可以使当前模板函数同时适应左值和右值参数
  - `std::move()`是到右值的强制转换，如果事先确定要使用移动语义(例如调用移动构造时)可以使用
```cpp
template<typename T>
void temp(T&& r){
  // test(r); 
  // forward根据参数T&&，将T定义为T&&的别名，将r强制转换为T类型(也就是T&&)
  // 如果本来是左值，T类型不是T&&别名，保持了左值
  test(std::forward<T>(r)); 
}
temp(5);
```
上述代码，传入的字面量`5`是右值，在函数`temp()`中形参传递为左值引用，当我们希望调用`temp(T&&)`时就会出现问题，此时可以使用`std::forward<T>()`完美转发


