# 智能指针
**作用**：智能指针自身被销毁时，会自动销毁指针指向的对象。能有效解决内存泄漏问题。

**规则**：
1. 智能指针**不能指向栈空间对象**，否则会free两次
2. 指向数组时，泛型应该使用数组`shared_ptr<int[]> ptr = new int[]{1,2};`


## 1. `shared_ptr`

多个`shared_ptr`可以指向同一个对象，没有智能指针指向对象时才会销毁对象
> [智能指针的实现](../4.函数/7.智能指针的实现.md)

1. 智能指针的**初始化**和**普通对象**一样，泛型为指向对象类型，接收参数为堆空间地址；**使用**和**指针**一样，使用`->`和`*`
2. `shared_ptr`是强引用指针，只要存在`shared_ptr`指向对象，对象便不会被析构
3. 可以通过已存在的智能指针初始化一个新的智能指针（拷贝构造或拷贝赋值）
4. 由引用计数实现，当计数为0时才销毁指向的对象
5. 可以理解为包含两个指针的结构：一个指向对象，一个指向计数器
![shared_ptr](https://i.loli.net/2020/04/12/OahEsZdb4iQDztH.png)

`shared_ptr`的缺点：循环链表可能资源泄漏、资源占用更高、多线程防止计数的数据竞争代价很高

### `shared_ptr`的循环引用
当存在循环链表（循环链表内部也使用`shared_ptr`）时，指向链表的外部`shared_ptr`消亡时，由于此时引用计数为**2**，析构函数不会`delete`堆空间链表对象，造成内存泄漏
![未命名绘图](https://i.loli.net/2021/03/20/dmvZjDuoxcqlOJ1.png)


## 2. `weak_ptr`

`weak_ptr`是弱引用指针对象，不会增加`shared_ptr`的引用计数




### 打破循环引用

![未命名绘图2](https://i.loli.net/2021/03/20/k5V8tm1q9yivFaG.png)

## 3. `unique_ptr`
`unique_ptr`也是强引用，但

1. 同一时间只能有一个`unique_ptr`指向对象
2. 拥有一个对象，保存一个指针，并负责用释放器销毁对象
3. 不能拷贝，但可以移交所有权`p2 = std::move(p1);`
![unique_ptr](https://i.loli.net/2020/04/12/5tXm4eLuf8GYB6a.png)

## 4. `auto_ptr`
自C++11开始已经**弃用**