# 原子操作
**作用**：在多线程操作中，使用原子变量之后就不需要再使用互斥量来保护该变量了，用起来更简洁

> 原子锁：使用CPU指令级别实现，不会陷入内核态，但是循环CAS会消耗时间，适用于低并发、单个数据类型的数据安全；
> 非阻塞互斥量：会陷入内核，由内核判断是否可以获取锁，其消耗主要是内核态与用户态切换开销，适用于高并发、代码块的类型安全

```cpp
#include <atomic>
template< class T >
struct atomic;
// 使用方法，m_value为临界区变量
std::atoimc_int m_value = 0; // atoimc_int = atomic<int>
```



在 C++20 版本中添加了新的功能函数，可以通过原子类型来阻塞线程，和条件变量中的等待 / 通知函数是一样的。

公共成员函数 | 说明
-------|---
`wait()` | 阻塞线程直至被提醒且原子值更改(C++20)
`notify_one()` | 通知（唤醒）至少一个在原子对象上阻塞的线程(C++20)
`notify_all()` | 通知（唤醒）所有在原子对象上阻塞的线程(C++20)

