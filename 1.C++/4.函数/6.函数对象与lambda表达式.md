
**函数对象**类型是可用在函数调用运算符左侧的对象的类型

## 函数名和函数指针
**函数指针**：不同于函数或函数的引用，函数指针是对象，从而能存储于数组、被复制、被赋值等。
```cpp
void f(int);
void (*p1)(int) = &f;
void (*p2)(int) = f; // 与 &f 相同
```

### 仿函数(functor)
**作用**：需要成员变量帮助完成功能或保存运行时的结果，而不借助函数参数和返回值。仿函数本质上是一个可以含有成员的函数
**本质**：就是一个重载了`operator()`操作符的类，概念上是函数的功能。
> 1. 函数对象可以将附加数据保存在成员变量中，从而实现携带附加数据，而函数指针不行。
> 2. 可以联合调用类内其他函数

**使用**：创建了对象后（栈上或临时对象），跟普通函数的使用一样

```cpp
struct Output{
    void operator()(int __n){
        cout << __n << " ";
    }
};
int main(){
    vector<int> v(5,100);//初始化vector，5个元素，元素值均为100
    //依次输出vector的元素，这里传入的不是函数指针，而是一个类
    for_each(v.begin(),v.end(),Output{}; //通过临时对象传入仿函数
return 0;
}

// STL中for_each()函数可能实现：
template<class InputIt, class UnaryFunction>
UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f)
{
    for (; first != last; ++first) {
        f(*first);
    }
    return f; // C++11 起隐式移动
}
```

### `lambda`表达式
**作用**：
> 1. 函数指针和仿函数较复杂，`lambda`表达式简洁，不需要实现类
> 2. 匿名内包的形式不会产生多余的函数名
> 3. 代码表达能力强，提高代码清晰度

**规则**：
1. 形式
    `[&a, b](int i) mutable{}noexcept -> int`，最简单形式为`[]{}`
   - `[]`捕获列表，指明作用域中匿名函数可以使用的变量，以`&`为前缀的局部名字通过引用捕获，默认以值捕获`=`。
     - `[&]`捕获列表可以出现`this`， 不在列表中的变量隐式引用捕获
     - `[=]`捕获列表不可以出现`this`， 不在列表中的变量隐式值捕获
    - `()`参数列表，`mutable`，`noexcept`，`->`尾置类型都为可选，和函数用法一样
2. 值捕获无法修改捕获列表的变量(`const`)，可以使用引用捕获修改
3. 定义值捕获匿名函数时，相当于捕获`const`常量，后面变量的值更改对函数没有影响，使用`mutable`相当于使用了局部变量，对外部变量没有影响
4. 可以将`lambda`表达式赋值和函数指针，相当于定义函数`auto func = [&](){...};`
5. `lambda`用在成员函数，可以引用捕获把`this`添加到捕获列表，`[this]`通过指针访问，而非拷贝。`[this]`和`[=]`不兼容，所以在多线程中可能产生竞争。

#### 泛型`lambda`(C++14)
`lambda`表达式可以像模板函数一样实现泛型，根据传入的参数自动推导类型

```cpp
auto add = [](auto x, auto y) { return x + y; };
int x = add(2, 3);   // 5
double y = add(2.5, 3.5);  // 6.0
```