# 泛型和模板
**作用**：将类型参数化，以完成代码复用的目的
不同数据类型以及返回值的函数（如`int`和`double`），内在逻辑和代码可能是一样的，但是需要重载几种类型不同的函数，将会浪费很多时间在代码编写，C++提供泛型来完成这一功能的代码复用
> **提醒:**
> 1. 模板对应的参数在没有使用时，是不会实例化的
> 2. 分离编译(`.h`文件和`.cpp`文件将声明和实现分离)时，编译器编译某个`.cpp`文件不知道其他`.cpp`文件，导致需要的模板类型不会实例化，引起链接错误
> 3. 解决方式：**将模板的声明和实现放在`.hpp`文件中**


## 函数模板(Function Template)
可以将函数的返回类型以及形参类型参数化
**规则**：
1. 用法：

    ```cpp
    template <typename T1, typename T2>//多参数模板头
    void func(const T1 &a, onst T2 &b){};
    ```
2. 函数声明和实现分开时，都要加上模板头，使用`typename`/`class`没有区别
3. 类型参数`typename`可以有多个，它们之间以`,`分隔。类型参数列表以`<>`包围，而形参列表以`()`包围
4. 使用时需要在函数旁边指定类型，如`func<double>();`，否则编译器会根据给定的数据推导数据类型（注意类模板不可以）
    ```cpp
    func(1, 2.0); //自动推导为func<int,double>()
    ```
5. 类模板和函数模板都支持默认参数，C++11在之前只支持类模板默认参数
6. 根据实际调用参数类型的不同，编译器实质上是生成了不同的重载函数。例如，用五个不同参数实例化一个函数模板，相当于新定义了五个重载函数，没有使用的类型不会实例化


## 类模板

**作用**：和函数模板类似，可以将数据的类型泛化。声明了类模板后，就可以将类型参数用于类的成员函数和成员变量。

**规则**：
1. 用法：
    ```cpp
    template<typename T>
    class Point{
    public:
        Point(T x,T y):x_(x), y_(y){}
        void get_point();
    private:
        T x_;
        T y_;
    };
    ```
2. 类外实现成员函数时，如果函数里面使用了模板类型`T`，仍然需要带上模板头
    ```cpp
    template<typename T>
    void Point<T>::get_point(){}
    ```
3. 类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型
4. 在类外定义成员函数时，`template`后面的类型参数要和类声明时的一致，可以使用`auto`
5. 和函数模板一样，模板类被实例化时实际产生一种新的类型，不同的参数实例化出不同的类型。


## 成员模板
**成员模板**：类(普通类或模板类)可以包含本身是模板的成员函数。
> 成员模板不能是`virtual`函数。
### 普通类的成员模板
与类模板的区别是，可以不用创建对象时指定模板参数
```cpp
//完成一个删除器的仿函数，代替delete
class Deleter{
public:
    Deleter(){};
    //重载operator(), 构成函数对象
    template <class T>
    void operator()(T* p) const{
        deleter p;
    }
}
```
### 类模板的成员模板
**作用**：模板拷贝构造函数可以进行不同参数类模板之间的类型转换，也可以在构造函数中用来作向上转型(基类智能指针指向派生类对象)
在外部定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表
```cpp
template<class T>
struct Point{
    T x_;
    T y_;
    Point(T x,T y):x_(x), y_(y){}
    template<class U>
    Point(const Point<U>& p): x_(static_cast<T>(p.x_)), y_(static_cast<T>(p.y_)){}
}
// 可以用double模板的类拷贝构造int模板的类
Point<double> d1{1.0, 2.0};
Point<int> d2(d1);

template<class T>
template<class U>
Point<T>::Point(){...}
```

