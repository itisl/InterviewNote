[TOC]
---

## 1. 虚函数 
**虚函数**是可在派生类中覆盖其行为的成员函数。与非虚函数相反，即使没有关于该类实际类型的编译时信息，仍然保留被覆盖的行为。==虚函数的唯一用途就是构成运行时的多态。==
> [重载和覆盖的区别](../4.函数/3.函数重载.md)

> ```cpp
> 声明符 虚说明符序列(可选) 纯说明符(可选)
> ```
> 虚说明符序列，必须是 `override`、`final`、`final override` 或 `override final`之一
> 1. 非虚(non-`virtual`)函数：不希望派生类重定义(`override`)，普通成员函数
> 2. 虚(`virtual`)函数：希望派生类重新定义，当前类有定义
> 3. 纯虚(pure `virtual`)函数：派生类必须重新定义，而且没有默认定义

### 1.1 普通虚函数
注意：基类的析构函数应该为`virtual`，否则使用基类指针指向子类对象时，会造成只析构基类部分
```cpp
class A{
public:
    virtual ~A();//虚函数的定义
    ...
};
class B:public A{
public:
    virtual ~B();
    ...
};
```
### 1.2 纯虚函数

1. 纯虚函数的声明:
```cpp
virtual type FunName(para_list) = 0; //在结尾加上=0告诉编译器这是纯虚函数
```
只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数
1. 抽象类（Abstract Class）：包含纯虚函数的类成为抽象类。
> 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。纯虚函数没有函数体，因此抽象类无法被实例化(通常没有构造函数)
```cpp
class Line(){
public:
    Line();//默认构造函数
    virtual float area() = 0;//声明这是一个纯虚函数
protected:
    float m_len;
};
class Cube:public Line{
public:
    Cube(float len);
    float area();//纯虚函数在派生类中声明
};
Cube::Cube(float len):Line(len){}
//纯虚函数的定义
float Cube::area(){
    return m_len*m_len;
}
main中：
Line *p = new Cube(5);//纯虚函数可以实现多态
```

> 在抽象基类中不需要或无法实现的功能，可以声明为纯虚函数。纯虚函数为派生类提供了约束，派生类必须完成纯虚函数的功能才能实例化

## 2. 多态
**作用**：基类指针可以使用基类的方法，也可以使用派生类的方法，实现一种接口，就能针对不同子类对象完成不同的功能
> **作用**
> - 派生类的方法，可以被基类的方法或引用变量调用。而有了多态，只需要一个指针`p`就可以调用所有派生类的虚函数，提高可扩充性。
> - 同一个函数可以处理多种不同的情况，定义了统一的接口
> - 指针和引用都可以实现多态，但是引用不如指针灵活
> 对某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数，让基类指针可以访问派生类的成员函数。可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行访问。
> - `public`派生类对象可以被当做基类对象使用，反之不行。基类对象名、指针只能使用从基类继承的成员
>   1. 派生类的对象可以隐含转换为基类对象；
>   2. 派生类的对象可以初始化基类的引用；
>   3. 派生类的指针可以隐含转换为基类的指针

> **虚函数注意事项**：
> 1. 只有类的成员函数才能声明为虚函数。
> 2. 只需要在虚函数的声明处加上`virtual` 键字，函数定义处可以加也可以不加(最好加上，使程序更加清晰)。
> 3. 在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将用基类的虚函数。
> 4. 只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态。
> 5. 静态成员函数不能使虚函数，因为它不受限于某个对象。
> 6. 内联函数不能是虚函数。
> 7.  构造函数不能是虚函数，因为构造函数不能被继承
> 8.  基类的析构函数应该声明为虚函数（防止基类指针只析构基类部分而不析构派生类）

### 构成多态的条件：
 1. 必须存在继承关系；
 2. 继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。
 3. 存在基类的指针，通过该指针调用虚函数。


