## 构造函数
**构造函数作用**：创建对象时自动执行，用于初始化成员变量。名字和类名相同，无返回值：
> 1. 构造函数没有名字且无法被直接调用。它们在发生初始化时调用，且它们按照初始化的规则进行选择；
> 2. 单参数的构造函数应该声明为`explicit`，避免编译器做类型转换；
> 3. 有`constexpr`说明符的构造函数令其类型成为字面类型(LiteralType)

```cpp
class Clock{
public:
    Clock(int hour,int minute,int second);//声明构造函数
    Clock();
    void show();
private:
    int hour_;
    int minute_;
    int second_;
};
```
    

### 1. 默认构造函数：
作用：构造对象时默认调用的构造函数
- 不能定义两个带初始值的默认构造函数（会报错）。程序中已定义构造函数，编译器不再隐含生成，如果希望，可以使用：`A()=default;`
调用没有参数的构造函数可以省略括号：`Clock today;`
`=default` 可以写在声明处也可以写在定义处
### 2. 拷贝构造函数：
**拷贝构造函数作用**：类内成员变量含指针、动态分配的内存时，必须定义拷贝构造函数进行深拷贝，否则可以不定义。
> 1. 类内成员变量含指针、动态分配的内存时，必须定义拷贝构造函数进行深拷贝；
> 2. 拷贝构造函数和拷贝赋值操作`operator=`必须同时给出，见[拷贝与移动](3.拷贝与移动.md)。
> 3. 可以在`private`中加入拷贝构造的声明（不必定义），用来防止默认拷贝。
```cpp
Clock(const Clock &today);//复制构造函数的声明
Clock(const Clock &today)=delete;//指示编译器不生成默认复制构造函数
Clock B = A;   // Clock B(A); 使用拷贝构造函数初始化新对象
```
==**注意：**==
> 1. 拷贝构造函数参数必须是当前类的引用，否则形参会调用拷贝构造函数创建临时对象，陷入死循环；
> 2. 如果不加`const`限制，将不能拷贝`const`修饰的对象

### 3. 移动构造函数：
> 注意：和拷贝构造一样，移动构造函数和移动赋值操作`operator=`必须同时给出。
### 4. 转换构造函数：
转换构造函数还作为用户定义的转换序列中的一部分，在复制初始化中受到考虑
隐式声明的及用户定义的非`explicit`复制构造函数与移动构造函数也是转换构造函数
```cpp
// 加上默认参数，构成单参数构造函数
Fraction(int numerator, int denomirator=1)
:numerator_(numerator), denomirator_(denomirator){ }
// 重载 + 操作符
Fraction operator+(){
    return Fraction(...);
}
// 运算时，会将整数当做一个参数
Fraction f(3, 5);
double d = 4 + f; // 调用构造函数将4转换为F(4,1), 然后调用operator+
```

### 5. 委托构造函数：
使用类的其他构造函数执行初始化过程(两个构造函数功能相似时，可以调用减少代码量)
```cpp
Clock::Clock(int hour,int minute,int second):m_hour(hour),m_minute(minute),m_second(second){};
Clock::Clock():m_hour(0),m_minute(0),m_second(0){};//不使用委托构造函数
Clock::Clock():Clock(0,0,0){};//使用委托构造函数
```
### 6. 派生类的构造函数：
类的构造函数不能被继承（可以用`using`语句继承基类构造函数（只能初始化继承的成员）即使继承了也不能成为派生类的构造函数，==最好不用==）
`using People::People;`
> 在子类的构造函数中调用基类的构造函数。
```cpp
People(std::string name,int age);//基类构造函数声明
Student(std::string name,int age,float score);//派生类构造函数声明
Student::Student(std::string name,int age,float score):
People(name, age), score_(score){
    ... //单继承派生类构造函数的初始化列表
```    
#### 6.1. 派生类构造函数的执行顺序：
1. 调用基类构造函数：顺序按照继承时声明的顺序
2. 初始化列表成员进行初始化，按照在类中定义的顺序，对象成员初始化自动调用所. 的构造函数
3. 执行派生类的构造函数体
派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的
#### 6.2. 基类构造函数的调用规则：
定义派生类构造函数时应指明基类构造函数，否则就调用基类的默认构造函数。如果基类没有默认构造函数（定义了其他构造函数，编译器不生成隐含的默认构造函数），编译失败

## 析构函数
**作用**：用于销毁对象释放内存。
> 1. 一个类只有一个析构函数；
> 2. 析构函数在销毁对象时自动执行，无法显式调用，没有参数和返回值；
> 3. 当类中不存在指针、动态分配内存时，可以不指定析构函数；否则必须指定用来释放掉指针所指向内存，避免内存泄漏
> 4. 使用多态时基类的析构函数必须为`virtual`，否则会造成部分析构而内存泄漏

```cpp
Clock::~Clock(){
    delete[] m_arr; //释放申请的数组的内存
} //析构函数定义
```
### 派生类的析构函数：
- 基类的析构函数也应该为`virtual`
- 如果需要，子类的析构函数另外声明定义
- 类的析构函数也不能被继承，与构造函数不同的是，在子类的析构函数中不用显式地调用父类的析构函数。

> #### 构造和析构的顺序
> 派生类(或复合)对象**构造由内到外**： Derivrd构造函数先调用Base的默认构造函数，然后调用Component的默认构造函数，然后执行自己
> ```cpp
> Derived::Derived(...):Base(), Component(){ ... }
> ```
> 派生类(或复合)对象**析构由外到内**：Derived析构函数先执行自己，然后调用Component的析构函数，然后再调用Base析构函数(顺序相反)
> ```cpp
> Derived::~Derived(...):{ ... ~Component(), ~Base() }
> ```
> ![20191017013441.png](https://raw.githubusercontent.com/itisl/Pic_Bed/master/img/20191017013441.png)
