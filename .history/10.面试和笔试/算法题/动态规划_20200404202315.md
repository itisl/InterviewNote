## 动态规划
**应用**：**最值**问题(具有最优子结构，即子问题拥有最值)

### dp数组的遍历方向
> 遍历的终点是最终存储的结果
![1](https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2F-M3U3aNXgGJVkKZ-TldN%2F-Lz1QbuLPFckafCeuiZ7%2F1.jpg?generation=1585364271429256&alt=media)

> **动态规划的步骤**：
> 1. 定义数组元素的含义
> 2. 找出数组元素之间的关系式(状态转移方程)
> 3. 找出边界初始值


#### [例题1：不同路径](https://leetcode-cn.com/problems/unique-paths/)
> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
> 问总共有多少条不同的路径？
> ![1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

1. dp数组定义：`dp[i][j]`为机器人到达`[i,j]`处的路径个数
2. 机器人可以从上边以及左边到达`[i,j]`处，状态转移方程`dp[i][j] = dp[i-1][j] + dp[i][j-1]`
3. 初始值在左边界和上边界为1，代码如下：
```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0]*n for _ in range(m)]
        for i in range(m):
            dp[i][0] = 1
        for j in range(n):
            dp[0][j] = 1
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]

        return dp[-1][-1]
```


#### [例题2：编辑距离](https://leetcode-cn.com/problems/edit-distance/)
> 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。
> 你可以对一个单词进行如下三种操作：
> 插入一个字符
> 删除一个字符
> 替换一个字符
> ```c
> 示例 1:
> 输入: word1 = "horse", word2 = "ros"
> 输出: 3
> 解释: 
> horse -> rorse (将 'h' 替换为 'r')
> rorse -> rose (删除 'r')
> rose -> ros (删除 'e')
> ```
1. `dp[i][j]`定义为word1的前i个字母到word2的前j个字母的操作数
2. 第`[i,j]`个字母相同时，`dp[i][j] = dp[i-1][j-1]`\(不执行任何操作)，不相同时dp[i-1][j]()

### 动态规划的优化步骤


对于dp矩阵，在计算第三行的值时，第一行的值实际上是没有利用到的，因此dp矩阵可以优化为只保存矩阵的一行，而状态
![1](https://camo.githubusercontent.com/bb04a1f4835fc8735ce1c1f701508eeffe49d8cb/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303139313131333039333335373637302e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c323077587a4d334f5441334e7a6b332c73697a655f31362c636f6c6f725f4646464646462c745f3730)

```py
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [1]*n
        
        for i in range(1, m):
            dp[0] = 1
            for j in range(1, n):
                dp[j] = dp[j] + dp[j-1]

        return dp[-1]
```