[TOC]
---

## `include`


## 宏与预定义常量
### 1. 宏定义`#define`
**宏**：`#define`在预编译时展开，将相对应位置宏定义替换成文本, 其作用域范围从定义位置开始，到其当前所在作用域结束
> 应尽量避免使用宏定义常量，使用宏时要非常谨慎，尽量以内联函数、枚举和常量代替
#### 1.1 简单宏定义
```cpp
#define FOREVER for(;;) //死循环
#define CASE break;case 
```
宏意味着你和编译器看到的代码是不同的。这可能会导致异常行为，尤其因为宏具有全局作用域，应该==避免使用宏定义常量==:

```cpp
#define PI 3.14
```	
#### 1.2 带参数的宏定义
`#define <宏名>(<参数表>) <宏体>`
> 宏体中出现的参数，如果必须使用宏需要注意：
> 1. 尽量用`()`把每个宏参数括起来
> 2. 整个宏体也要使用`()`括起来
> 3. 全局名字一定要使用作用域解析符`::`

```cpp
#define MIN(a, b) (((a)<(b))?(a):(b))
```	

### 2. `const`常量
C++编译器会在编译时为`const`常量分配地址，并提供类型检查和作用域检查

### 3. `enum hack`
**作用**：`#define`进行的是字符串替换，不利于程序调试，而且不容易控制范围。使用`enum hack`可以定义一个枚举常量，而且也不会导致不必要的内存分配。

```cpp
class box{
private:
  enum {volume = 10};
  int things[volume];
};
```

```cpp
// 利用enum hack和模板元实现递归版本的阶乘直接求值
template<unsigned n>
struct Factorial{
	enum {value = n * Factorial<n-1>::value};
};
template<>
struct Factorial<0>{
	enum {value = 1};
};
std::cout<<Factorial<10>::value;

```

> - `enum hack`比较像`#define`而不像`const`，比如对`enum`取址不合法；
> - `enum`和`#define`一样不会导致非必要的内存分配；
> - `enum hack`是模板元编程的一项基本技术，大量的代码在使用
> - `enum`定义的常量，并不是在预编译的时候进行替换，只是在编译的时候，根据标识去常量区获取对应的值

### 4. `constexpr`
// TODO
