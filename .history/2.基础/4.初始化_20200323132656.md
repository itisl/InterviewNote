[TOC]
---
## 统一初始化
**说明**：在C++11之前，初始化可能发生在`()`, `{}`或者`=`上，C++11标准提供了一个共通的初始化方法，使用`{}`列表初始化
> **实现**：编译器将`{t1, t2, ..., tn}`当做`initializer_list<T>`，关联到一个`array<T, n>`(类中包含`array`)，编译器将`array`内的元素逐一分解传给函数(如构造函数)
```cpp
int arr[] {1, 2, 3} // 初始化一个数组
vector<int> v{4, 5, 6} // 初始化一个容器
complex<double> c{1.0, 2.0} // 调用构造函数初始化对象，等价于complex<double> c(1.0, 2.0)
```




> - 使用列表初始化，可以避免发生窄化转换，如果没有参数，还会初始化为`0`(指针为`nullptr`)
>     ```cpp
>     int i = 3.14;  // 会发生窄化转换，丢失0.14
>     int i = {3.14};  // 编译器不通过，或者warning
>     int* p; // 未定义的值
>     int* q{};  // 初始化为nullptr
>     ```
> - 列表初始化避免和`auto`结合使用，除非目的就是为了得到一个`initializer_list<T>`
> - 如果初始化的对象本身有一个接受`initializer_list<T>`的构造函数(如`vector`)，那么整个`initializer_list<T>`将作为参数传入，如果要使用其他的构造函数，应该使用`()`
>     ```cpp
>     vector<int> v1{5, 1}; // {5,1}
>     vector<int> v2(5, 1); // {1,1,1,1,1}
>     cout << v1[0] << endl; // 输出5
>     cout << v2[0] << endl; // 输出1
>     ```
### 类型别名
#### 1. C语言方法`typedef`	
```cpp
typedef int n; //n是int的同义词
typedef n a, *p; //a是int的同义词，p是int*的同义词
```
#### 2. 新标准别名声明`using`
```cpp
using zs = int; //n是int的同义词
```
==注意==类型别名前不能加修饰符：
```cpp
unsigned zs i;  // 错误 
```
### `auto`占位符

#### 1. `auto`与变量
**作用**：自动推导变量的类型，无需显示指定(返回迭代器等类型时手动写太复杂)
> 1. `auto`变量必须在定义时初始化
> 2. `auto`只能使用在局部变量。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远**别使用`{}`初始化`auto`变量**
> 3. 定义在一个`auto`序列的变量必须始终推导成同一类型
>     ```cpp
>     auto a4 = 10, a5 = 20, a6 = 30;//正确
>     auto b4 = 10, b5 = 20.0, b6 = 'a';//错误,没有推导为同一类型
>     ```
> 4. 如果初始化表达式是引用，则自动去除引用语义
> 5. 如果初始化表达式为`const`或`volatile`，则除去`const`/`volatile`语义(`auto`不能自动推导成cv限定符)
> 6. `auto`仅仅是一个占位符，不能使用`sizeof`或`typeid`
> 7. 可以使用`valatile`, `*`(指针类型说明符), `&`(引用类型说明符)，`&&`(右值引用)来修饰`auto`关键字
> 8. `auto`会自动推断出数组和指针类型，因此`auto`与`auto*`作用一致
> 9. **`auto`与`{}`列表**: 如果不希望得到`initializer_list<T>`类型，应该选择`=`而非`{}`
>     `auto x{1};  // 推断为{1}列表`

#### 2.`auto`与函数

> 1. 当不知道函数返回类型，可以用`auto f();`自动推导返回类型；
> 2. 泛型lambda
