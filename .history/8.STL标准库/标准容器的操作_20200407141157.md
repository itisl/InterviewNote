### 标准容器的方法
> `?`表明这些操作有些容器不支持：
> 1. `milti*` 关联容器不提供`[]`或`at()`
> 2. `forward_list`不提供`insert()`/`erase()`/`back()`/`push_back()`/`pop_back()`或`emplace()`，但是提供`*_after`
> 3. `forward_list`不提供`reverse_iterator`/`const_reverse_iterator`/`rbegin()`/`rend()`/`crbegin()`/`crend()`及`size()`
> 4. `unordered_*` 关联容器不提供`<`/`<=`/`>`/`>=`



### 构造与赋值
#### 构造与初始化
```cpp
C c{};          //默认构造一个空容器
C c{a};         //使用分配器a默认构造c
C c(n);         //c初始化为n个元素，值为value_type{}；关联容器不适用
C c(n, x);      //c初始化为x的n个拷贝;关联容器不适用
C c(n, x, a);   //c初始化为x的n个拷贝;使用分配器a
C c{elem};      //c初始化为elem；优先使用初始化器列表构造函数(若有)
C c{c2};        //拷贝构造，将c2的元素分配器拷贝到c
C c{move(c2)};  //移动构造，将c2的元素分配器移入到c
C c{{elem}, a}; //用initializer_list{elem}初始化c;使用分配器a
C c{b, e};      //用[b:e)中的元素初始化c
C c{b, e, a};   //用[b:e)中的元素初始化c;使用分配器a
```
#### 赋值
```cpp
c2 = c;         //拷贝赋值
c2 = move(c);   //移动赋值
c = {elem};     //initialize_list{elem}赋予c
c.assign(n, x); //x的n个拷贝赋予c；关联容器不适用
c.assign(b, e); //[b:e)赋予c
c.assign({elem})//initialize_list{elem}赋予c
```
### 标准容器的遍历
#### 1. 迭代器
访问`string`对象字符或`vector`对象的元素可以使用下标，也可以使用另一种更通用的机制：迭代器
标准库容器（如`vector`）都可以使用迭代器（`string`不属于容器，但支持迭代器）
访问安全，但性能比指针低

```cpp
vector<int> arr(3);
auto b = arr.begin();//类似于指针类型，使用方法和指针一样
auto e = arr.end();//尾后迭代器（尾迭代器的下一位置）
// 使用迭代器进行迭代
for(auto it = b; it != b; ++it){
    ...
}
// 迭代器运算
iter += n //向前移动n个元素
iter -= n //向后移动n个元素
iter1 - iter2 //距离
```
> - 没有`iter1 + iter2`的操作定义
> - 有些容器没有定义`<`运算符，但是都定义了`==`和`!=`，使用迭代器和!=就不用在意容器的类型
> - 向容器添加元素或删除元素将会使迭代器失效。每次改变容器后都得正确的重新定位迭代器，原来位置的迭代器值未知
> - `cbegin()`/`cend()`，无论可迭代对象是不是常量，返回的迭代器都是常量，可以读不能修改
> - `rbegin()`和`rend()`用于从后向前的迭代访问



#### 2. 基于范围的`for`循环
能自动遍历整个容器（数组、`vector`对象等），不需要知道数组的长度，语句简洁
```cpp
//遍历数组的元素
int arr[] {1, 2, 3, };
for(auto& elem:arr){//改变数组元素的值，所以用引用
elem += 2;
std::cout << elem << std::endl;
}
```