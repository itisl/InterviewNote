### STL通用算法`<algorithm>`
`<algorithm>`中函数都是函数模板在元素范围上操作，范围定义为`[first, last)`
#### 不修改序列的操作

| 函数                                       | 作用                                                  |
| ------------------------------------------ | ----------------------------------------------------- |
| `all_of()`<br>`any_of()`<br>`none_of()`    | (C++11)检查谓词是否对范围中所有、任一或无元素为`true` |
| `for_each()`                               | 应用函数到范围中的元素                                |
| `for_each_n()`                             | (C++17)应用一个函数对象到序列的前 n 个元素            |
| `count()` `count_if()`                     | 返回满足指定判别标准的元素数                          |
| `mismatch()`                               | 寻找两个范围出现不同的首个位置                        |
| `find()`<br>`find_if()`<br>`find_if_not()` | (C++11)寻找首个满足特定判别标准的元素                 |
| `find_end()`                               | 在特定范围中寻找最后出现的元素序列                    |
| `find_first_of()`                          | 搜索元素集合中的任意元素                              |
| `adjacent_find()`                          | 查找首对相邻的相同（或满足给定谓词的）元素            |
| `search()`                                 | 搜索一个元素范围                                      |
| `search_n()`                               | 在范围中搜索一定量的某个元素的连续副本                |

#### 修改序列的操作
| 函数                                    | 作用                                                           |
| :-------------------------------------- | :------------------------------------------------------------- |
| `copy()`<br>`copy_if()`                 | (C++11)将某一范围的元素复制到一个新的位置                      |
| `copy_n()`                              | (C++11)将一定数目的元素复制到一个新的位置                      |
| `copy_backward()`                       | 按从后往前的顺序复制一个范围内的元素                           |
| `move()`                                | (C++11)将某一范围的元素移动到一个新的位置                      |
| `move_backward`                         | (C++11)按从后往前的顺序移动某一范围的元素到新的位置            |
| `fill()`                                | 将一个给定值复制赋值给一个范围内的每个元素                     |
| `fill_n()`                              | 将一个给定值复制赋值给一个范围内的 N 个元素                    |
| `transform()`                           | 将一个函数应用于某一范围的各个元素                             |
| `generate()`                            | 将相继的函数调用结果赋值给一个范围中的每个元素                 |
| `generate_n()`                          | 将相继的函数调用结果赋值给一个范围中的 N 个元素                |
| `remove()`<br>`remove_if()`             | 移除满足特定判别标准的元素                                     |
| `remove_copy()`<br>`remove_copy_if()`   | 复制一个范围的元素，忽略满足特定判别标准的元素                 |
| `replace()`<br>`replace_if()`           | 将所有满足特定判别标准的值替换为另一个值                       |
| `replace_copy()`<br>`replace_copy_if()` | 复制一个范围内的元素，并将满足特定判别标准的元素替换为另一个值 |
| `swap()`                                | 交换两个对象的值                                               |
| `swap_ranges()`                         | 交换两个范围的元素                                             |
| `iter_swap()`                           | 交换两个迭代器所指向的元素                                     |
| `reverse()`                             | 逆转范围中的元素顺序                                           |
| `reverse_copy()`                        | 创建一个范围的逆向副本                                         |
| `shift_left()`<br>`shift_right()`       | (C++20)迁移范围中的元素                                        |
| `rotate()`                              | 旋转范围中的元素顺序                                           |
| `rotate_copy()`                         | 复制并旋转元素范围                                             |
| `random_shuffle()`<br>`shuffle()`       | (C++17 前)(C++11)随机重排范围中的元素                          |
| `sample()`                              | (C++17)从一个序列中随机选择 n 个元素                           |
| `unique()`                              | 移除范围内的连续重复元素                                       |
| `unique_copy()`                         | 创建某范围的不含连续重复元素的副本                             |

#### 划分操作
| 函数                 | 作用                                  |
| :------------------- | :------------------------------------ |
| `is_partitioned()`   | (C++11)判断范围是否已按给定的谓词划分 |
| `partition()`        | 将范围中的元素分为两组                |
| `partition_copy()`   | (C++11)复制一个范围，将各元素分为两组 |
| `stable_partition()` | 将元素分为两组，同时保留其相对顺序    |
| `partition_point()`  | (C++11)定位已划分范围的划分点         |

#### 排序操作
| 函数                       | 作用                                             |
| :------------------------- | :----------------------------------------------- |
| `is_sorted()`(C++11)       | 检查范围是否已按升序排列                         |
| `is_sorted_until()`(C++11) | 找出最大的已排序子范围                           |
| `sort()`                   | 将范围按升序排序                                 |
| `partial_sort()`           | 排序一个范围的前 N 个元素                        |
| `partial_sort_copy()`      | 对范围内的元素进行复制并部分排序                 |
| `stable_sort()`            | 将范围内的元素排序，同时保持相等的元素之间的顺序 |
| `nth_element()`            | 将给定的范围部分排序，确保其按给定元素划分       |
#### 二分搜索操作
| 函数              | 作用                                     |
| :---------------- | :--------------------------------------- |
| `lower_bound()`   | 返回指向第一个不小于给定值的元素的迭代器 |
| `upper_bound()`   | 返回指向第一个大于给定值的元素的迭代器   |
| `binary_search()` | 确定元素是否存在于某范围中               |
| `equal_range()`   | 返回匹配特定键值的元素范围               |

#### 集合操作（已排序范围）
| 函数                         | 作用                                 |
| :--------------------------- | :----------------------------------- |
| `merge()`                    | 归并两个已排序的范围                 |
| `inplace_merge()`            | 就地归并两个有序范围                 |
| `includes()`                 | 若一个集合是另一个的子集则返回`true` |
| `set_difference()`           | 计算两个集合的差集                   |
| `set_intersection()`         | 计算两个集合的交集                   |
| `set_symmetric_difference()` | 计算两个集合的对称差                 |
| `set_union()`                | 计算两个集合的并集                   |

#### 堆操作
| 函数              | 作用                                     |
| :---------------- | :--------------------------------------- |
| `is_heap()`       | 检查给定范围是否为一个最大堆             |
| `is_heap_until()` | (C++11)查找能成为最大堆的最大子范围      |
| `make_heap()`     | 从一个元素范围创建出一个最大堆           |
| `push_heap()`     | 将一个元素加入到一个最大堆               |
| `pop_heap()`      | 从最大堆中移除最大元素                   |
| `sort_heap()`     | 将一个最大堆变成一个按升序排序的元素范围 |

#### 最大/最小操作
| 函数               | 作用                                  |
| :----------------- | :------------------------------------ |
| `max()`            | 返回各给定值中的较大者                |
| `max_element()`    | 返回范围内的最大元素                  |
| `min()`            | 返回各给定值中的较小者                |
| `min_element()`    | 返回范围内的最小元素                  |
| `minmax()`         | (C++11)返回两个元素的较小和较大者     |
| `minmax_element()` | (C++11)返回范围内的最小元素和最大元素 |
| `clamp()`          | (C++17)在一对边界值间夹逼一个值       |

#### 比较操作
| 函数                                  | 作用                                             |
| :------------------------------------ | :----------------------------------------------- |
| `equal()`                             | 确定两个元素集合是否是相同的                     |
| `lexicographical_compare()`           | 当一个范围按字典顺序小于另一个范围时，返回`true` |
| `lexicographical_compare_three_way()` | (C++20)用三路比较比较两个范围                    |


#### 排列操作
| 函数                 | 作用                                           |
| :------------------- | :--------------------------------------------- |
| `is_permutation()`   | (C++11)判断一个序列是否为另一个序列的排列      |
| `next_permutation()` | 产生某个元素范围的按字典顺序的下一个较大的排列 |
| `prev_permutation()` | 产生某个元素范围的按字典顺序的下一个较小的排列 |

### `<numeric>`数值运算
| 函数                         | 作用                                                      |
| :--------------------------- | :-------------------------------------------------------- |
| `iota()`                     | 用从起始值开始连续递增的值填充一个范围 (C++11)            |
| `accumulate()`               | 对一个范围内的元素求和                                    |
| `inner_product()`            | 计算两个范围的元素的内积                                  |
| `adjacent_difference()`      | 计算范围内各相邻元素之间的差                              |
| `partial_sum()`              | 计算范围内元素的部分和                                    |
| `reduce()`                   | 类似`std::accumulate`，但不依序执行(C++17)                |
| `exclusive_scan()`           | 类似`std::partial_sum`，第 i 个和中排除第 i 个输入(C++17) |
| `inclusive_scan()`           | 类似`std::partial_sum`，第 i 个和中包含第 i 个输入(C++17) |
| `transform_reduce()`         | 应用一个函数对象，然后以乱序规约(C++17)                   |
| `transform_exclusive_scan()` | 应用一个函数对象，然后进行排除扫描(C++17)                 |
| `transform_inclusive_scan()` | 应用一个函数对象，然后进行包含扫描(C++17)                 |

### `<memory>`为初始化内存上的操作
| 函数                                  | 作用                                                            |
| :------------------------------------ | :-------------------------------------------------------------- |
| `uninitialized_copy()`                | 将范围内的对象复制到未初始化的内存区域                          |
| `uninitialized_copy_n()`              | 将指定数量的对象复制到未初始化的内存区域(C++11)                 |
| `uninitialized_fill()`                | 复制一个对象到以范围定义的未初始化内存区域                      |
| `uninitialized_fill_n()`              | 复制一个对象到以起点和计数定义的未初始化内存区域                |
| `uninitialized_move()`                | 移动一个范围的对象到未初始化的内存区域(C++17)                   |
| `uninitialized_move_n()`              | 移动一定数量对象到未初始化内存区域(C++17)                       |
| `uninitialized_default_construct()`   | 在范围所定义的未初始化的内存区域以默认初始化构造对象(C++17)     |
| `uninitialized_default_construct_n()` | 在起始和计数所定义的未初始化内存区域用默认初始化构造对象(C++17) |
| `uninitialized_value_construct()`     | 在范围所定义的未初始化内存中用值初始化构造对象(C++17)           |
| `uninitialized_value_construct_n()`   | 在起始和计数所定义的未初始化内存区域以值初始化构造对象(C++17)   |
| `destroy_at()`                        | 销毁在给定地址的对象(C++17)                                     |
| `destroy()`                           | 销毁一个范围中的对象(C++17)                                     |
| `destroy_n()`                         | 销毁范围中一定数量的对象(C++17)                                 |

bool all_of(Iter first, Iter last, Pred pred) bool any_of(Iter first, Iter last, Pred pred) bool none_of(Iter first, Iter last, Pred pred) Iter find_if_not(Iter first, Iter last, Pred pred)
OutIter copy_if(InIter first, InIter last, OutIter result, Pred pred)
OutIter copy_n(InIter first, Size n, OutIter result) uninitialized_copy_n(InIter first, Size n, OutIter result) OutIter move(InIter first, InIter last, OutIter result)
OutIter move_backward(InIter first, InIter last, OutIter result)
is_partitioned(InIter first, InIter last, Pred pred)
pair<OutIter1, OutIter2> partition_copy(InIter first, InIter last, OutIter1 out_true, OutIter2 out_false, Pred pred)
Iter partition_point(Iter first, Iter last, Pred pred)
RAIter partial_sort_copy(InIter first, InIter last, RAIter result_first, RAIter result_last)
RAIter partial_sort_copy(InIter first, InIter last, RAIter result_first, RAIter result_last, Compare comp)
bool is_sorted(Iter first, Iter last) bool is_sorted(Iter first, Iter last, Compare comp)
Iter is_sorted_until(Iter first, Iter last) Iter is_sorted_until(Iter first, Iter last, Compare comp)
bool is_heap(Iter first, Iter last) bool is_heap(Iter first, Iter last, Compare comp)
Iter is_heap_until(Iter first, Iter last) Iter is_heap_until(Iter first, Iter last, Compare comp)
T min(initializer_list<T> t) T min(initializer_list<T> t, Compare comp)
T max(initializer_list<T> t) T max(initializer_list<T> t, Compare comp)
pair<const T&, const T&> minmax(const T& a, const T& b)
pair<const T&, const T&> minmax(const T& a, const T& b, Compare comp)
pair<const T&, const T&> minmax(initializer_list<T> t)
pair<const T&, const T&> minmax(initializer_list<T> t, Compare comp)
pair<Iter, Iter> minmax_element(Iter first, Iter last)
pair<Iter, Iter> minmax_element(Iter first, Iter last, Compare comp)
void iota(Iter first, Iter last, T value)
true if all the values in [first, last) satisfy the predicate (or the range is empty), false otherwise
true if at least one of the values in [first, last) satisifes the predicate, false otherwise (or if the range is empty)
true if no values in [first, last) satisfy the predicate (or if the range is empty), false otherwise
returns the first iterator i in the range where pred(*i) == false or last if no such iterator found
copy all elements in [first, last) that satisfy a predicate into a range starting from result (the opposite of remove_copy_if)
copies n elements starting from first into a range starting from result invokes uninitialized_copy for n elements
moves elements from [first, last) into a range starting from result
moves elements in the range [first, last) into the range [result – (last – first), result) starting from last - 1 and proceeding to first
true if [first, last) is empty or if [first, last) is partitioned by pred, i.e. if all elements that satisfy pred appear before those that don't
copies elements that satisfy pred from [first, last) into the range starting with out_true, and other elements into the range starting with out_false
returns an iterator to the 1st element in [first, last) that doesn't satisfy pred
copies sorted elements from [first, last) into the result range (in terms of comp If supplied); the number of elements copied is determined by the size of the smaller of input and result ranges
true if [first, last) is sorted (in terms of comp if supplied), false otherwise
returns the last iterator i in [first, last] for which the range [first, i) is sorted (in terms of comp if supplied)
true if [first, last) is a heap (in terms of comp if supplied), i.e. the first element is the largest
returns the last iterator i in [first, last] for which the range [first, i) is a heap (in terms of comp if supplied)
returns the smallest value (in terms of comp if supplied) in the initializer_list
returns the largest value in the initializer_list (in terms of comp if supplied)
returns (b, a) pair if b < a (in terms of comp if supplied), and (a, b) pair otherwise
returns the smallest and the largest element in initializer_list (in terms of comp if supplied)
returns the first iterator in [first, last) pointing to the smallest element, and the last iterator pointing to the largest element (in terms of comp if supplied)
creates a range of sequentially increasing values; assigns *i = value to each element in [first, last) and increments value as if by ++value