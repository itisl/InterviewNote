### 类对象大小
==**类对象的大小**== ： **数据成员的总和** + **`vfptr指针`大小** + **`vbptr指针`大小** + **编译器内存对齐增加的字节**。

> 1. 包括父类的非`static`数据成员，不包括所有的成员函数。虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类象的存储空间的
> 2. 由于空基类优化，空类、单一继承的空类、多重继承的空类所占空间大小为：1字节
> 3. 当类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器自动在对象里安插一个`指针vPtr`指向`虚函数表VTable`，多继承下可能不止一个，单继承时虚函数个数不会影响类对象大小；
> 4. 虚承继的情况：由于涉及到虚函数表和虚基表，会同时增加一个（多重虚继承下对应多个）`vfPtr指针`指向`虚函数表vfTable`和一个`vbPtr指针`指向`虚基表vbTable`，这两者所占的空间大小总共为：8（或8乘以多继承时父类的个数）；
>     **空基类优化**：
>     为保证同一类型的不同对象地址始终有别，要求任何对象或成员子对象的大小至少为 1，即使该类型是空的类类型（即没有非静态数据成员的 class 或 struct）也是如此。
>     然而，基类子对象不受这种制约，而且可以完全从对象布局中被优化掉：

```cpp
#include <cassert>
 
struct Base {}; // 空类
 
struct Derived1 : Base {
    int i;
};
 
int main()
{
    // 任何空类类型的对象大小至少为 1
    assert(sizeof(Base) > 0);
 
    // 应用空基优化
    assert(sizeof(Derived1) == sizeof(int));
}

```
若空基类之一亦为首个非静态数据成员的类型或其类型的基类，则禁用空基优化，因为要求两个同类型基类子对象在最终派生类型的对象表示中必须拥有不同地址。

这种情况的典例是 std::reverse_iterator 的朴素实现（派生自空基类 std::iterator），它持有其底层迭代器（亦派生自 std::iterator）为其首个非静态数据成员。

```cpp
#include <cassert>
struct Base {}; // 空类
struct Derived1 : Base {
    int i;
};
struct Derived2 : Base {
    Base c; // Base，占用 1 字节，后随对 i 的填充
    int i;
};
struct Derived3 : Base {
    Derived1 c; // 从 Base 派生，占用 sizeof(int) 字节
    int i;
};
 
int main()
{
    // 不应用空基优化
    // 基类占用 1 字节，Base 成员占用 1 字节，后随 2 个填充字节以满足 int 的对齐要求
    assert(sizeof(Derived2) == 2*sizeof(int));
 
    // 不应用空基类优化，
    // 基类占用至少 1 字节加填充，以满足首个成员的对齐要求（其对齐要求与 int 相同）
    assert(sizeof(Derived3) == 3*sizeof(int));
}
```
空基类优化对于标准布局类型 (StandardLayoutType) 是被要求的，以维持指向标准布局对象的指针，用 reinterpret_cast 转换后，还指向其首成员，这是标准要求标准布局类型“在同一个类中声明所有非静态数据成员（全在派生类或全在某个基类）”，并且“无与首个非静态数据成员同类型的基类”的原因。

(C++11 起)
若空成员子对象使用属性 [[no_unique_address]]，则允许像空基类一样优化掉它们。取这种成员的地址会产生可能等于同一个对象的某个其他成员的地址。

```cpp
#include <cassert>
 
struct Empty {}; // 空类
 
struct X {
    int i;
    [[no_unique_address]] Empty e;
};
 
int main()
{
    // 任何空类类型对象的大小至少为 1
    assert(sizeof(Empty) >= 1);
 
    // 空成员被优化掉
    assert(sizeof(X) == sizeof(int));
}
```
(C++20 起)
注解
空基类优化常用于具分配器的标准库类（std::vector、std::function、std::shared_ptr 等），使得当分配器无状态时可避免为其分配器成员占用任何额外存储。这是通过将必要的数据成员之一（例如 vector 的 begin、end 或 capacity 指针）与分配器一起，在 boost::compressed_pair 的某种等价物中存储而实现的。