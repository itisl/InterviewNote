## 虚函数表与虚指针
**虚函数底层实现**：每个类对象中都存在一个虚函数表指针`vfptr`指向当前类的虚函数表`vtbl`，虚函数表中存储着对应虚函数的地址，同一个类的不同实例共用同一份虚函数表，编译时期创建。
**存在继承的情况**：继承类的虚函数表被加在基类的后面，多继承时哪个类拥有虚函数，位置就越靠前，同时虚函数表加到该基类后面。如果基类都没有虚函数则直接指向当前类的虚函数表。

![20191018100806.png](https://raw.githubusercontent.com/itisl/Pic_Bed/master/img/20191018100806.png)
类`B`继承于`A`，`A`中存在虚函数`vfunc1()`和` vfunc2()`，`B`中覆盖了`A`中的虚函数`vfunc1()`和非虚成员函数`func2()`，如下述代码所示：
```cpp
class A{
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int data1_;
};
class B:public A{
public:
    virtual void vfunc1();
    void func2();
private:
    int data2_;
};
```
#### 虚函数表和虚函数的地址

```cpp
A obj{};
printf("Address of vtbl: %p\n", *(int*)&obj); // 虚函数表地址
printf("Address of vfunc1: %p\n", *(int*)*(int*)&obj); // 第一个虚函数地址
printf("Address of vfunc2: %p\n", *((int*)*(int*)&obj + 1)); // 第二个虚函数地址
```
#### 虚函数表`vtbl`的结构模型
> ![20190903104551.png](https://raw.githubusercontent.com/itisl/Pic_Bed/master/img/20190903104551.png)
> - 橙色线框中的内容仅限于虚拟继承的情形（若无虚继承，则无此内容）
> - “offset to top”是指到对象起始地址的偏移值，只有多重继承的情形才有可能不为0，单继承或无继承的情形都为0。
> - “RTTI information”是一个对象指针，它用于唯一地标识该类型。
> “virtual function pointers”也就是我们之前理解的虚函数表指针，其中存放着虚函数指针列表。
> - 虚函数指针__vfptr位于所有的成员变量之前定义
