### 1. 内存对齐
**对齐规则**：
-  `#pragram pack(n)` 表示的是设置n字节对齐，VC默认8，gcc默认4
-  结构体内数据成员对齐，`min(数据成员, n)`，**成员偏移量**必须在这个数的**倍数**的地址上
-  结构体对齐，整个结构体大小一定是`min(最大数据成员, n)`的倍数

```cpp
class Data1
{
    char c; // 偏移量在1
    int a; // 偏移量在4
}; // 内存布局为 1 _ _ _ 4 4 4 4
class Data2
{
    char c;  // 偏移量在1
    int a; // 偏移量在4
    char d; // 偏移量在9
    // 整体为4的倍数
}; // 内存布局为 1 _ _ _ 4 4 4 4 1 _ _ _ _

class Data3
{
    char c;  // 偏移量在1
    int a; // 偏移量在4
    char c2; // 偏移量在9
    double d; // 偏移量在16
    // 整体为4的倍数
}; // 内存布局为 1 _ _ _ 4 4 4 4 1 _ _ _ _ 
 
cout << sizeof(Data1) << endl; // 输出8
cout << sizeof(Data2) << endl; // 输出12
cout << sizeof(Data3) << endl; // 输出24
```

### 2. 类对象大小
==**类对象的大小**== ： **数据成员的总和** + **`vfptr指针`大小** + **`vbptr指针`大小** + **编译器内存对齐增加的字节**。

> 1. 包括父类的非`static`数据成员，不包括所有的成员函数。虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类象的存储空间的
> 2. 由于空基类优化，空类、单一继承的空类、多重继承的空类所占空间大小为：1字节
> 3. 当类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器自动在对象里安插一个`指针vPtr`指向`虚函数表VTable`，多继承下可能不止一个，单继承时虚函数个数不会影响类对象大小；
> 4. 虚承继的情况：由于涉及到虚函数表和虚基表，会同时增加一个（多重虚继承下对应多个）`vfPtr指针`指向`虚函数表vfTable`和一个`vbPtr指针`指向`虚基表vbTable`，这两者所占的空间大小总共为：8（或8乘以多继承时父类的个数）；
     
 
### 3. 空基类优化：
作用：当存在空的基类子对象，子类可以将其默认规定的占位字节忽略
为保证同一类型的不同对象地址始终有别，要求任何对象或成员子对象的大小至少为 1，即使该类型是空的类。
然而，**空基类的子类对象不受这种制约，而且可以完全从对象布局中被优化掉**
例外：第一个非静态数据成员为空基类对象时，禁用空基类优化

```cpp
#include <cassert>
 
struct Base {}; // 空类
 
struct Derived1 : Base {
    int i;
};

struct Derived2: Base {
    Base a;
    int i;
}
 
int main()
{
    // 任何空类类型的对象大小至少为 1
    assert(sizeof(Base) > 0);
 
    // 应用空基类优化，判定为True
    assert(sizeof(Derived1) == sizeof(int));

    // 第一个非静态数据成员为空基类对象时，禁用空基类优化
    assert(sizeof(Derived2) == 2*sizeof(int));
}

```
