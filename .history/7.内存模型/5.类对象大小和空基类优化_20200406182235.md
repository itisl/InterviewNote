### 类对象大小
==**类对象的大小**== ： **数据成员的总和** + **`vfptr指针`大小** + **`vbptr指针`大小** + **编译器内存对齐增加的字节**。

> 1. 包括父类的非`static`数据成员，不包括所有的成员函数。虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类象的存储空间的
> 2. 由于空基类优化，空类、单一继承的空类、多重继承的空类所占空间大小为：1字节
> 3. 当类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器自动在对象里安插一个`指针vPtr`指向`虚函数表VTable`，多继承下可能不止一个，单继承时虚函数个数不会影响类对象大小；
> 4. 虚承继的情况：由于涉及到虚函数表和虚基表，会同时增加一个（多重虚继承下对应多个）`vfPtr指针`指向`虚函数表vfTable`和一个`vbPtr指针`指向`虚基表vbTable`，这两者所占的空间大小总共为：8（或8乘以多继承时父类的个数）；
     
 
### 空基类优化：
作用：当存在空的基类子对象，子类可以将其默认规定的占位字节忽略
为保证同一类型的不同对象地址始终有别，要求任何对象或成员子对象的大小至少为 1，即使该类型是空的类。然而，**基类子对象不受这种制约，而且可以完全从对象布局中被优化掉**：

```cpp
#include <cassert>
 
struct Base {}; // 空类
 
struct Derived1 : Base {
    int i;
};
 
int main()
{
    // 任何空类类型的对象大小至少为 1
    assert(sizeof(Base) > 0);
 
    // 应用空基类优化，判定为True
    assert(sizeof(Derived1) == sizeof(int));
}

```
若空基类之一为非静态数据成员的类型或其类型的基类，则禁用空基优化，因为要求两个同类型基类子对象在最终派生类型的对象表示中必须拥有不同地址。
