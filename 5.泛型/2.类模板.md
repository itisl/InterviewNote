## 类模板
**作用**：和函数模板类似，可以将数据的类型参数化。声明了类模板后，就可以将类型参数用于类的成员函数和成员变量。
```cpp
template<typename T1,typename T2>
class Point{
public:
    Point(T1 x,T2 y):x_(x), y_(y){}
    T1 getX(T1 x);
    T2 getY(T2 y);
private:
    T1x_;
    T2y_;
};
template<typename T1,typename T2>
T1 Point<T1,T2>::getX(T1 x){//类名也要带上类型参数，不加typename
    return x_;
}
template<typename T1,typename T2>
T2 Point<T1,T2>::getY(T2 y){
    return y_;
}
```
> 1. 类名也要带上类型参数，不加typename
> 2. 类外定义成员函数时仍然需要带上模板头
> 3. 在类外定义成员函数时，`template`后面的类型参数要和类声明时的一致

实例化
```cpp
// 栈上实例化：
Point<int,int> P1(1,2);
Point<int,float> P2(1,1.2);
// 自由存储区实例化, 赋值号两边都要指明具体的数据类型, 且要保持一致：
Point<int,int> *pP1 = new Point<int,int>(1,2);
Point<int,float> *pP2 = new Point<int,float>(1,1.2);
//（使用auto代替）
auto *pP3 = new Point<int,int>(1,2);
```
