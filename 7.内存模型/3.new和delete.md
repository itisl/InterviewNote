## `new`和`delete`
new/delete, new[]/delete[]位于<new>头文件中，返回类型为指向其类型初始化对象的指针，不负责初始化得到的内存

```cpp
void *operator new(size_t);
void *operator new[](size_t);
void *operator delete(void *p);
void *operator delete[](void *p);
```
### 1. `new`操作符
先分配内存，再调用`ctor`(构造函数)，内部调用`malloc`
```cpp
// 
Complex* pc = new Complex(1, 2);
// 编译器自动转换为
Complex *pc;
void* mem = operator new(sizeof(Complex));//内部调用malloc
pc = static_cast<Complex*>(mem);
pc->Complex::Complex(1, 2);
```
没有多余内存时会抛出bad_alloc异常，有的程序不允许异常，可以使用`noexcept`版本：
```cpp
void *oparator new(size_t, const nothrow_t&) noexcept;
void *oparator delete(void *pt, const nothrow_t&) noexcept;
int *p = new(nothrow) int[10];
delete(nothrow, p);
```
在指定地方分配对象：
```cpp
void *operator new(size_t, void *p){return p;}
X *p = new{buf} X;  // 在buf处构建X
```

### 2. `delete`操作符
先调用`dtor`析构函数，再释放内存，内部调用`free`

### 3. `new`和`delete`区别与联系
`new[]`一定要搭配`delete[]`，否则会造成少调用析构函数
```cpp
string *p = new string[3];
...
delete[] p; //调用3次dtor

string *p = new string[3];
...
delete p; //调用1次dtor
```	

### 4. `new/delete`和`malloc/free`
![20190911151533.png](https://raw.githubusercontent.com/itisl/Pic_Bed/master/img/20190911151533.png)