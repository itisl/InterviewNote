## 程序内存空间布局


内存分类：
a. 存储类(storage class)：
栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量、函数参数等。
堆，就是那些由new分配的内存块，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。"动态内存"对象与作用域独立，在函数返回后仍能使用(与栈空间相比容量大)
int *p = new int{};  // 初始化为0，没有初始化列表则不能初始化内置类型
全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）
    
1. 自由存储的问题：
    a. 内存泄漏：使用了new，但是没有用delete释放掉分配的对象
    b. 提前释放：对有其他指针指向并且会使用的对象过早的delete
    int *p1 = new int{};
    int *p2 = p1;
    delete p1;
    p1 = nullptr;
    *p2 = 1;  // 此时的内存可能被其他对象占用，引发严重的错误
    c. 重复释放：同一对象多次释放，多次调用析构函数
    int *p1 = new int[100];
    delete[] p1;
    //...其他操作
    delete[] p1; // 会产生不可预知的结果
2. 解决方法：
    a. 优先使用作用域内的变量，不要把对象放在自由存储(除非万不得已，例如对象太大)
    b. RAII(资源获取初始化)：在自由存储上构建对象，将其指针放在管理器对象(句柄)中，例如string, vector等标准容器、智能指针。注意：vector本身也是对象，可以使用普通的new和delete分配释放vector
    int n = 100;
    vector<int>* p = new vector<int>(n);
    delete p;
    c. new(new[])和delete(delete[])成对使用，将new放在构造函数，delete放在析构函数中。避免用new创建局部对象(如函数内部)，如果先有return或者发生异常再delete会造成内存泄漏。
    d. 内存检测(编译时debug)：
    g++ -c -DMEM_DEBUG xxxxxx.cpp


