## 程序内存空间布局

### 进程内存空间布局

![20190917204832.png](https://raw.githubusercontent.com/itisl/Pic_Bed/master/img/20190917204832.png)
> （1）最上层部分属于内核区域，特定进程的环境变量就存放在该区域
> （2）代码节：供CPU执行的机器指令码（.text节）
> （3）数据节：供CPU操作的数据，通常来说，初始化数据（.data）、未初始化数据（.bss）、和只读数据（.rdata）会保存在分量的节中
> （4）堆：由`new`操作符分配的内存块，"动态内存"对象与作用域独立，在函数返回后仍能使用(与栈空间相比容量较大)
> （5）栈：为各个函数提供独立的存储空间，由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的数据通常是局部变量、函数参数等。


## 内存分类：
a. 存储类(storage class)：

int *p = new int{};  // 初始化为0，没有初始化列表则不能初始化内置类型
全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改
1. 自由存储的问题：
a. 内存泄漏：使用了new，但是没有用delete释放掉分配的对象
b. 提前释放：对有其他指针指向并且会使用的对象过早的delete
int *p1 = new int{};
int *p2 = p1;
delete p1;
p1 = nullptr;
*p2 = 1;  // 此时的内存可能被其他对象占用，引发严重的错误
c. 重复释放：同一对象多次释放，多次调用析构函数
int *p1 = new int[100];
delete[] p1;
//...其他操作
delete[] p1; // 会产生不可预知的结果
### 内存泄漏的预防
> 1. 优先使用作用域内的变量，不要把对象放在自由存储(除非万不得已，例如对象太大)
> 2. RAII(资源获取初始化)：在自由存储上构建对象，将其指针放在管理器对象(句柄)中，例如string, vector等标准容器、智能指针。注意：vector本身也是对象，可以使用普通的new和delete分配释放vector
> 3. `new`/`delete`或`new[]`/`delete[]`成对使用，将`new`放在构造函数，`delete`放在析构函数中。避免用`new`创建局部对象(如函数内部)，如果先有`return`或者发生异常再`delete`会造成内存泄漏。
> 4. 内存检测(编译时debug)：
> 5. `g++ -c -DMEM_DEBUG xxxxxx.cpp`


