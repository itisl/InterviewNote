# 死锁与处理
## 死锁产生(四个必要条件)
### 互斥条件
* 对临界区资源的争抢
### 不剥夺条件
* 资源只能由进程主动释放，不能被抢夺
### 请求和保持条件
* 进程拥有了至少一个临界区资源，同时对其他临界区资源进行请求
### 循环等待条件
* 存在资源的循环等待环，每个进程的已拥有资源被下一个进程所请求
## 死锁的处理
### 静态策略：预防死锁
> 破坏某个或多个必要条件

* 破坏互斥条件
    * 将互斥使用资源改为允许共享使用
     * > 例：用SPOOLing技术把独占设备改造成共享设备，如改造打印机。但不是所有资源都可以改造

* 破坏不剥夺条件
* > 缺点：
* > 1.实现复杂
* > 2.重复请求释放资源导致低效
* > 3.有可能会导致进程饥饿

    * 进程请求资源得不到满足时，主动释放已保持的资源
    * 操作系统将优先级更高进程想要的资源强行剥夺
* 破坏请求和保持条件
* > 1.资源利用率低
* > 2.会导致进程饥饿

    * 静态分配：运行之前一次性分配需要的全部资源
* 破坏循环等待条件
* > 缺点：
* > 1.不方便增加新的设备
* > 2.使用资源顺序和递增顺序可能不一致，导致资源浪费
* > 3.用户编程实现比较麻烦

    * 顺序资源分配：给系统资源编号，必须按编号递增的顺序请求资源，已持有大编号的进程就不能逆向申请小编号资源
### 动态策略：避免死锁：银行家算法
* 思想：在资源分配之前先判断是否会导致系统进入不安全状态
* 步骤
    * 1.找出进程最大需求矩阵和已分配资源列表，计算各进程的need矩阵(待分配资源)
    * 2.将系统可用资源列表和每个进程的need列表对比，将能够满足待分配的进程加入安全序列，同时将该进程所有资源回收
    * 3.依次将各个进程加入安全序列
### 允许死锁发生：死锁的检测和解除
> 允许死锁发生，然后检测出死锁并采取措施接触死锁

* 死锁检测
    * 死锁检测算法化简资源分配图
* 死锁解除
    * 资源剥夺法
    * 终止进程法
    * 进程回退法

*XMind: ZEN - Trial Version*