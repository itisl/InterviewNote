# 死锁的产生
死锁的产生(四个必要条件)
1. 互斥条件：对临界区资源的争抢
2. 不剥夺条件：资源只能由进程主动释放，不能被抢夺
3. 请求和保持条件：进程拥有了至少一个临界区资源，同时对其他临界区资源进行请求
4. 循环等待条件：存在资源的循环等待环，每个进程的已拥有资源被下一个进程所请求
# 死锁的处理
## 静态策略：预防死锁
破坏某个或多个必要条件

1. **破坏互斥条件**
    方式：将互斥使用资源改为允许共享使用。例：用SPOOLing技术把独占设备改造成共享设备，如改造打印机。
    缺点：不是所有资源都可以改造

2. **破坏不剥夺条件**
   - 方式：
   1. 进程请求资源得不到满足时，主动释放已保持的资源
   2. 操作系统将优先级更高进程想要的资源强行剥夺
   - 缺点：
    1.实现复杂
    2.重复请求释放资源导致低效
    3.有可能会导致进程饥饿

3. **破坏请求和保持条件**
   - 方式：静态分配，运行之前一次性分配需要的全部资源
   - 缺点：
    1.资源利用率低
    2.会导致进程饥饿

4. **破坏循环等待条件**
   - 方式：顺序资源分配，给系统资源编号，必须按编号递增的顺序请求资源，已持有大编号的进程就不能逆向申请小编号资源
   - 缺点：
    1.不方便增加新的设备
    2.使用资源顺序和递增顺序可能不一致，导致资源浪费
    3.用户编程实现比较麻烦


## 动态策略：避免死锁
### 银行家算法
* 思想：在资源分配之前先判断是否会导致系统进入不安全状态
* 步骤：
1.找出进程最大需求矩阵和已分配资源列表，计算各进程的need矩阵(待分配资源)
2.将系统可用资源列表和每个进程的need列表对比，将能够满足待分配的进程加入安全序列，同时将该进程所有资源回收
3.依次将各个进程加入安全序列
## 死锁的检测和解除
> 允许死锁发生，然后检测出死锁并采取措施接触死锁

* 死锁检测
    * 死锁检测算法化简资源分配图
* 死锁解除
    * 资源剥夺法
    * 终止进程法
    * 进程回退法


## 锁
### 重量级锁

如果你学过多线程，那么你肯定知道**锁**这个东西，至于为什么需要锁，我就不给你普及了，就当做你是已经懂的了。

我们知道，我们要进入一个**同步、线程安全**的方法时，是需要先获得这个方法的锁的，退出这个方法时，则会释放锁。如果获取不到这个锁的话，意味着有别的线程在执行这个方法，这时我们就会**马上进入阻塞的状态**，等待那个持有锁的线程释放锁，然后再把我们从**阻塞的状态唤醒**，我们再去获取这个方法的锁。

这种获取不到锁就**马上**进入阻塞状态的锁，我们称之为**重量级锁**。

### 自旋锁

我们知道，线程从**运行态**进入**阻塞态**这个过程，是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到**用户态**到**内核态**的转换。当然，把线程从阻塞态唤醒也是一样，也是非常消耗时间的。

刚才我说线程拿不到锁，就会**马上**进入阻塞状态，然而现实是，它虽然这一刻拿不到锁，可能在下 0.0001 秒，就有其他线程把这个锁释放了。如果它慢0.0001秒来拿这个锁的话，可能就可以顺利拿到了，不需要经历**阻塞/唤醒**这个花时间的过程了。

然而重量级锁就是这么坑，它就是不肯等待一下，一拿不到就是要马上进入阻塞状态。为了解决这个问题，我们引入了另外一种愿意等待一段时间的锁 --- **自旋锁**。

自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看看这段时间有没其他人把这锁给释放了。怎么等呢？这个就类似于线程在那里做**空循环**，如果循环一定的次数还拿不到锁，那么它才会进入阻塞的状态。

至于是循环等待几次，这个是可以人为指定一个数字的。

### 自适应自旋锁

上面我们说的自旋锁，每个线程循环等待的次数都是一样的，例如我设置为 100次的话，那么线程在空循环 100 次之后还没拿到锁，就会进入阻塞状态了。

而自适应自旋锁就牛逼了，它不需要我们人为指定循环几次，它自己本身会进行判断要循环几次，而且每个线程可能循环的次数也是不一样的。而之所以这样做，主要是我们觉得，如果一个线程在不久前拿到过这个锁，或者它之前经常拿到过这个锁，那么我们认为**它再次拿到锁的几率非常大**，所以循环的次数会多一些。

而如果有些线程从来就没有拿到过这个锁，或者说，平时很少拿到，那么我们认为，它再次拿到的概率是比较小的，所以我们就让它循环的次数少一些。因为你在那里做空循环是很消耗 CPU 的。

所以这种能够根据线程最近获得锁的状态来调整循环次数的自旋锁，我们称之为**自适应自旋锁**。

### 轻量级锁

上面我们介绍的三种锁：重量级、自旋锁和自适应自旋锁，他们都有一个特点，就是进入一个方法的时候，就会加上锁，退出一个方法的时候，也就释放对应的锁。

之所以要加锁，是因为他们害怕自己在这个方法执行的时候，被别人偷偷进来了，所以只能加锁，防止其他线程进来。这就相当于，每次离开自己的房间，都要锁上门，人回来了再把锁解开。

这实在是太麻烦了，如果根本就没有线程来和他们竞争锁，那他们不是白白上锁了？要知道，**加锁**这个过程是需要操作系统这个大佬来帮忙的，是很消耗时间的，。为了解决这种**动不动就加锁**带来的开销，轻量级锁出现了。

轻量级锁认为，当你在方法里面执行的时候，其实是很少刚好有人也来执行这个方法的，所以，当我们进入一个方法的时候根本就不用加锁，我们只需要**做一个标记**就可以了，也就是说，我们可以用一个变量来记录此时该方法是否有人在执行。也就是说，如果这个方法没人在执行，当我们进入这个方法的时候，采用**CAS**机制，把这个方法的状态标记为**已经有人在执行**，退出这个方法时，在把这个状态改为了**没有人在执行**了。

> 之所以要用CAS机制来改变状态，是因为我们对这个状态的改变，不是一个原子性操作，所以需要CAS机制来保证操作的原子性。不知道CAS的可以看这篇文章：[并发的核心：CAS 是什么？Java8是如何优化 CAS 的？](https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247485301&idx=1&sn=c433c39a741c941a4d38d8944704b342&chksm=ce404ca1f937c5b79e2922051b36f76f9d7d669442071a3cc8489116f422331095d45cb42523&token=960773791&lang=zh_CN#rd)。

显然，**比起加锁操作，这个采用CAS来改变状态的操作，花销就小多了。**

然而可能会说，没人来竞争的这种想法，那是你说的而已，那如果万一有人来竞争说呢？也就是说，当一个线程来执行一个方法的时候，方法里面已经有人在执行了。

如果真的遇到了竞争，我们就会认为**轻量级锁**已经不适合了，我们就会把轻量级锁升级为重量级锁了。

所以轻量级锁适合用在那种，很少出现多个线程竞争一个锁的情况，也就是说，适合那种多个线程总是**错开时间**来获取锁的情况。

### 偏向锁

偏向锁就更加牛逼了，我们已经觉得轻量级锁已经够**轻**，然而偏向锁更加**省事**，偏向锁认为，你轻量级锁每次进入一个方法都需要用CAS来改变状态，退出也需要改变，多麻烦。

偏向锁认为，其实对于一个方法，是很少有两个线程来执行的，搞来搞去，其实也就一个线程在执行这个方法而已，相当于**单线程**的情况，居然是单线程，那就没必要加锁了。

不过毕竟实际情况的多线程，单线程只是自己认为的而已了，所以呢，偏向锁进入一个方法的时候是这样处理的：如果这个方法没有人进来过，那么一个线程首次进入这个方法的时候，会采用CAS机制，把这个方法标记为有人在执行了，和轻量级锁加锁有点类似，并且也会把该线程的 ID 也记录进去，相当于记录了哪个线程在执行。

然后，但这个线程退出这个方法的时候，它不会改变这个方法的状态，而是直接退出来，懒的去改，因为它认为除了自己这个线程之外，其他线程并不会来执行这个方法。

然后当这个线程想要再次进入这个方法的时候，会判断一下这个方法的状态，如果这个方法已经被标记为**有人在执行**了，并且线程的ID是自己，那么它就直接进入这个方法执行，啥也不用做

你看，多方便，第一次进入需要CAS机制来设置，以后进出就啥也不用干了，直接进入退出。

然而，现实总是残酷的，毕竟实际情况还是多线程，所以万一有其他线程来进入这个方法呢？如果真的出现这种情况，其他线程一看这个方法的ID不是自己，这个时候说明，至少有两个线程要来执行这个方法论，这意味着**偏向锁已经不适用了**，这个时候就会从偏向锁升级为轻量级锁。

所以呢，偏向锁适用于那种，始终只有一个线程在执行一个方法的情况哦。

> 这里我作下说明，为了方便大家理解，我在将轻量级锁和偏向锁的时候，其实是简化了很多的，不然的话会涉及到**对象的内部结构、布局**，我觉得把那些扯出来，你们可能要晕了，所以我大致讲了他们的原理。

### 悲观锁和乐观锁

最开始我们说的三种锁，重量级锁、自旋锁和自适应自旋锁，进入方法之前，就一定要先加一个锁，这种我们为称之为**悲观锁**。悲观锁总认为，如果不事先加锁的话，就会出事，这种想法确实悲观了点，这估计就是**悲观锁**的来源了。

而乐观锁却相反，认为不加锁也没事，我们可以先不加锁，如果出现了冲突，我们在想办法解决，例如 CAS 机制，上面说的轻量级锁，就是乐观锁的。不会马上加锁，而是等待真的出现了冲突，在想办法解决。
