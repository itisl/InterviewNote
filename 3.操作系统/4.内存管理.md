# 内存管理
## 1. 虚拟地址转换
* 绝对装入：编译器负责地址转换
* 可重定位装入：装入程序负责地址转换(早期阶段)
* 动态运行时装入：运行时才进行地址转换(现代操作系统)

## 2. 物理内存分配与回收
### 2.1 连续分配管理
系统为进程所分配的必须是连续的一块内存

1. 首次适应算法：每次从低地址查找满足大小的空闲分区
2. 最佳适应算法：优先分配满足要求的最小的空闲分区
缺点：会产生很多外部碎片
3. 最坏适应算法：优先分配最大的连续空闲分区
缺点：会很快将大分区分配完，导致后续大进程没有内存空间
4. 邻近适应算法：从上次分配完的地址开始查找满足大小的分区
### 2.2 非连续分配(离散分配方式)
* 分页内存管理
    * 把内存分为大小相等的分区，按照分区大小把进程拆分开，一般为4kb=2^12
* 分段内存管理
    * 区别：段的大小可以不相同，页的大小相同
    * 分段是信息的逻辑单位，对用户是可见的；分页是信息的物理单位，用户不可见
* 段页式内存管理
## 3. 虚拟内存
- 覆盖技术：程序分成几个模块，按时间先后运行
- 交换技术：进程在内存与磁盘间动态调度
### 3.1 虚拟内存特征
**特征**：
1. 多次性：程序允许被分成多次调入内存
2. 对换性：程序运行时无需常驻内存，可以在运行过程中换入换出
3. 虚拟性：逻辑上扩充了内存的容量
虚拟地址空间的最大容量由CPU寻址范围确定，32位系统为4GB

### 3.1 页面置换算法
#### 3.1.1 最佳置换算法OPT
每次淘汰以后最长时间不被访问的页面（理想化算法，无法实现）
#### 3.1.2 先进先出置换算法FIFO
每次淘汰最早进入内存的页面，可能导致Belady异常：为进程分配的物理块增多时，缺页中断不减反增的异常现象
#### 3.1.3 最近最久未使用置换算法LRU
将前面最久没有使用过的页面置换，性能最接近OPT算法，但是实现困难，需要硬件支持，开销大
#### 3.1.4 时钟置换算法CLOCK
将页面链接成循环队列，并增加访问位。访问过的页面访问位置为1；缺页中断时遇到访问位为1则置0，为0则置换，循环扫描
#### 3.1.5 改进时钟算法
思想：被淘汰的页面如果没被修改，不需要写回外存浪费I/O，因此优先置换没被修改、没被访问的页面(访问位，修改位)为(0,0)
在CLOCK算法基础上增加修改位。先扫描第一个(0,0)置换，不修改标志位；再扫描第一个(0,1)置换，访问位置0；再扫描第一个(0,0)置换，不修改标志位；再扫描第一个(0,1)置换