# 进程同步与互斥
> 异步性：各并发执行的进程以各自独立、不可预知的速度向前推进
> 同步(直接制约关系)：进程直接因为资源，需要协调工作次序

## 进程同步
> 详细见[Linux内核的同步机制1](https://www.ibm.com/developerworks/cn/linux/l-synch/part1/), [Linux内核的同步机制2](https://www.ibm.com/developerworks/cn/linux/l-synch/part2/)

同步方式
- 原子操作
- 信号量（semaphore）
- 读写信号量（rw_semaphore）
- 自旋锁（spinlock）
- 大内核锁（BKL，Big Kernel Lock）
- 读写锁（rwlock）
- 大读者锁（brlock-Big Reader Lock）
- 读-拷贝修改(RCU，Read-Copy Update)
- 顺序锁（seqlock）


## 进程互斥
对临界资源的访问，需要互斥进行
### 临界资源与临界区
* 临界资源：一个时间段内只允许一个进程使用，如：打印机等
* 临界区：进入临界资源的代码段
### 进程互斥原则
* 空闲让进：临界区空闲时，可允许进程立即进入相应临界区
* 忙则等待：已有进程进入临界区时，其他进程应该等待
* 有限等待：不能让进程饥饿
* 让权等待：进程无法进入临界区时，应立即释放处理机，进入阻塞态
## 信号量
机制：一对原语PV操作
### 类型
#### 整型信号量
* 用整数变量作为信号量，表示某种资源的数量
* 不满足让权等待，会一直占用处理机
#### 记录型型号量
P(S)如果剩余资源数不够，使用block原语将进程阻塞，并挂到信号量S的阻塞队列中；V(S)释放资源后，阻塞队列还有进程，便使用wakeup原语唤醒，变为就绪态


## 同步与互斥问题
> **实现进程互斥步骤**：
> * 确定临界区
> * 设置互斥信号量mutex=1
> * 进入临界区之前执行P操作
> * 离开临界区时执行V操作
  
> **实现进程同步步骤**：
> * 找出同步关系
> * 设置同步信号量初始值为0
> * 在前置操作后执行V操作
> * 在后置操作前执行P操作


### 生产者-消费者问题
* 互斥：只有一个进程能访问缓冲区mutex=1
* 同步：生产者需要空余缓冲区empty=n，消费者需要产品full=0
* PV操作先后问题：互斥P操作必须在进入临界区之前，否则可能发生死锁，V操作先后顺序没影响(互斥PV在临界区前后)
### 多生产者-消费者问题
* 互斥：只有一个进程能访问缓冲区mutex=1
* 同步：生产者A生产的产品a只能由α消费，生产者B生产的产品b只能由β消费，a=0, b=0, 缓冲区buffer=1
```c
// 生产者
A{
    // 生产a
    P(buffer)
    P(mutex)
    // a放入缓冲区
    V(mutex)
    V(a)
}
// 消费者
a{
    P(a)
    P(mutex)
    // 从缓冲区取出a
    V(mutex)
    V(buffer)
    // 消费a
}
```
### 读者-写者模型
* 互斥量：读-写进程互斥，写-写进程互斥，读-读进程互不干扰，mutex=1

处理方法：增加读进程cnt,cnt为0时对文件加锁P(mutex), cnt++，读完后cnt--，cnt为0时再解锁V(mutex)，同时应该对cnt变量的互斥操作mutex_count=1(cnt检查和赋值需要一气呵成，否则两个读进程可能cnt判断同时通过从而死锁)
```c
// 读者(读优先)
P(mutex_count)
if cnt==0:
    P(mutex)
V(mutex_count)
// 读文件
P(mutex_count)
if cnt==0:
    V(mutex)
V(mutex_count)
```

实现读写公平：增加互斥量w=1, 写者在先后进行互斥，读者在读文件之前进行互斥
### 哲学家进餐模型
* 问题：只有互斥关系，避免临界资源分配不当造成死锁
* 定义互斥信号量数组v(5,1),哲学家编号i=0~4，左边筷子编号为i，右边为(i+1)%5