{"./":{"url":"./","title":"Introduction","keywords":"","body":"Lzy's Interview Note 个人C/C++以及数据结构与算法、操作系统、TCP/IP网络编程、数据库相关的笔记 在GitBook、GitHub、Gitee上都有部署 "},"1.C++/":{"url":"1.C++/","title":"第一部分 C++","keywords":"","body":"程序的执行过程 程序首先装载到内存，与CPU的寄存器进行数据交换，并由CPU对外设进行控制 编程语言的发展 C++是一种高级语言 "},"1.C++/1.编译与链接/":{"url":"1.C++/1.编译与链接/","title":"1. 编译与链接","keywords":"","body":""},"1.C++/1.编译与链接/0.汇编指令与寄存器.html":{"url":"1.C++/1.编译与链接/0.汇编指令与寄存器.html","title":"1.0 汇编指令与寄存器","keywords":"","body":"x64汇编寄存器 寄存器与内存 CPU先将内存中的数据存储到寄存器中，再对寄存器中的数据进行运算 通用寄存器 Register 状态 使用 RAX 易失的 返回值寄存器 RCX 易失的 第一个整型参数 RDX 易失的 第二个整型参数 RBX 非易失的 必须由被调用方保留 32bit使用64bit的RAX一半作为EAX，EBX/ECX/EDX同理 汇编指令 汇编不区分大小写 []里一定代表内存地址值 变量的地址值，是其最低位字节的地址值 word为2字节，dword为4字节，qword为8字节 mov dword ptr[addr], 0 赋值指令 mov指令 move，将src值传给目标寄存器 mov dest, src 将地址src里的值传给目标寄存器 mov dest, dword ptr [src] tips:move操 作不支持内存到内存的操作，必须有一边是寄存器或立即数(常数) lea指令 load effect address，取地址（指针）赋值给目标寄存器 lea dest, [地址] 控制指令 call指令 调用指定地址的函数，call之前调用push为传参 call 函数地址 ret指令 return，返回 ret jmp指令 jump，跳转到指定地址 jmp 地址 tips：j开头的指令一般都是跳转，配合cmp, test带条件跳转 运算指令 add指令 加法，等价于a=a+b add a, b sub指令 减法，等价于a=a+b sub a, b inc指令 increase，自增，i=i+1 inc i dec指令 decrease，自增，i=i-1 dec i xor指令 异或，将a, b按位异或的结果赋值给a, 等价于a = a^b xor a, b "},"1.C++/1.编译与链接/1.编译预处理.html":{"url":"1.C++/1.编译与链接/1.编译预处理.html","title":"1.1 编译预处理","keywords":"","body":"条件编译 作用：预处理器支持有条件地编译源文件的某些部分。这一行为由 #if、#else、#elif、#ifdef、#ifndef 与#endif 指令所控制 // 防止重复引用头文件的代码规范(Google) #ifndef ___HPP_ #define ___HPP_ ... #endif // //.hpp的条件编译，防止重复引用头文件 注意：#pragma once可防止整个文件的内容被重复包含，较老的编译器可能不支持 #include include 头文件的顺序 测试的文件.h C系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 当测试文件遗漏某些必要的库时， 当前文件的构建会立刻中止 Q2：include双引号\"\"和尖括号<>的区别？ 双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。 对于使用双引号包含的头文件，查找头文件路径的顺序为： 当前头文件目录 编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径） 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径 对于使用尖括号包含的头文件，查找头文件的路径顺序为： 编译器设置的头文件路径（编译器可使用-I 显式指定搜索路径）系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径 宏与预定义 宏定义#define 作用：#define在预编译时展开，将相对应位置宏定义替换成文本, 其作用域范围从定义位置开始，到其当前所在作用域结束 tips：宏意味着你和编译器看到的代码是不同的，这可能会导致异常行为，尤其因为宏具有全局作用域，应该==避免使用宏定义常量==，尽量以内联函数、枚举和常量代替 规则： // 常量 #define PI 3.14 //死循环 #define FOREVER for(;;) // 用于switch case #define CASE break;case 带参数的宏定义 #define () 宏体中出现的参数，如果必须使用宏需要注意： 尽量用()把每个宏参数括起来 整个宏体也要使用()括起来 全局名字一定要使用作用域解析符:: #define MIN(a, b) (((a) inline内联函数 作用：inline能加快运行效率(空间换时间)，编译器能够在编译时将内联函数在调用的地方展开（类似于宏） 规则： 用法 inline int sum(); 可以单独在声明或实现处使用（建议都使用） inline函数在代码较少、调用频繁时使用，当形式复杂时，编译器不会将其编译为内联函数 对比宏，内联函数多了函数特性和语法检查 在class/struct/union的定义之内定义的函数，无论它是成员函数还是非成员friend函数，均为隐式的内联函数 声明有 constexpr 的函数是隐式的内联函数 "},"1.C++/1.编译与链接/2.从代码到可执行文件.html":{"url":"1.C++/1.编译与链接/2.从代码到可执行文件.html","title":"1.2 从代码到可执行文件","keywords":"","body":"编译与链接 C++文件格式 编译器 Microsoft Visual C++ GCC（GNU C++） Borland C++ UNIX 源文件后缀 .cpp .cxx .cc .cpp .cxx .cc .c++ .C .cpp .C .cc .cxx 注意： 类模板声明与实现如果分离，链接时会出现错误 类模板必须要写在.hpp文件中 从代码到可执行文件 C++从源代码生成可执行文件的过程： 预处理：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。 编译：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件 目标代码：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件 链接：将多个目标文件及所需要的库连接成最终的可执行目标文件 程序的生命周期阶段 如何运行一个C++程序？ 使用g++命令行编译链接(Linux) 常用命令 -c 生成.o目标文件 -o生成可执行文件 -shared 指定生成动态链接库 -L 要链接的库所在目录 -l 指定链接时需要的动态库，隐含命名规则，即在前加lib，在后加.a或.so确定库文件名 1. 编译 -E预处理命令，宏的替换，还有注释的消除，还有找到相关的库文件，生成Test.i文件 g++ -E Test.cpp -S命令将文件转换为汇编文件，生成Test.s文件 g++ -S Test.cpp 2. 目标代码 -c命令将文件转换为目标文件，生成Test.o文件 g++ -c Test.cpp 3. 生成库文件 动态库 g++ Test.cpp -fPIC -shared -o libTest.so 静态库 ar cr libTest.a Test.o 4. 链接 -o命令生成可执行文件out(或out.exe)，-L命令链接库文件路径，-l链接动态链接库.so g++ Test.cpp -L /usr/include/iostream -l Test -o out "},"1.C++/1.编译与链接/3.main函数.html":{"url":"1.C++/1.编译与链接/3.main函数.html","title":"1.3 main函数","keywords":"","body":"入口函数 全局对象(包括静态对象)的构造函数会在入口函数之前执行。 可以改变程序的入口函数，mymain()函数的参数与返回值和main相同 > gcc entrypoint.c -e mymain main()函数 作用：是程序在有宿主 (hosted)环境（亦即有操作系统）中所默认指定的入口点，在程序启动中完成对具有静态存储期的全局对象的初始化之后被调用。 main()应当有下列形式之一： int main(){ body } int main(int argc, char* argv[]){ body } //int main(int argc, char** argv) 同样合法 argc：非负数，表示从程序运行的环境传递给程序的实参个数。 argv：指针数组，表示从执行环境传递给程序的若干参数，指向包含 argc + 1 个指针的数组的首元素。数组最后元素为空指针。 main函数具有几项特殊性质： 不能在程序的任何地方使用它 不能递归调用它 不能取其地址 不能预定义，不能重载 不能定义为=delete、或声明为extern \"C\"、inline、static 或 constexpr。 主函数的函数体可以不需要包含return语句，末尾会自动执行return 0; 执行返回时，先正常离开函数（这将销毁具有自动存储期的对象），然后用和return相同的实参来调用std::exit。（std::exit 随即销毁静态对象并终止程序） (C++14 起)不允许 auto main() {...} "},"1.C++/1.编译与链接/4.static,extern和全局变量.html":{"url":"1.C++/1.编译与链接/4.static,extern和全局变量.html","title":"1.4 static,extern和全局变量","keywords":"","body":"static 作用：定义 static数据或函数在整个程序中只能有唯一定义，其生存期为整个程序，是只能在定义的作用域中使用的全局变量 static 仅在变量声明、函数声明处使用 static修饰的全局变量声明与定义同时进行（声明未指定初值会自动初始化为0） static修饰全局变量的作用域，只能是本身的编译单元 函数体内static变量的作用范围为该函数体, 在第一次调用时初始化。不同于普通成员变量, 该变量的内存只被分配一次, 因此其值在下次调用时仍维持上次的值 在模块内的static变量可以被模块内所有函数访问，但不能被模块外其他函数访问 在模块内的static函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内 类的static 类的静态成员不与类的对象关联，是具有静态存储期的独立变量，或者常规函数。 class X { static int n; }; // （仅）声明（用 'static'） int X::n = 1; // 定义（不用 'static'） extern 作用：指定外部连接，从当前文件引用外部变量或函数，声明的函数或变量可以在全局范围使用 规则： extern只允许用于声明； 声明的对象必须是全局对象，不能是static。 该变量在所有模块中只能定义一次 extern \"C\" 作用：会指示编译器这部分代码按C语言（而不是C++）的方式进行编译，进行C/C++的混合编程 规则： 用法 // 单个函数写法 extern \"C\" int sum(); // 作用域写法 extern \"C\"{ int sum(); } // C语言库.h文件兼容C++的写法 #ifdef __cplusplus extern \"C\"{ #endif int sum(); #ifdef __cplusplus } #endif 同时存在声明和实现时，声明必须被修饰，函数实现可以不修饰； extern \"C\"遵循extern的规则 常量 const常量 作用：被const修饰的变量不可修改，是一个常量 规则： 用法： const int i = 0; 定义const 常量必须指定初值 C++编译器会在编译时为const常量分配地址，并提供类型检查和作用域检查 有关底层const和顶层const，详见const详解 enum hack 作用：#define进行的是字符串替换，不利于程序调试，而且不容易控制范围。使用enum hack可以定义一个枚举常量，而且也不会导致不必要的内存分配。 class box{ private: enum {volume = 10}; int things[volume]; }; // 利用enum hack和模板元实现递归版本的阶乘直接求值 template struct Factorial{ enum {value = n * Factorial::value}; }; template<> struct Factorial{ enum {value = 1}; }; std::cout::value; enum hack比较像#define而不像const，比如对enum取址不合法； enum和#define一样不会导致非必要的内存分配； enum hack是模板元编程的一项基本技术，大量的代码在使用 enum定义的常量，并不是在预编译的时候进行替换，只是在编译的时候，根据标识去常量区获取对应的值 constexpr // TODO "},"1.C++/1.编译与链接/5.链接与符号.html":{"url":"1.C++/1.编译与链接/5.链接与符号.html","title":"1.5 链接与符号","keywords":"","body":"符号表 根据符号（变量、函数）的名字，找到内存中对应的地址 符号与符号表https://www.jianshu.com/p/bda60193808d 编译原理 符号表 https://blog.csdn.net/getianao97/article/details/85316436 静态链接与动态链接https://blog.csdn.net/weixin_43670802/article/details/88236871 静态库与共享库https://blog.csdn.net/foooooods/article/details/80259395 add_library(MySharedLib SHARED library.cpp library.h) 环境变量 • LD_LIBRARY_PATH：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序 • LD_PRELOAD：指定预先装载的一些共享库甚至是目标文件 • LD_DEBUG：打开动态链接器的调试功能 静态库和动态库 静态库就是Static Library,之所以称之为静态，与库中代码的重用方式有关。当应用程序 复用了静态库中的代码（类、函数、变量等）,这部分代码会加入最终的目标代码（如可执行 exe文件等）中。换句话说，静态库只在程序的链接阶段有用，程序运行时，并不需要静态库的支持，因为程序运行时所需要的那部分代码已经从静态库中提取出来并合并进目标文件中去了。 .lib .a 动态链接的处理方式与静态链接很相似，同样是将可重用代码放在一个单独的库文件中 (在Windows操作系统中是以dll为后缀的文件，Linux下也有动态链接库，被称为Shared Object 的so文件）,所不同的是：如果用户程序调用了动态链接库中的函数，编译器并不将库文件中 的函数执行体复制到可执行文件中，而是只在可执行文件中保留一个函数调用的标记。当程 序运行时，才由操作系统将动态链接库文件一并加载入内存，并映射到程序的地址空间中， 这样就保证了程序能够正常调用到库文件中的函数。同时，操作系统保证当程序有多个实例 运行时，动态链接库也只有一份拷贝在内存中，也就是说动态链接库是在运行期共享的。 使用动态链接方式带来了几大好处：首先是动态链接库和用户程序可以分开编写，这里 的分开既可以指时间和空间的分开，也可以指开发语言的分开，这样就降低了程序的精合度； 其次由于动态链接独特的编译方式和运行方式，使得目标程序本身体积比静态链接时小，同 时运行期又是共享动态链库，所以节省了磁盘存储空间和运行内存空间；最后一个是增加了 程序的灵活性，可以实现诸如插件机制等功能。用过winamp的人都知道，它的很多功能都是 以插件的形式提供的，这些插件就是一些动态链接库，主程序事先规定好了调用接口，只要 是按照规定的调用接口写的插件，都能被winamp调用。 .dll .so 静态绑定和动态绑定 (见虚函数与多态) 静态类型：对象在声明时采用的类型，在编译期既已确定； 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的； 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期； 非虚函数一般是静态绑定，虚函数一般是动态绑定 "},"1.C++/1.编译与链接/附：常用头文件.html":{"url":"1.C++/1.编译与链接/附：常用头文件.html","title":"附：常用头文件","keywords":"","body":"附录：头文件 万能头文件 头文件: 作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明 包含STL以及[常用头文件]的, 可用LeetCode等在线编程网站 #include // gcc编译器可用, vs不支持 常用头文件及其作用 概念库 #include //(C++20 起) 基础库概念 协程库 #include //(C++20 起) 协程支持库 工具库 #include //通用工具：程序控制、动态内存分配、随机数、排序与搜索 #include //信号管理的函数与宏常量 #include //保存执行语境的宏，及跳转到某个执行语境的函数 #include //变长实参列表的处理 #include //运行时类型信息工具 #include //(C++11 起)std::type_index #include //(C++11 起)编译时类型信息 #include //std::bitset 类模板 #include //函数对象、函数调用、绑定操作、引用包装 #include //多种工具组件 #include //C 风格的时间/日期工具 #include //(C++11 起)C++ 时间工具 #include //标准宏和 typedef #include //(C++11 起)std::initializer_list 类模板 #include //(C++11 起)std::tuple 类模板 #include //(C++17 起)std::any 类 #include //(C++17 起)std::optional 类模板 #include //(C++17 起)std::variant 类模板 #include //(C++20 起)三路比较运算符支持 #include //(C++20 起)提供依赖于实现的库信息 #include //(C++20 起)提供获得源码位置的手段 动态内存管理 #include //低层内存管理工具 #include //高层内存管理工具 #include //(C++11 起)嵌套分配器类 #include //(C++17 起)多态分配器及内存资源 数值界限 #include //整型类型的界限 #include //浮点类型的界限 #include //(C++11 起)定长整数及其他类型的界限 #include //(C++11 起)格式化宏、 intmax_t 及 uintmax_t，数学工具及转换 #include //查询算术类型属性的标准化方式 错误处理 #include //异常处理工具 #include //标准异常对象 #include //将其实参与零比较的条件性编译宏 #include //(C++11 起)定义 std::error_code，依赖于平台的错误码 #include //含有最近一次错误号的宏 字符串库 #include //确定字符数据中所含类型的函数 #include //确定宽字符数据中所含类型的函数 #include //多种窄字符串处理函数 #include //多种宽及多字节字符串处理函数 #include //(C++11 起)C 风格 Unicode 字符转换函数 #include //std::basic_string 类模板 #include //(C++17 起)std::basic_string_view 类模板 #include //(C++17 起)std::to_chars 与 std::from_chars 容器库 #include //(C++11 起)std::array 容器 #include //std::vector 容器 #include //std::deque 容器 #include //std::list 容器 #include //(C++11 起)std::forward_list 容器 #include //std::set 及 std::multiset 关联容器 #include //std::map 及 std::multimap 关联容器 #include //(C++11 起)std::unordered_set 及 #include std::unordered_multiset 无序关联容器 #include //(C++11 起) std::unordered_map 及 #include std::unordered_multimap 无序关联容器 #include //std::stack 容器适配器 #include //std::queue 及 std::priority_queue 容器适配器 #include //(C++20 起)std::span 视图 迭代器库 #include //范围迭代器 范围库 #include //(C++20 起)范围访问、原语、要求、工具及适配器 算法库 #include //对范围操作的算法 #include //(C++17 起)针对算法的并行版本的预定义执行策略 数值库 #include //常用数学函数 #include //复数类型 #include //表示和操作值的数组的类 #include //(C++11 起)随机数生成器及分布 #include //容器中值的数值运算 #include //(C++11 起)编译时有理数算术 #include //(C++11 起)浮点环境访问函数 #include //(C++20 起)位操纵函数 输入/输出库 #include //所有输入/输出库中的类的前置声明 #include //std::ios_base 类、std::basic_ios 类模板及数个 typedef #include //std::basic_istream 类模板及数个 typedef #include //std::basic_ostream、std::basic_iostream 类模板及数个 typedef #include //数个标准流对象 #include //std::basic_fstream、std::basic_ifstream、#include std::basic_ofstream 类模板及数个typedef #include //std::basic_stringstream、std::basic_istringstream、#include std::basic_ostringstream 类模板及数个 typedef #include //(C++20 起)std::basic_osyncstream、std::basic_syncbuf 及 #include typedef #include //(C++98 中弃用)std::strstream、std::istrstream、#include std::ostrstream #include //控制输入输出格式的辅助函数 #include //std::basic_streambuf 类模板 #include //C 风格输入输出函数 本地化库 #include //本地化工具 #include //C 本地化工具 #include //(C++11 起)(C++17 中弃用) Unicode 转换设施 #include //正则表达式库 #include //(C++11 起)支持正则表达式处理的类、算法及迭代器 #include //原子操作库 #include //(C++11 起)原子操作库 线程支持库 #include //(C++11 起)std::thread 类及支持函数 #include //(C++20 起)std::jthread 的停止记号 #include //(C++11 起)互斥原语 #include //(C++14 起)共享的互斥原语 #include //(C++11 起)异步计算的原语 #include //(C++11 起)线程等待条件 #include //(C++20 起)信号量 #include //(C++20 起)闩 #include //(C++20 起)屏障 文件系统库 #include //(C++17 起)std::path 类及 支持函数 "},"1.C++/2.基础/":{"url":"1.C++/2.基础/","title":"2. 基础","keywords":"","body":""},"1.C++/2.基础/1.作用域与生命期.html":{"url":"1.C++/2.基础/1.作用域与生命期.html","title":"2.1 作用域与生命期","keywords":"","body":"1. 作用域 说明：作用域是指一个标识符能独立、合法出现的区域 规则： 一般而言，使用{}包围的区域是一个独立的作用域 作用域在栈中申请的内存，随着离开作用域回收，因此作用域中局部变量只能在当前作用域使用 在同一作用域不允许定义同名变量，同名函数则 1.1 命名空间namespace 作用：命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突 规则： 新增命名空间：namespace myspace{ // 该名字空间下的成员和函数 ... } 使用命名空间的成员 位于相同的作用域中，无须特殊符号可以访问 名字空间外访问需要域解析符myspace::func(); 存在默认的全局命名空间，所有命名空间嵌套在里面，指定默认命名空间使用::func(); 命名空间不影响内存布局，命名空间在全局的，其中变量都是全局变量 同一命名空间可以在多个位置和文件共同实现，例如std在多个文件中同时定义 namespace作用域可以定义类、函数、变量，但类和函数内部不能声明namespace 在一个namespace可以自由访问另一个namespace的成员 namespace内部可以嵌套另一个namespace，使用A::B::fun(); 可以为命名空间长名起一个别名： namespace Glib = Graph_lib; 1.1.1 using namespace 作用： using声明可以使一个namespace的成员在当前作用域下使用，不必使用域解析符:: using namespace std; { cout tips：这样做相当于取消了名字空间的定义，使发生名称冲突的机会增多，可以单独为某个函数设置using std::cout; 2. 生命期 "},"1.C++/2.基础/2.声明、运算符与表达式.html":{"url":"1.C++/2.基础/2.声明、运算符与表达式.html","title":"2.2 声明、运算符与表达式","keywords":"","body":"1. 声明 离变量名最近的符号是变量的类型，其余部分确定引用的类型（从右往左阅读） 2. 运算符 四则运算i++ i-- ++i --i 逻辑运算 3. 表达式 C++可以将值赋值给表达式，取决于表达式返回的值 条件判断表达式 if else 3.1 switch case switch(expression){ case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s); } expression 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。 case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量 一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的 switch语句可以进行初始化(C++17) switch(int i = 10; a){ } "},"1.C++/2.基础/3.输入输出.html":{"url":"1.C++/2.基础/3.输入输出.html","title":"2.3 输入输出","keywords":"","body":"1. cin与cout常用 线上刷题小Tips: endl等价于'\\n'，会刷新缓冲区，造成效率低下。推荐用'\\n'代替endl； 可以使用tie()函数解除cin与cout的绑定，加快输入输出效率：std::ios::syn_with_stdio(false); //解除stdio的兼容 std::cin.tie(nullptr); std::cout.tie(nullptr); 输出精度控制：cout.precesion(3);//3为有效数字 格式化输出，见格式化字符串 1.1 已知数据的数量 1.1.1 单行数据 以空格隔开，\\n结束 while(cin>>a>>b){ cout 1.1.2 多行数据 每行开头指定输入数据个数 while(true){ int n = 0, e = 0; cin >> n; while(n--){ cin >> e; } } 1.2 不定数量 多行数据，每行不定个数 // 行读取函数原型getline(istream is,string& str,结束符=\"\\n\"); while(getline(cin, s, \",\")){ //可以用stringstream接收，方便分割， //否则使用 char *strtok(char *str, const char *delim); stringstream ss{s}; while(ss >> e){ int i = stoi(e); //如果要转换类型 } } 2. 标准库I/O流 标准库I/O流 cout 标准字符输出(默认为屏幕) cin 标准字符输入(默认为键盘) cerr 标准字符错误输出(无缓冲) clog 标准字符日志输出(有缓冲) 3. 文件流 #include | 数据类型 | 描述 | | ---------- | -------------------------------------------------------------------------------------------------------------------------------- | | ofstream | 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 | | ifstream | 该数据类型表示输入文件流，用于从文件读取信息。 | | fstream | 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 | string data; ifstream fs(\"路径\", mode); // 或使用fs.open(); // 其中，open函数原型为： // void open(const char *filename, ios::openmode mode); fs >> data; //用法和 mode可以控制打开的模式 | 模式标志 | 描述 | | ---------- | ---------------------------------------------------------------------- | | ios::app | 追加模式。所有写入都追加到文件末尾。 | | ios::ate | 文件打开后定位到文件末尾。 | | ios::in | 打开文件用于读取。 | | ios::out | 打开文件用于写入。 | | ios::trunc | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 | "},"1.C++/2.基础/4.初始化.html":{"url":"1.C++/2.基础/4.初始化.html","title":"2.4 初始化","keywords":"","body":"列表初始化 说明：在C++11之前，初始化可能发生在(), {}或者=上，C++11标准提供了一个统一的初始化方法，使用{}列表初始化 规则： 用法： int arr[] {1, 2, 3}; // 初始化一个数组 vector v{4, 5, 6}; // 初始化一个容器 int* p = new int[3]{}; //堆上初始化{0,0,0} complex c{1.0, 2.0}; // 调用构造函数 ==complex c(1.0, 2.0) 如果不指定初始值{}，编译器将变量和对象成员变量都设为0，除非对象的类有自定义构造函数 使用列表初始化能避免函数声明int i();和无参数初始化int i{};的混淆 列表初始化避免和auto结合使用，除非目的就是为了得到一个initializer_list 如果初始化的对象本身有一个接受initializer_list的构造函数(如vector)，那么整个initializer_list将作为参数传入，如果要使用其他的构造函数，应该使用()vector v1{5, 1}; // {5,1} vector v2(5, 1); // {1,1,1,1,1} 使用列表初始化，可以避免发生窄化转换，如果没有参数，还会初始化为0(指针为nullptr)int i = 3.14; // 会发生窄化转换，丢失0.14 int i = {3.14}; // 编译器不通过，或者warning int* p; // 未定义的值 int* q{}; // 初始化为nullptr 实现：编译器将{t1, t2, ..., tn}当做initializer_list，关联到一个array(类中包含array)，编译器将array内的元素逐一分解传给函数(如构造函数) 不指定参数的() {}自动初始化，编译器会调用memset初始化为0 堆空间初始化 将较大数据结构内存清零较快的方法 void memset(void str, int c, size_t n) 复制字节 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字节(按字节赋值)。 void memcpy(void dest, const void *src, size_t n) 从 src 复制 n 个字符到 dest 匿名变量（临时对象） 没有变量名、没有被指针指向的对象，用完后马上销毁 匿名对象用作函数参数时，会直接成为形参的局部变量 "},"1.C++/2.基础/5.类型及其转换.html":{"url":"1.C++/2.基础/5.类型及其转换.html","title":"2.5 类型及其转换","keywords":"","body":"1. 类型 1.1 字符串 字符串以\\0结束，字符串内存大小strlen(str)+1 = sizeof(str) char str[]{\"ab\"} char *str = new char[3]{'a','b'}; 1.1.1 字符串常量 只允许常量指针或常引用指向字符串常量 1.2 class, union, struct和enum typename()表示默认构造函数构造的临时对象 struct是一种特殊的class, union和enum则是一种特殊的struct； struct是成员和继承关系默认是public属性的,class默认为private； C语言中struct只有成员变量，没成员函数，C++都可包含； struct是C++用来兼容C语言的，实际使用上除了访问权限和class完全等价。 1.2.1 联合union 所有成员都分配在同一地址，同一时刻union只能保存一个成员变量的值，不推荐使用 union Value{ char *s; int i; }; 1.2.2 枚举enum 作用: 枚举是列出某些有穷序列集的所有成员, 在程序中用于声明一组命名的常数 枚举默认为int，必须是一种带符号或无符号的整数类型； 不指定值时默认从0开始，后面每个值为前项+1，枚举常量的值可以重复； 枚举命名常量的值不可更改，没有初始化枚举对象时不占用内存空间。 枚举常量详见enum hack 1.2.2.1 无作用域枚举 枚举名与类型在同一作用域内，值可以隐式转换成整数 enum 名字 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... }; enum 名字 : 类型 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... };(C++11) enum 名字 : 类型 ;(C++11) enum {a = 0, b, c}; //可以不声明枚举名，这种声明仅将各枚举项常量引入到其外围作用域中 enum Color{red=1, yellow, green=1}; //可以声明相同的值，后一项yellow默认=2 enum Rooms:char{ livingroom, den, bedroom, kitchen }; //可以声明类型 Color c = red; //enum定义 1.2.2.2 有作用域枚举 枚举名位于enum局部作用域，值不会隐式转换(C++11) enum struct|class 名字 { 枚举项 = 常量表达式 , 枚举项 = 常量表达式 , ... }; enum class Color{red, yellow, green}; //关键词class与struct等价 Color c = Color::red; //使用必须加上枚举名Color 2. 类型别名 2.1 类型别名typedef(C语言) C语言方法，注意typedef的用法和定义变量、函数的用法一样(除了前面加了typedef关键字) typedef int n; //n是int的同义词 typedef int (*pfun)(int, int); //pfun是函数指针类型int (*)(int, int) 2.2 别名声明using 作用和typedef一样 template using v = vector; //注意模板要带上模板头，别名不带<> 类型别名前不能加其他修饰符 unsigned int_n i; // 错误 3. 类型推导 3.1 auto类型推导 3.1.1 auto与变量 作用：自动推导变量的类型，无需显示指定(返回迭代器等类型时手动写太复杂) auto是编译器特性，不影响运行效率 规则： auto变量必须在定义时初始化 定义在一个auto序列的变量必须始终推导成同一类型auto a4 = 10, a5 = 20, a6 = 30;//正确 auto b4 = 10, b5 = 20.0, b6 = 'a';//错误,没有推导为同一类型 auto只能使用在局部变量。不能用在文件作用域变量，命名空间作用域变量和类数据成员里 如果初始化表达式是引用，则自动去除引用语义 如果初始化表达式为const或volatile，则除去const/volatile语义(auto不能自动推导成cv限定符) auto仅仅是一个占位符，不能使用sizeof或typeid 可以使用valatile, *(指针类型说明符), &(引用类型说明符)，&&(右值引用)来修饰auto关键字 auto会自动推断出数组和指针类型，因此auto与auto*作用一致 auto与{}列表: 如果不希望得到initializer_list类型，应该选择=而非{}，尽量不使用{}初始化auto变量 auto x{1}; // 推断为{1}列表 auto用于vector不会得到bool类型 3.1.2 auto与函数 当不知道函数返回类型，可以用auto f();自动推导返回类型；(C++14) 泛型lambda，参数列表可以使用[](auto x, auto y){return x+y;}(C++14) 自动推导函数对象类型auto f=function(){}; 3.2 decltype类型推导 作用：decltype用来推导表达式的类型，并可以直接使用该类型进行声明和定义。decltype并不会实际计算表达式的值，编译器分析表达式并得到它的类型 规则： decltype(expr)推导的类型和表达式完全一致，包括左右值、引用、const/volatile 可以推导返回值，返回值与函数返回值完全一致(函数不会运执行) 纯右值(字面量)会忽略const和volatile 表达式为左值，或者被括号()包围，推导出该类型的引用 4. 类型转换 4.1 隐式转换 基本数据类型，int, float, double, long可能会进行隐式的窄化转换 当一个类使用非explicit单参数构造函数，可能会将基础类型作为参数调用构造函数，将基础类型隐式转换成类的对象 4.2 强制类型转换 C语言使用()进行强制类型转换，这种转换会干扰正常的类型检查，C++使用四种强制类型转换。 cast_name(expr)，<>内指明待转换的类型 cast_name 作用 static_cast<> 静态转换, 只能进行编译器允许的转换以及非const，缺乏运行安全检测，常用于非const转const dynamic_cast<> 用于将基类的指针或引用安全地转换成派生类指针或引用。转型失败时，会返回一个nullptr指针dynamic_cast (p) const_cast<> 只能改变对象的底层const，可以改变表达式的常量属性 reinterpret_cast<> 底层的强制转换，没有任何类型和格式检查，只是内存拷贝如double转换为int时，输出的数据大小会完全不同，但是二进制数据相同。可以完成指针和非指针对象的转换 int num = 10; double d = static_cast(num); "},"1.C++/2.基础/6.循环与遍历.html":{"url":"1.C++/2.基础/6.循环与遍历.html","title":"2.6 循环与遍历","keywords":"","body":"遍历 基于范围的for循环 能自动遍历整个容器（数组、vector对象等），不需要知道数组的长度，语句简洁 不能用于指向数组的指针 //遍历数组的元素 int arr[] {1, 2, 3, }; for(auto& elem:arr){//改变数组元素的值，所以用引用 elem += 2; std::cout "},"1.C++/2.基础/7.数组与指针.html":{"url":"1.C++/2.基础/7.数组与指针.html","title":"2.7 数组与指针","keywords":"","body":"指针 说明：指针Pointer是C++中用于存放地址的变量，其值为内存地址，表示其指向变量或对象，并可以通过解引用*引用该对象 规则： 指针的定义：int n = 0; int* ptr = &n; //ptr为指向变量n地址的指针 &为取地址，可以得到变量的地址（&用在变量定义）；*用于声明指针并代表解引用，*ptr表示对对象的解引用，可以通过指针执行操作 指针指向类/结构体的对象时，可以直接用ptr->mem访问成员(等价于*ptr.mem) void*是一种无类型指针，任何类型指针都可以转为void*，它无条件接受各种类型。如果期望接口能够接受任何类型的参数，可以使用void类型。使用`void`必须清楚原始传入的是什么类型，在函数里使用时要转换成对应类型 避免使用悬空的野指针，当指针定义没指向对象或对象内存已释放时，应当设为空指针nullptr 指针类型和指针指向的类型 指针类型 说明：指针类型是指针定义时的数据类型，不代表其指向内存地址的数据类型 int* p = nullptr 指针类型只指示指针的动作，不说明指针本身的类型 指针的大小是固定的，在x86系统中为4个字节，x64位系统中为8个字节 指针类型决定了指针运算的内存偏移量(包括+, -, ++, --)，以及解引用*时操作的内存大小 指针类型为类时，动作（调用的函数）只取决于指针的类型，和指针指向地址的类型无关（多态例外，多态利用虚表指向调用的函数） 指针指向的类型 指针指向的类型是指针指向的内存地址的数据结构类型 指针类型通常与所指对象的类型一致。例外： 可以用常量指针指向非常量对象 int n = 0; const int *p = &n;//n的值可以改变，但是不能通过指针*p修改 指针指向强制类型转换的地址 父类指针可以指向子类对象 空指针 空指针nullptr是C++11标准的关键字，指针指向nullptr代表指针为空。C语言类型空指针NULL和0可能会造成歧义，代码如下： void f(int); void f(void*); f(0); // 调用f(int) f(NULL); // 实际调用f(int)，与目标调用不符 f(nullptr); // 调用f(void*) 空指针类型nullptr_t 所有定义为nullptr_t类型的数据都是等价的，行为也是完全一致。 nullptr_t类型数据可以隐式转换成任意一个指针类型。 式也是不可以的。 nullptr_t类型数据不适用于算术运算表达式。 nullptr_t类型数据可以用于关系运算表达式，但仅能与nullptr_t类型数据或者指针类型数据进行比较，当且仅当关系运算符为==、、>=等时返回true。 数组 数组名可以看做指向数组首元素的指针，数组名arr是数组首元素的指针，&arr是数组指针，但是sizeof(arr)是整个数组的大小而不是该指针大小 数组名是一个指针常量 数组的空间是静态分配的 数组与指针 &arr数组指针，指向整个数组，int (*p)[3] = &arr; 指针偏移量为int[3] arr数组元素指针int* p = arr;，指针偏移量为int 数组名arr是一个指针常量，无法通过引用非常量指针来引用，详见引用 "},"1.C++/2.基础/8.引用.html":{"url":"1.C++/2.基础/8.引用.html","title":"2.8 引用","keywords":"","body":"引用Reference 作用：引用相当于变量的别名，可以像指针一样传递地址的同时，和变量一样使用。一般引用不用于声明变量，而用于函数传递参数和返回类型（左值引用），可以和指针一样提高程序效率的同时，比指针安全且形式更加优美。 规则： 用法 // 引用不会生成中间变量传递值，而是传递地址，但是用法和普通变量一样，形式上比指针更加优美直观 int sum(const int& a,const int& b){ return a + b; } cout 引用仅在定义时需要&，对引用做计算，相当于对变量做计算 引用必须被初始化，初始化类型必须和引用变量相同（多态除外），引用初始化后，不能再引用其他变量 可以用引用初始化另一个引用，相当于多个别名 引用本身不是对象，不存在[void的引用，引用的引用，指向引用的指针、引用数组] 常引用(如函数参数中const int&)可以绑定到临时量(右值)，如上文代码，详见const与引用 引用作为返回类型时，可以作为左值被赋值，但是不能绑定临时对象（常引用也不能，需要返回临时对象使用值传递返回类型） int n = 0; int& get_num(int &n){ cout 右值引用&&(C++11) 作用：引用对象为临时对象(函数返回值，未命名的自由空间等)，判断对象为临时对象后，可以用廉价的移动操作代替拷贝操作。右值引用可以延长临时对象的生存期到该右值引用消亡 不可返回局部数据的引用 右值引用可用于为临时对象延长生存期 当函数同时具有右值引用和左值引用的重载时，右值引用重载绑定到右值（包含纯右值和亡值），而左值引用重载绑定到左值T&& rr = 1; T&& rr = a + b; 指针与引用 指针与引用的区别 引用的底层实现是指向不可更改的指针，但是从语言层面来讲引用和指针是完全不同的东西 从汇编代码角度分析，引用和指针的汇编代码相同，且都调用了lea指令对地址操作 将int&放在结构体中，结构体大小与指针一样有8字节(x64系统)，int为4字节 可以用=, +=, -=, ++, --改变指针变量的值，引用指向不可更改 指针可以为nullptr或野指针，引用必须初始化 引用会有类型检查，是类型安全的 指针的引用 离变量名最近的符号是变量的类型（引用），其余部分确定引用的类型（从右往左阅读） int*& p_ref = p; 数组的引用 可以有数组的引用，但不能有引用数组（数组元素全为引用） int arr[3]{1,2,3}; int (&arr_ref)[3] = arr; int* const &arr_ref2 = arr; //引用指向一个指针常量(顶层const)，即指向不可更改的指针，等价于数组 "},"1.C++/2.基础/9.左值和右值.html":{"url":"1.C++/2.基础/9.左值和右值.html","title":"2.9 左值和右值","keywords":"","body":"左值和右值 每个表达式恰属于三种基本值类别之一：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue) 1. 左值 性质： 可以通过左值到右值、数组到指针或函数到指针隐式转换转换成纯右值 可以是多态的：其所标识的对象的动态类型不必是该表达式的静态类型 可以由内建的取址运算符取左值的地址 可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数 左值可用于初始化左值引用 以下均为左值表达式： 变量、函数、模板形参对象 (C++20 起)或数据成员，不论其类型，即使变量的类型是右值引用，由其名字构成的表达式仍是左值表达式 常用 字符串常量，例如 \"Hello, world!\"； 转换为左值引用类型的转型表达式，例如 static_cast(x) 返回类型是到函数的右值引用的函数调用表达式或重载的运算符表达式 转换为函数的右值引用类型的转型表达式，如 static_cast(x) 1.1 泛左值 泛左值表达式包括左值、亡值。 亡值： 返回类型为对象的右值引用的函数调用或重载运算符表达式，例如 std::move(x) a[n]，内建的下标表达式，其操作数之一是数组右值 a.m，对象成员表达式，其中 a 是右值且 m 是非引用类型的非静态数据成员 a.*mp，对象的成员指针表达式，其中 a 为右值且 mp 为数据成员指针 转换为对象的右值引用类型的转型表达式，例如 static_cast(x) 性质： 泛左值可以通过左值到右值、数组到指针或函数到指针隐式转换转换成纯右值。 泛左值可以是多态的：其所标识的对象的动态类型不必是该表达式的静态类型。 非右值：左值、右值引用、const右值引用、const左值引用 2. 右值 右值分为纯右值和亡值（亡值也是泛左值） 性质： 右值不能由内建的取址运算符取地址 右值不能用作内建赋值运算符及内建复合赋值运算符的左操作数 右值可以用于初始化 const左值引用（const&） 右值可以用于初始化右值引用，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾 当被用作函数实参且该函数有两种重载可用，其中之一接受右值引用的形参而另一个接受 const左值引用的形参时，右值将被绑定到右值引用的重载之上（右值引用优先于const左值引用绑定） 以下均为右值表达式： 字面量（字符串字面量之外的），例如 5、true 或 nullptr 返回临时对象的操作符 转换为非引用类型的转型表达式，例如 static_cast(x)、std::string{} 或 (int)42 this 指针 枚举项 非类型模板形参，除非其类型为类或 (C++20 起)左值引用类型 lambda 表达式，例如 [](int x){ return x * x; } 3. 引用的传递 3.1 引用类型推导 只有右值引用推导到右值时，结果才为右值引用 | 引用传递 | 结果 | | --------- | ---- | | & & | & | | & && | & | | && & | & | | && && | && | int a1 = 1; int&& a2 = 1; auto&& b1 = a1; // b1推导为左值引用 auto&& b2 = 2; // 右值引用 auto&& b3 = a2; // 右值引用 3.2 在函数参数中传递 说明：右值引用具名化后，使用=传递时(包括在函数参数中绑定、传递)，会被视为左值引用，此时左值、右值语义可能会发生变化，可能导致不能调用正确参数类型的函数。 非const左值引用只能绑定到非const左值； const左值引用可绑定到const左值、非const左值、const右值、非const右值； 非const右值引用只能绑定到非const右值，但不适用于函数模板的形参； const右值引用可绑定到const右值和非const右值，它没有现实意义（毕竟右值引用的初衷在于移动语义，而移动就意味着修改）；4. 转移语义与完美转发 std::move转移 作用：std::move()将左值强制转换为右值引用，等价于static_cast() std::move()实现到右值的无条件转换 std::forward()完美转发 作用：保持参数传递过程中的右值语义。即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。 注意：std::forward()的实现基于模板参数的特化，在非模板函数中不会生效，此时如果需要传递右值应该使用std::move 和std::move()区别： std::forward()实现到右值的有条件转换，在模板中不确定实际传递的值时使用完美转发，可以使当前模板函数同时适应左值和右值参数 std::move()是到右值的强制转换，如果事先确定要使用移动语义(例如调用移动构造时)可以使用template void temp(T&& r){ // test(r); // forward根据参数T&&，将T定义为T&&的别名，将r强制转换为T类型(也就是T&&) // 如果本来是左值，T类型不是T&&别名，保持了左值 test(std::forward(r)); } temp(5); 上述代码，传入的字面量5是右值，在函数temp()中形参传递为左值引用，当我们希望调用temp(T&&)时就会出现问题，此时可以使用std::forward()完美转发 "},"1.C++/2.基础/10.常用关键字.html":{"url":"1.C++/2.基础/10.常用关键字.html","title":"2.10 常用关键字","keywords":"","body":"1. 类型说明符 1.1 alignas说明符 1.2 decltype()说明符 作用：获取变量声明的类型(包括顶层const和引用) decltype(f()) sum = x;//sum的类型是f的返回类型 decltype((i)) n = a; //编译器认为(i)为表达式，得到左值引用，如果i为普通变量，最终结果n也是a的引用 若实参是指名某个结构化绑定的无括号的标识表达式，则decltype产生被引用类型（在关于结构化绑定声明的说明中有所描述）。(C++17 起) 若实参是指名某个非类型模板形参的无括号的标识表达式，则decltype生成该模板形参的类型（当该模板形参以占位符类型声明时，则为进行任何所需的类型推导后的类型）。(C++20 起) 若实参为无括号的标识表达式或无括号的类成员访问表达式，则decltype产生以此表达式命名的实体的类型。若无这种实体，或该实参指名某个重载函数，则程序非良构。 若实参是其他类型为 T 的任何表达式，且 若 表达式 的值类别为亡值，则decltype产生 T&&； 若 表达式 的值类别为左值，则decltype产生 T&； 若 表达式 的值类别为纯右值，则decltype产生 T。 若 表达式 是返回类类型纯右值的函数调用，或是右操作数为这种函数调用的逗号表达式，则不对该纯右值引入临时量。(C++17 前) 若 表达式 是除了（可带括号的）立即调用以外的 (C++20 起)纯右值，则不从该纯右值实质化临时对象。(C++17 起) 不需要该类型完整或拥有可用的析构函数，而且类型可以是抽象的。此规则不适用于其子表达式：decltype(f(g()))中，g()必须有完整类型，但f()不必。 注意如果对象的名字带有括号，则它被当做通常的左值表达式，从而decltype(x)和 decltype((x))通常是不同的类型。 在难以或不可能以标准写法进行声明的类型时，decltype 很有用，例如lambda相关类型或依赖于模板形参的类型。占位符类型说明符 auto说明符 auto让编译器通过初始值来推算变量类型，auto定义的变量必须有初始值 auto item1 = var1, item2 = var2;//若var1和var2类型不一样将会报错 对于变量，指定要从其初始化器自动推导出其类型。 对于函数，指定要从其 return 语句推导出其返回类型。(C++14 起) 对于非类型模板形参，指定从实参推导出其类型。(C++17 起) 不允许使用auto的场景 不能作为函数形参； 不能用于类的非静态成员 不能定义数组 2. 限定符 2.1 cv-限定符 2.2 constexpr 作用：constexpr说明符声明可以在编译时求得函数或变量的值 将变量声明为constexpr类型，可以让编译器验证变量值是否为常量表达式（编译过程就能得到结果的表达式），必须用常量表达式初始化。 普通函数不能作为constexpr变量的初始值，但是可以通过定义constexpr函数（足够简单）来初始化constexpr变量 constexpr int *p = nullptr; // p是常量指针（顶层const,和const定义的不同）2.3 constexpr函数 constexpr函数可以在编译时求值，从而可以用constexpr函数来初始化constexpr变量constexpr int Fac(int n){ return (n>1)? n*Fac(n-1):1; } constexpr int kf9 = Fac(9); //必须在编译时求值 constexpr函数必须是一个==纯函数==：必须包含一条独立的return语句(return 常量表达式)，不能有==循环==、==条件判断==、==局部变量==、不能有==副作用==(修改变量的值)，允许递归和条件表达式 int kGlob; constexpr void Bad1(int a){ //错误：函数类型不能是void，必须有返回值 kGlob = a; // 错误：不能有副作用（修改变量的值） } constexpr int Bad2(int a){ if(a>0) return a; // 错误：不能有if语句 else return -a; } 3. 属性 [[...]]被称为属性，可以置于C++语法的任何位置， [[noreturn]] 作用：[[noreturn]]放在函数声明开始位置表示不希望任何返回结果。 [[noreturn]] void exit(int); //exit永远不会返回任何结果 using using可以用于namespace和namespace中的成员 using可以用于类型别名和模板别名 using用于类的成员中，可以在派生类中指定使用基类的某个成员(即使该成员为private/protected，包括基类的构造函数) noexcept 作用：表明一个函数不会抛出异常 void swap(int, int) noexcept{}; // 也可以加上判断 void swap(int, int) noexcept(if a>b){}; decltype sizeof() 作用：返回类型或其对象在内存中所占的字节数 sizeof()是一个占位符，其值在编译时期就已经确定 "},"1.C++/2.基础/11.const与volatile.html":{"url":"1.C++/2.基础/11.const与volatile.html","title":"2.11 const与volatile","keywords":"","body":"1. const 作用：const用于告诉编译器，const修饰的变量不会在代码中显式修改，如果代码会修改就报错(const不能保证变量在内存中的值不被修改) const修饰的是其右边的内容 1.1 const与指针 底层const常量指针：p是变量（指向另一个变量），但是*p是常量，不能通过*p间接修改变量 顶层const指针常量：p是常量，*p是变量，指针的指向不可修改，但是*p可以间接改变变量 底层const常量指针用于函数参数时和引用规则相同 ```cpp // 底层const，p是变量（指向另一个变量），但是p是常量(不能通过p改变变量)。下面两种等价 const int p1 = &i; int const p1 = &i; p1 = &j; //正确 *p1 = 0; //错误 // 顶层const，p是常量，p是变量 int const p2 = &i; p2 = &j; //错误 *p2 = 0; //正确 // p和p都是常量，下面两种等价 const int const p3 = &i; int const* const p3 = &i; ## 1.2 `const`与引用 **作用**：防止通过引用修改变量，常用于通过引用传递函数实参同时防止修改实参，或传入临时量和`const`常量（`const`常量无法使用非`const`形参的函数） **规则**： 1. `const`必须在`&`符号的左边 ```cpp const int& r = a; const引用可以绑定临时对象（常量、表达式、函数实参），不可绑定函数返回值（返回值虽然是临时对象，但是在函数内已经构造，不能用于初始化） const引用可以引用不同类型的数据，此时会产生临时变量，引用指向的不是初始化时的对象（指针不能指向不同类型） const引用作为函数参数时： 可以同时接受const实参和非const实参（非const引用只能接受非const实参） 可以跟非const引用构成重载 1.3 const与函数 1.3.1 const修饰函数的参数 const用作函数参数，可以与不用const的函数构成重载 const修饰函数的返回值 值传递/引用传递方式：不用加const修饰，没有意义 指针传递：必须用底层const指针接收 1.4 const成员函数 作用：const对象可以调用const成员函数，而不能调用非const修饰的函数 规则： 可以访问类中所有成员变量，但是不能修改除静态成员以外的变量 在定义和声明的时候都要使用const static成员函数不能使用const 只能调用const或static成员函数 const成员函数可以和非const构成重载，非const对象优先调用相对应类型的函数void A::func() const; // 2. constexpr 作用：constexpr修饰的变量/函数，会在编译期就确定表达式的值，和const不同，该值不会在程序运行期间被更改。根据这个特征可以在编译时求值，虽然会增加编译时间，但是会加快执行效率。 修饰函数可以在编译期确定值，代替模板元编程 "},"1.C++/3.类与对象/":{"url":"1.C++/3.类与对象/","title":"3. 类与对象","keywords":"","body":""},"1.C++/3.类与对象/1.类与对象.html":{"url":"1.C++/3.类与对象/1.类与对象.html","title":"3.1 类与对象","keywords":"","body":"类与class 作用：将数据结构和其对应方法封装，实现面对对象 规则： 用法： class A{ public: //公有成员 void func_(); //成员函数（方法） private: //私有成员 int var_; //成员变量（属性） … }; 一个类是包含其成员的namespace 可以为类定义运算符，如+, !和[] 类是一个模板，编译后不占用内存空间，所以定义类时不能对类进行初始化，只能创建对象的时候初始化; 在类内部可以定义其类型的指针变量，但是不能直接创建当前类实例（static除外，static对象属于类不属于具体对象），也可以使用成员函数创建实例 class, union, struct和enum的关系 struct是一种特殊的class, union和enum则是一种特殊的struct； struct是成员和继承关系默认是public属性的,class默认为private； C语言中struct只能包含成员变量，不可包含成员函数，C++都可包含； struct是C++用来兼容C语言的，实际使用上除了访问权限完全等价。 更多关于struct, enum, union可见数据类型 ==和struct, enum一样，';'也是类定义的一部分, 表示类定义结束== 类的成员 访问权限/继承方式 private：公共的，任何地方都可以访问（struct默认） protected：保护的，当前类、子类内部可以访问 private：私有的，只有当前类内部可以访问（class默认） class A{...}; class B: public A{...}; //public继承 继承方式/父类成员 public成员 protected成员 private成员 public继承 public protected 不可见 protected继承 protected protected 不可见 private继承 private private 不可见 继承方式中的public/protected/private是用来指明父类成员在子类中的最高访问权限 使用class定义类不写明继承方式时，默认继承方式是private，struct默认是public 父类中的private成员在子类中始终不能在子类的成员函数中访问或调用，在子类访问父类private成员的方法是使用父类的非private成员函数 访问权限不改变对象的内存布局 改变访问权限：使用using关键字可以改变父类成员在子类的访问权限public: using People::name_; tips：一般最好public继承，能够将父类成员的权限也继承过来 成员函数 参数列表中使用const可以同时适用于const参数和非const参数 成员函数属于类，static成员函数可以不借助对象直接通过类名调用 成员变量 成员变量属于对象 类与对象的调用 类的成员为public ::操作符：属于类不属于对象，且不依赖于对象独立运行的，使用A::s_func_()调用和访问。如static成员变量和static成员函数 .操作符：属于对象不属于类的，使用A.func_()调用和访问。（成员函数虽然属于类，但是隐含有this指针绑定到当前对象） ->操作符：指向对象的指针，使用p->func_()调用和访问 "},"1.C++/3.类与对象/2.构造与初始化.html":{"url":"1.C++/3.类与对象/2.构造与初始化.html","title":"3.2 构造与初始化","keywords":"","body":"构造函数 作用：对象创建时自动调用，用于初始化对象。 规则： 用法： class A{ public: A(); //构造函数 ~A(); //析构函数 }; 名字和类名相同，无返回值 构造函数没有名字且无法被直接调用。它们在发生初始化时调用，且它们按照初始化的规则进行选择 存在自定义构造函数时，必须选择其中之一进行对象初始化 单参数的构造函数应该声明为explicit，避免编译器做类型转换 使用A()=default;并不实现，编译器会自动生成默认构造函数 有constexpr说明符的构造函数令其类型成为字面类型(LiteralType) 默认构造函数 作用：构造对象时默认调用的构造函数 规则 不能定义两个带初始值的默认构造函数（会报错）。 程序中已定义构造函数，编译器不会再隐含生成 调用没有参数的构造函数可以省略括号：Clock today; 参数初始化列表 作用：在构造函数中对成员变量赋值，等价于逐个变量=（语法糖）。同时可以为const类型变量初始化(也可以使用类内初始化器) 规则： 只能用于构造函数： A::A(int a,int b,int c): a_(a),b_(b), c_(c){} 只能初始化非静态数据成员（也就是属于对象的部分） 使用构造函数初始化const成员变量、引用时，只能用参数初始化列表，否则使用类内初始化 参数初始化顺序只与成员变量在类中声明的顺序有关，与初始化表列出的变量的顺序无关（低位地址先初始化） 如果声明和实现分离，初始化列表只能用于实现，不能用于声明 可以和函数默认参数配合使用 初始化列表的构造函数，会先执行初始化，再执行函数体 如果自定义了构造函数，全局区对象会把未指定初值的成员变量初始化为0，其他内存空间的对象成员变量不会被初始化，需要显式初始化 构造函数和析构函数都为public，对象才能正常使用 类内初始化(C++11起) 规则： 用法： class A{ int a{1};// 或int a = 1; 注意这里不能使用()初始化 const int b{2}; // const int b = 2; } 直接在类内初始化成员变量，与构造函数是等价的，没有构造函数时编译器会生成默认构造函数 类内初始化不能初始化static成员变量，必须在类外初始化（C++17可以使用inline在类内初始化static成员变量） 其他构造函数 拷贝构造函数和移动构造函数见拷贝与移动 转换构造(隐式构造)函数 编译器会隐式调用单参数的构造函数 不希望编译器隐式调用单参数构造函数时，可以使用explicit禁止隐式调用 转换构造函数还作为用户定义的转换序列中的一部分，在复制初始化中受到考虑 隐式声明的及用户定义的非explicit复制构造函数与移动构造函数也是转换构造函数 // 加上默认参数，构成单参数构造函数 Fraction(int numerator, int denomirator=1) :numerator_(numerator), denomirator_(denomirator){ } Fraction operator+(...){ //重载operator+ return Fraction(...); } // 运算时，会将整数当做一个参数 Fraction f(3, 5); double d = 4 + f; // 调用构造函数将4转换为F(4,1), 然后调用operator+ 委托构造函数 作用：使用类的其他构造函数执行初始化过程(两个构造函数功能相似时，可以调用减少代码量) 规则： 用法： A::A(): a_(0),b_(0), c_(0){} //默认构造函数 A::A():A(){...}; //使用委托构造函数，先调用默认构造函数A() 只能在初始化列表调用其他构造函数 编译器默认生成的构造函数 编译器会在下面情况自动生成默认构造函数 成员变量声明时进行了初始化（类内初始化） 有定义虚函数 虚继承了其他类 成员有其他对象类型，且这个成员构造函数 父类有构造函数 总结：创建对象时，需要进行内存操作（初始化、生成虚表指针等，以及成员的初始化和构造）时，编译器才会自动生成构造函数 "},"1.C++/3.类与对象/3.构造、析构与子类.html":{"url":"1.C++/3.类与对象/3.构造、析构与子类.html","title":"3.3 构造、析构与子类","keywords":"","body":"析构函数 作用：用于销毁对象，释放内存。对象内部申请的堆空间，需要由析构函数回收 规则： 类外自定义析构函数： Clock::~Clock(){ delete[] arr_; //释放申请的数组的内存 } //析构函数定义 一个类只有一个析构函数 析构函数在销毁对象时自动执行，，没有参数和返回值 当类中不存在指针、动态分配内存时，可以不指定析构函数；否则必须指定用来释放掉指针所指向内存，避免内存泄漏 存在父类指针指向子类对象时，父类的析构函数必须为virtual，否则父类指针不会调用子类析构函数，会部分析构而内存泄漏 子类的构造与析构 子类构造函数 规则： 用法：子类构造函数在初始化列表指明父类构造函数（和委托构造函数一样） People(std::string name,int age);//父类构造函数声明 Student(std::string name,int age,float score);//子类构造函数声明 Student::Student(std::string name,int age,float score): People(name, age), score_(score){ ... //单继承子类构造函数的初始化列表 } 如果初始化列表没有指定父类构造函数，就默认调用父类的无参构造函数；如果父类没有无参构造函数（但是有其他构造函数），编译失败；如果父类没有构造函数，就不调用父类构造函数，只执行子类的构造函数 构造函数不能直接继承，即使继承也不是子类构造函数（使用using，不推荐） 多继承调用父类构造函数，顺序按照继承时声明的顺序 子类构造函数中只能调用直接父类的构造函数，不能调用间接父类的构造函数 子类析构函数 规则： 析构函数也不能被继承，与构造函数不同的是，在子类的析构函数中不用显式地调用父类的析构函数，子类会自动调用父类析构函数 父类的析构函数应该为virtual，并且子类存在需要手动释放的内存时，子类必须override该虚函数，否则使用父类指针指向子类对象时，会造成只析构父类部分 构造、析构的顺序 在内存中，父类的成员在前（低位），子类的成员在后（高位），申请和释放内存像栈一样（这是单个对象的内存布局，永远是从低到高，和栈多个对象从高位到低位生长没关系） 子类(或复合)对象构造由内到外： Derivrd构造函数先调用Base的默认构造函数，然后调用Component的默认构造函数，然后执行自己 Derived::Derived(...):Base(), Component(){ ... } 子类(或复合)对象析构由外到内：Derived析构函数先执行自己，然后调用Component的析构函数，然后再调用Base析构函数(顺序相反) Derived::~Derived(...):{ ... ~Component(), ~Base() } "},"1.C++/3.类与对象/4.拷贝与移动.html":{"url":"1.C++/3.类与对象/4.拷贝与移动.html","title":"3.4 拷贝与移动","keywords":"","body":"拷贝和移动 1. 浅拷贝和深拷贝 当利用已存在对象初始化新对象时，调用新对象的拷贝构造函数进行初始化，这个过程叫做拷贝 浅拷贝：将已存在对象的内存内容直接复制到新对象的内存。如果成员中有指针变量时会复制其指向的地址，新对象可能会访问到已存在对象的指针成员指向的堆上内存空间 深拷贝：将整个已存在对象的完整状态拷贝到新对象，如果有指针指向堆上内存，会重新在堆上开辟新的内存，并将指针变量指向新的内存 1.1 浅拷贝构造函数 作用：类内成员变量含指针、动态分配的内存时，必须定义拷贝构造函数进行深拷贝，否则编译器会生成默认浅拷贝构造函数。 规则： 用法： A(const A &a); //拷贝构造函数的声明，注意参数不能为值传递 A(const A &a)=delete;//指示编译器不生成默认复制构造函数 A a2 = a; // 等价于A a2(a); 调用拷贝构造函数初始化 a2 = a; //调用拷贝赋值函数operator = 没有定义拷贝构造函数时，编译器自动生成浅拷贝构造函数 拷贝构造函数和拷贝赋值操作operator =需要同时给出，如果没有定义，编译器会自动生成浅拷贝赋值函数 可以在private中加入拷贝构造的声明或使用=delete，防止生成默认拷贝函数 拷贝构造函数参数不能使用值传递，否则形参会继续调用拷贝构造函数创建临时对象，陷入死循环 如果不加const限制，将不能拷贝const修饰的对象 1.2 深拷贝构造函数 作用：不指定拷贝构造函数时，编译器默认执行浅拷贝。为了实现深拷贝，需要定义拷贝构造函数 // String对象的深拷贝构造函数 inline String::String(const String& str){ data_=new char[strlen(str.data_) + 1]; strcpy(data_, str.data_); } 存在继承时，父类的拷贝部分应该在初始化列表中调用父类的拷贝构造函数 1.3 拷贝赋值函数 动态分配成员的类除了深拷贝构造函数时，还必须定义拷贝赋值函数，即operator=，为了连续赋值，需要返回引用 ==定义拷贝赋值函数的步骤：== 先判断是否自我赋值 delete掉当前对象数据的内存（如果继续指向原空间可能有空间大小不一致等问题，更改指向而不delete会造成内存泄漏） new申请一块与被复制对象数据相等的内存空间，并复制内容// String对象的拷贝赋值函数 inline String &String::operator=(const String& str){ if(this == &str){ //先判断是否是自我赋值 return *this; } delete[] this.data_; //先delete已存在的字符串 this.data_ = new char[strlen(str.m_data) + 1]; //+1是末尾的'\\0' strcpy(this.data_, str.data_); return *this; } String s2{s1}; // 调用拷贝构造函数 String s3 = s1; // 调用拷贝赋值函数 2. 移动操作 和拷贝构造一样，移动构造函数和移动赋值操作operator=必须同时给出，移动操作可以代替深拷贝，最小化拷贝量而不会增加复杂性。 2.1 移动构造函数 以自身为参数时，不会调用移动构造函数，因此不用判断是否自我构造 必须要把右值的内容更改掉，把传入的内容指针置空，因此参数不能为constString::String(String&& s):data_(s.data_){ s.data = nullptr; } 2.2 移动赋值函数 为了连续赋值，移动赋值函数应该返回引用 应该判断是否自我移动 原先指向的堆空间应该先释放，被移动的对象指针应该置空nullptr 对传入的参数有改动，参数不能为const修饰 String& String::operator=(String&& s){ if(&s != this){ delete data_; data_ = s.data; s.data_ = nullptr; } return *this } "},"1.C++/3.类与对象/5.继承.html":{"url":"1.C++/3.类与对象/5.继承.html","title":"3.5 继承","keywords":"","body":"继承 作用：可以让子类拥有父类的所有成员，可以在拓展父类功能的同时复用已实现代码 规则 ： 用法： class 子类名:继承方式 父类名{ // 子类新增成员 }; 被继承的类称为父类，继承的类称为子类 子类包含了全部父类中除构造函数和析构函数外的所有成员 子类可以直接使用父类中的公有成员A::func();，子类对象同理b.A::func(); 子类声明了和父类成员同名的新成员，父类成员函数和子类成员函数不会构成重载，子类的新成员会覆盖同名成员 多继承 说明：一个类可以同时拥有多个父类（不建议使用，会增加程序设计复杂度） 规则： 用法： class C:public A, public B{...};//C同时继承A和B 子类同时拥有所有直接父类的成员 子类在初始化列表中使用多个父类的构造函数，构造顺序按照继承的顺序 C::C():A(), B(){} 子类拥有父类的同名成员变量时，父类成员虽然会覆盖掉，但是仍然占用内存 二义性：类A和类B包含同名成员var_，而多继承子类C没有var_，编译器不知道该使用哪一个var_，可以使用A::var_限定 如果父类都有虚函数，那么子类会产生对应的多张虚表，虚指针在内存中顺序按照继承的顺序（见虚函数表与虚指针）菱形继承 graph BT D[D] --> B[B] D[D] --> C[C] B[B] --> A[A] C[C] --> A[A] 菱形继承，类D会同时拥有多个类A中的数据，在产生命名冲突同时还会有数据冗余 虚继承 作用：解决多继承时的命名冲突和冗余数据问题，使得在子类中只保留一份间接父类的成员。 规则： 用法：在继承方式前加上virtual关键字 //虚父类A class A{ public: int x_; }; //虚继承 class B: virtual public A{ … }; class C: virtual public A{ … }; //只会保留一份间接父类A中的成员 class D: public B, public C{ … }; 类B和C需要虚继承，类D不需要 虚继承只影响从指定了虚基类的子类中进一步派生出来的类D，它不会影响子类B、C。 虚基类成员在所有子类成员后面 利用虚基表指针和虚基表实现（类似于了虚函数表） 虚继承时的构造函数 最终子类不仅需要调用B, C的构造函数，还需要调用间接父类A的构造函数（B, C的构造函数对A的初始化是无效的，只有D有效，普通继承不能调用间接父类） D::D(int x1, int x2, int x3, int x4): A(x1),B(x2),C(x3),D_x(x4) {} 调用顺序：先调用虚父类的构造函数，再按出现顺序调用其他构造函数 "},"1.C++/3.类与对象/6.虚函数与多态.html":{"url":"1.C++/3.类与对象/6.虚函数与多态.html","title":"3.6 虚函数与多态","keywords":"","body":"多态 概念：同一种操作可以作用于不同的对象，可以有不同的解释，产生不同的执行结果 父类指针可以指向父类对象，也可以指向子类对象，并且能够正确执行相对应类的函数。多态定义了统一的接口，使一个函数能够同时处理子类和父类的对象，并完成相对应类的功能，同一个函数在父类和子类中可以实现不同功能 规则： 父类指针允许访问的范围只限于父类定义的成员 父类指针可以指向子类对象，子类指针不能指向父类对象（父类指针允许访问内存范围小，安全；子类指针访问范围更大，访问父类对象可能会访问越界） 继承方式必须为public 构成多态的要素： 子类覆盖override父类的成员函数 父类指针指向子类对象 利用父类指针调用子类覆盖的成员函数 多态是利用虚函数表实现的，详见内存模型的虚函数表与虚指针 指针和引用都能实现多态，但是引用没有指针灵活 虚函数 作用：默认情况下不存在多态，编译器只会根据指针类型调用对应的函数，不存在多态。虚函数的作用就是构成运行时的多态。 规则： 虚函数使用virtual声明，virtual func() 虚说明符序列{};，虚说明符序列，必须是 override/final/override final之一 class A{ public: virtual ~A(); //将析构函数声明为虚函数 ... }; 虚函数是可在子类中覆盖其行为的成员函数，即使没有关于该类实际类型的编译时信息，仍保留被覆盖的行为（纯虚函数） 重载和覆盖的区别 对于virtual函数，必须形参列表相同才能override，否则编译器会认为相互独立而遮蔽 虚函数注意事项： 只有类的成员函数才能声明为虚函数。 构造函数不能是虚函数，因为构造函数不能被继承 父类的析构函数应该声明为虚函数（防止父类指针只析构父类部分而不析构子类） 只需要在虚函数的声明处加上virtual 键字，函数定义处可以加也可以不加(最好加上以及使用override，使程序更加清晰)。 在父类中定义了虚函数时，如果子类没有定义新的函数来覆盖此函数，那么子类对象将用父类的虚函数。 静态成员函数不能使用虚函数，因为它不受限于某个对象。 内联函数不能是虚函数。 纯虚函数和抽象类 作用：没有函数体且声明为= 0的虚函数，用来定义接口规范 有时候父类希望子类拥有统一的功能（例如People都要工作），但是父类无法给出具体的定义（不同的职业工作内容不一样），父类就可以定义纯虚函数自己不定义虚函数，交给子类完成定义 规则： 纯虚函数的声明，使用= 0: virtual type FunName(para_list) = 0; //在结尾加上=0告诉编译器这是纯虚函数 纯虚函数没有函数体 含有纯虚函数的类是抽象类 抽象类不可实例化，没有构造函数 抽象类可以有其他非纯虚函数成员 纯虚函数为子类提供约束，子类必须覆盖所有的纯虚函数，否则子类依然是抽象类 只有类中的虚函数才能被声明为纯虚函数 "},"1.C++/3.类与对象/7.静态成员.html":{"url":"1.C++/3.类与对象/7.静态成员.html","title":"3.7 静态成员","keywords":"","body":"static成员 static变量或函数在整个程序中只能有唯一定义，其生存期为整个程序，不同的作用域可以有定义的同名的静态变量，是属于不同作用域的不同变量 静态成员变量 作用：使用static成员变量来实现多个对象共享数据（如计数器） 规则： 用法： class A{ public: static int count_; }； static静态成员变量必须在类声明的外部初始化(C++17之前)，非static成员变量可以类内初始化int A::count_ = 0; //静态成员变量在初始化时不能再加static，但必须要有数据类型 (C++17)静态数据成员可以声明为inline。内联静态数据成员可以在类定义中定义，而且可以指定初始化器，不需要类外定义class A{ inline static int count_ = 1; }; static成员变量属于类所有，在编译的时候确定内存地址，只占一份内存 static成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问A::count_（前提是public权限），也可以通过对象访问a.count_（不推荐，warning） 子类和父类可以有定义的同名的静态变量，是属于不同作用域的不同变量 注意事项： static成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。没有在类外初始化的 static 成员变量不能使用。 静态成员函数 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，不能访问非静态成员变量和非静态成员函数，但可以访问其他静态成员 可以直接通过类名调用A::func()，不需要借助实例 静态成员函数不能是虚函数 声明和实现可以分离，但是只能在声明处使用 "},"1.C++/3.类与对象/8.友元成员.html":{"url":"1.C++/3.类与对象/8.友元成员.html","title":"3.8 友元成员","keywords":"","body":"friend友元 作用：可以使其他类中的成员函数或全局函数访问当前类的private成员。 规则： friend的关系不能传递（你朋友的朋友不是你的朋友），也不能被继承（你朋友的孩子不是你的朋友） friend函数，不能直接访问类的成员，必须借助类的对象访问； 同一个class的对象互为friend； 一个函数可以被多个类声明为友元函数，这样函数可以访问多个类中的private成员； 访问说明符(public，protect，private)对于友元声明没有影响friend函数 将非成员函数声明为friend函数： class Clock{ friend void show(Clock &ck); }; void show(Clock &ck){} //非成员函数 其他类的成员函数声明为friend函数： class Clock{ public: friend void Address::show(Clock *ptime); };//声明Clock类 class Address{ void show(Clock *ptime); }; 友元函数中含有泛型时，需要在函数名后面加上<>（()之前）friend类 友元类：可以将整个类声明为另一个类的友元（==不建议，只将成员函数声明为友元函数更安全==）class Clock{ public: friend class Address;//Address类声明为Clock的友元类 ... }; 友元关系是单向的（你是我的朋友，我不一定是你的） 友元类只能声明，不能定义新的类（friend class X {}; ） "},"1.C++/3.类与对象/9.类的关键词.html":{"url":"1.C++/3.类与对象/9.类的关键词.html","title":"3.9 类的关键词","keywords":"","body":"this指针 作用： this是一个指针，指向当前调用函数的对象的地址 在类的非静态成员函数中需要返回类对象本身的时候，使用 return *this; 当参数与成员变量名相同时，如this->n = n; （不能写成n = n） 规则： 用在类的内部，是一个const指针，指向当前对象，可以用->来访问当前对象的成员变量或成员函数 this通过指针常量T* const this形参传入，在成员函数中不能被修改指向，只能在非静态成员函数内部使用 this实质上是成员函数的一个隐藏形参，在调用成员函数时将对象地址作为实参传递给this, 在编译阶段由编译器自动将其添加到参数列表 this是一个右值，不能取得this的地址(不能&this) const成员 const可以用来修饰成员变量、非静态成员函数、对象 注意：const用于函数名前面用于修饰返回值，只有用于后面才是const成员函数，注意区分 const成员变量：和普通变量用法一样，必须初始化 参数初始化列表 或类内初始化 const成员函数：int A::func_() const{} 可以访问类中所有成员变量，但是不能修改除静态成员以外的变量 在定义和声明的时候都要使用const static成员函数不能使用const 只能调用const或static成员函数 const成员函数可以和非const构成重载，非const对象优先调用相对应类型的函数 const对象： const对象只能使用const或static成员函数，可以访问public变量，但不能修改 注意：const成员函数中，实际上const修饰的是*this，因此const成员函数不可以修改非static成员(可以修改static和mutable修饰的成员变量，因为static不属于子对象) int gethour() const; //类内 void Clock::gethour() const{ return m_hour; } const成员函数可以使用类中所有成员变量，但是不能修改它们的值 const成员函数声明和定义都必须使用const后缀 const对象只能调用const成员函数，不能调用非const成员函数 mutable mutable：容许在即便包含它的对象被声明为const时仍可修改声明为mutable的类成员。如果需要一部分成员变量能在const成员函数中修改(用于改变const对象)，可以加上mutable修饰： mutable bool flag; override与final 作用： override为虚函数覆盖，用来防止出现意外的继承行为。override说明编译器会检查该函数是否为虚函数，是否会覆盖父类中的虚函数，如果不是虚函数会报错。 void func() override{}; // 子类中使用 是在成员函数声明符之后使用时拥有特殊含义的标识符，其他情况下它不是保留的关键词，如果不能覆盖（不是虚函数、形参不对）会出错 如果没有用overide关键字，当虚函数返回类型或参数不一样时将会造成函数的隐藏而不是覆盖 覆盖的方法不能为private final用来防止类被继承(用于类定义类名后面)或成员函数被覆盖(用于成员函数后) class base final{}; void setname() final; explicit 作用：禁止隐式调用单参数的构造函数，包括： 禁止隐式调用拷贝构造函数complex c1(1, 2); complex c2 = c1 + 5; // 此时会隐式调用构造函数complex(5, imag=0) 禁止类对象之间的隐式转换(见转换函数) 一般而言，只有单参数的构造函数会用到explicit关键字 explicit指明构造函数不能作隐式类型转换，只能进行初始化和显式类型转换 用=进行初始化可看作拷贝初始化，初始化器是右值时可能会采取移动操作。省略=会将初始化变为显式初始化 ==单参数的构造函数应声明为explicit==，避免发生不必要的类型转换，更多可见转换函数class Clock{ public: explicit Clock(int d); }; using 作用：using可以在子类中使用本来无法使用的父类的成员，无论继承方式为private/protected，包括构造函数和析构函数 如果成员原本是公共的，可以直接使用B::func() 用using可以继承父类构造函数using A::A;，但是只能初始化继承的成员，即使继承了也不能成为子类构造函数， =default和=delete =default用于要求编译器生成一个默认构造函数，=default 可以写在声明处也可以写在定义处，也可以只声明 =delete用于指定编译器禁止该函数调用 在C++11之前，为了防止调用特定函数，需要把函数声明到private域并且不实现 禁止编译器使用默认生成的构造函数 也可用于类的成员函数，防止隐式类型转换 重载operator 操作符并指定=delete可以禁止该操作符，比如重载new可以禁止堆上初始化。 在模板特化中，用=delete过滤特定的形参类型 // 这两种类型可以只声明不实现 class A{ A()=default; void get(double)=delete; } "},"1.C++/3.类与对象/10.类的嵌套与组合.html":{"url":"1.C++/3.类与对象/10.类的嵌套与组合.html","title":"3.10 类的嵌套与组合","keywords":"","body":"嵌套类 嵌套类(nested class)：可以在一个类的内部嵌套声明另一个类，也称为成员类(member class) 嵌套类只是声明放在了外部类，增加了对外部类的访问权限（如果是private也限定了外部的实例化），同时也限定了命名空间，其他地方和普通类一模一样 class Tree{ //在Tree的内部声明Node类 class Node{ Node *right; Node *left; } } 内部类不会影响外部类的内存布局 内部类可以访问外部类的成员(包括private)，外部类不可访问内部类的成员 和其他类一样，内部类的声明和实现可以分离 ==note：注意和类的组合区分== 类的组合 类组合：类中的成员是另一个类的对象，实现更复杂的抽象。 class A{}; class B{ A a; }; 类组合的构造函数： 组合类不仅要对本类的成员数据初始化，也要在初始化列表中。初始化次序是成员在类体中定义的次序： Clock::Clock(对象成员形参，本类成员形参):对象1(参数)，对象2(参数), ...{ ... } 部件类最好有不带参数的默认构造函数。如果部件类要作为函数参数，需要有拷贝构造函数前向引用声明 前向引用声明作用：类只能先声明，后使用。如果两个类互相引用，应进行前向引用声明。前向引用声明只为程序引入一个标识符说明这是一个类，具体声明在其他地方。 ```cpp class B; //前向引用声明 class A{ public: void f(B b); B b2; //错误用法 B *b2; //正确的用法，并在构造函数中分配内存 }; class B{ public: void g(A a); A a2; }; ``` 在提供完整的类声明之前，可以用作函数参数，但不能声明该类的对象（因为需要空间大小位置，可以用指针），也不能在内联成员函数使用该类的对象 使用前向引用声明时，不能涉及类的任何细节，只能使用被声明的符号 "},"1.C++/4.函数/":{"url":"1.C++/4.函数/","title":"4. 函数","keywords":"","body":""},"1.C++/4.函数/1.函数.html":{"url":"1.C++/4.函数/1.函数.html","title":"4.1 函数","keywords":"","body":"函数声明与定义 规则： 函数声明 static inline auto/returntype func(const unsigned long int* const)->void const noexcept; 必选项：函数名，参数列表(可以为空)，返回类型 可选项： static链接说明 inline表示希望内联调用 constexpr返回类型为常量表达式时，可以在编译时求值 ->尾置返回类型，和auto结合使用，返回类型更加清晰 noexcept函数不允许抛出异常，，属性[[noreturn]]不会用常规调用、返回 函数内部不允许定义另一个函数 调用函数，必须先定义。定义是特殊的函数声明，需要给出函数体 函数名就是函数地址func，func、*func、&func三者等价 函数返回值 引用：可作为左值 列表初始化： return {\"1\", \"2\"}; // vector对象 返回数组指针： i. 使用类型别名: using arrT = int[10]; arrT func(int i); // 返回指向10个整数数组的指针 int (func(int i))[10]; // 不使用类型别名 ii. 尾置返回类型: auto func(int i) -> int()[10]; iii. 使用decltype int arr[10]; decltype(arr) func(int i); 函数调用 函数调用时申请栈空间，并将实参绑定到形参（分配空间），每次调用函数都是新的参数变量参数(static除外) 特殊函数 构造函数：严格来说不是函数，没有返回值，无法得到其地址，可以初始化基类和成员，初始化时自动调用 析构函数：用来销毁函数对象，无法得到其地址 函数对象：是对象不是函数，不能被重载，其operator()是函数 lambda表达式：匿名函数对象，定义函数对象的一种简写形式 "},"1.C++/4.函数/2.函数参数与返回值.html":{"url":"1.C++/4.函数/2.函数参数与返回值.html","title":"4.2 函数参数与返回值","keywords":"","body":"函数参数 参数传递：参数按从右到左的顺序压入堆栈，由主调函数caller负责维护堆栈（在调用之前将参数压入堆栈，调用完成后将参数弹出栈）。 值传递时，会产生中间临时变量，如果是传递对象，这个操作会构建新的临时对象，返回值同理，这些中间对象是不必要的 默认参数 作用：允许设置默认参数，在调用时可以省略实参 规则： 因为用来传送参数的堆栈是由主调函数维护的，所以实现可变参数的函数只能使用这种函数调用约定。默认参数在参数列表中只能按照从右到左的顺序，不能放在左边或中间（主调函数先push最右侧参数）； 函数同时存在声明和实现时，默认参数只能放在声明，而不能放在实现中； 默认参数可以为常量、全局符号(全局变量、函数名)。不定参数 1. 实参类型都相同 initializer_list类模板 ```cpp initializer_list ls;// 元素类型是string void error_msg(initializer_list ls){ for(auto beg = ls.begin(); beg != ls.end(); ++beg){ cout 2. 参数类型不同：[可变参数的模板] ...参数列表 (前两种不可用时) "},"1.C++/4.函数/3.函数重载.html":{"url":"1.C++/4.函数/3.函数重载.html","title":"4.3 函数重载","keywords":"","body":"函数重载 作用：可以存在同名函数，根据参数列表和返回类型的不同调用不同的函数。 规则： 用法： int func(int m); //不同参数类型和参数个数构成重载 int func(double m); int func(int m, int n); 函数名相同 参数个数不同/参数类型不同/参数顺序不同 仅根据返回类型不同不能重载函数，编译无法通过 在不同的作用域中无法重载，只会覆盖 有无const修饰可以用来重载函数，但仅限于底层const（顶层const和普通形参无法区分） 本质：采用了name mangling(name decoration)技术 编译器默认对符号名进行改编和修饰，重载时会生成不同的符号，不同编译器有不同的生成规则 函数重载的二义性 实参类型不同的重载函数，实参如果会发生隐式类型转换(如long和int)，可能会有二义性； 实参个数不同的函数重载，可能会和带默认参数的函数产生二义性（建议优先使用默认参数） 重载(overload)和覆盖(override)的区别 重载是在同一个类或作用域中，覆盖是在子类和父类中(不同作用域) 覆盖要求参数列表、返回类型必须相同，重载要求参数列表必须不同(返回类型可以不同) 覆盖的方法不能为private 当覆盖函数返回类型或参数不一样时，或者覆盖函数不是virtual函数，函数会隐藏而不是覆盖 "},"1.C++/4.函数/4.转换函数.html":{"url":"1.C++/4.函数/4.转换函数.html","title":"4.4 转换函数","keywords":"","body":"转换函数 转换函数(conversion function)：自定义类型转换函数，可以把目标类的类型转换为系统预定义类型的数据 ==注意：不同于其他运算符重载，转换函数没有返回类型，因为其返回类型在其操作符中== // 这是一个类的成员函数 operator type() const{ return type(); } 示例：自定义分数类转换成double类型 class Fraction { private: int numerator_; // 分子 int denomirator_; // 分母 public: Fraction(int numerator, int denomirator) :numerator_(numerator), denomirator_(denomirator){ }; // 转换函数 operator double() const{ return double(1.0*numerator_ / denomirator_); } }; 调用double时，会执行类型转换 Fraction f(3, 5); double d = 4 + f; //调用operator double()将f=3/5转换为0.6 非explicit单参数构造函数 当转换函数和非explicit单参数构造函数同时存在时，可能出现二义性造成编译错误 class Fraction { private: int numerator_; // 分子 int denomirator_; // 分母 public: // 加上默认参数，构成单参数构造函数 Fraction(int numerator, int denomirator=1) :numerator_(numerator), denomirator_(denomirator){ }; operator double() const{ return double(1.0*numerator_ / denomirator_); } Fraction operator+(){ return Fraction(...); } }; //in main() Fraction f(3, 5); // 编译器不知道调用构造函数将4转换为F(4,1), 然后调用operator+ // 还是Fraction d2 = 4.6，产生二义性 Fraction d2 = 4 + f; "},"1.C++/4.函数/5.运算符重载.html":{"url":"1.C++/4.函数/5.运算符重载.html","title":"4.5 运算符重载","keywords":"","body":"运算符重载 作用：给类的对象增加新的操作支持，例如可以通过重载四则运算符，使对象可以按指定的规则进行四则操作运算（针对自定义数据类型，不针对基本数据类型） 运算符重载是通过函数实现的，本质上是函数重载，可以将operator运算符看作函数名 。oprator是关键字，用来定义重载运算符的函数。 规则： 运算符重载的格式： A operator+(parm){} 运算符函数或者是类的成员，或者至少有一个类类型的参数。 双目运算符形参在参数表中的顺序任意，但在使用时左侧操作数需要与第一个参数对应，右侧操作数与第二个参数对应。数学上的交换律在此不适用，如果希望适用，应再次重载操作符并调整参数表顺序。 重载运算符的参数数量与该运算符作用的运算对象数量一样。当一个重载的运算符是成员函数时，左侧运算对象绑定到隐式的this指针上（函数体内用this作为参数）。因此成员运算符的显式参数数量比运算符运算对象少一个； 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变； 重载不能改变运算符的优先级和结合性； 运算符重载函数不能有默认的参数（否则就改变了运算符操作数的个数）。 注意： 如果希望表达式的临时对象不被赋值，可以将返回类型限定为const const A::operator+(const A& a){} a1 + a2 = a3; //会报错 在上述条件下，如果希望完成a = a1 + a2 + a3的功能，应该用const限定函数 const A::operator+(const A& a) const{} A a = a1 + a2 + a3; // 等价于a1.operator+(a2).operator(a3) // 但是a1.operator+(a2)返回const临时对象，const对象只能调用const函数 应该重载为成员函数的运算符 一般将单目运算符-a *a !a &a ++ --以及+=、-=、*=、/=（复合赋值运算符）重载为成员函数 箭头运算符->、下标运算符[]、函数调用运算符()、赋值运算符=只能以成员函数的形式重载 成员函数的运算符左侧会绑定到隐式this指针 应该重载为友元函数的运算符 一般将双目运算符重载为友元函数 不能重载的运算符 下列5个运算符不能被重载： :: .* . ?: sizeof 通常情况下，尽量避免逗号,、取地址&、逻辑与&&或and、逻辑或||或or运算符的重载 可以重载的运算符 + - * / % ^ & | ~ ! = += -= *= /= % = ^= &= |= > >= == != = && || ++ -- , ->* -> () [] new new[] delete delete[] class Point{ int x_; int y_; }; 示例1：重载+运算符 //以友元函数的形式重载`+` class Point{ public: friend const Point operator+(const Point &point1, const Point &point2); } const Point operator+(const Point &point1, const Point &point2) const{ return Point(point1.x_ + point2.x_, point1.y_ + point2.y_); } 示例2：重载复合赋值+=运算符 //以成员函数的形式重载+= Point &Point::operator+=(const Point &point){ x_ += point.x_; y_ += point.y_; return *this; } 示例3：重载 输出运算符应尽量减少格式化操作，以便让用户能控制输出的细节 class Point{ friend ostream &operator 示例4：重载>> 输入输出运算符必须是非成员函数，不能是成员函数，否则左侧运算对象将是当前对象，无法完成输入。 class Point{ friend istream &operator>(istream &is, Point &point){//对象要改变，参数不能为const is >> point.x_ >> point.y_; return is; } 示例5：重载[] 单目运算符必须以成员函数形式进行重载，[]是后置运算符 //不仅可以访问元素，还可以修改 int &operator[](int i){ return data_[i]; } //只能访问不能修改，为了适应const int& Array::operator[](int i) const int &Array::operator[](int i) const{ return data_[i]; } 示例6：重载++和-- 对++运算符以成员函数形式进行重载，有前置和后置两种形式 class Point{ Point &operator++(); //++i，前置形式。为了与内置保持一致应返回对象的引用 const Point Point::operator++(int); //i++，后置形式，参数int没有意义，只是为了区分前置和后置 }; Point &Point::operator++(){ x_ ++; y_ ++; return *this; } const Point Point::operator++(int n){ Point old(*this); x_ ++; y_ ++; return old; } 示例7：重载new和delete 可以以成员函数形式或全局函数形式重载new运算符，在重载new或new[]时，无论是作为成员函数还是作为全局函数，它的第一个参数必须是size_t类型。size_t表示的是要分配空间的大小，对于new[]的重载函数而言，size_t则表示所需要分配的所有空间的总和。 void * className::operator new(size_t size){//成员函数形式 ... } void * operator new(size_t size){//全局函数形式 ... } 重载delete运算符，两种重载形式的返回值都是void类型，并且都必须有一个void类型的指针作为参数，该指针指向需要释放的内存空间。 void className::operator delete( void *ptr){//成员函数形式 ... } void operator delete( void *ptr){//全局函数形式 ... } 示例8：重载*和ptr 见智能指针的实现 operator->(特殊行为, 指向符会继续作用下去不会被消耗掉)编译器将sp->解析为px-> "},"1.C++/4.函数/6.函数对象与lambda表达式.html":{"url":"1.C++/4.函数/6.函数对象与lambda表达式.html","title":"4.6 函数对象与lambda表达式","keywords":"","body":"函数对象类型是可用在函数调用运算符左侧的对象的类型 函数名和函数指针 函数指针：不同于函数或函数的引用，函数指针是对象，从而能存储于数组、被复制、被赋值等。 void f(int); void (*p1)(int) = &f; void (*p2)(int) = f; // 与 &f 相同 仿函数(functor) 作用：需要成员变量帮助完成功能或保存运行时的结果，而不借助函数参数和返回值。仿函数本质上是一个可以含有成员的函数 本质：就是一个重载了operator()操作符的类，概念上是函数的功能。 函数对象可以将附加数据保存在成员变量中，从而实现携带附加数据，而函数指针不行。 可以联合调用类内其他函数 使用：创建了对象后（栈上或临时对象），跟普通函数的使用一样 struct Output{ void operator()(int __n){ cout v(5,100);//初始化vector，5个元素，元素值均为100 //依次输出vector的元素，这里传入的不是函数指针，而是一个类 for_each(v.begin(),v.end(),Output{}; //通过临时对象传入仿函数 return 0; } // STL中for_each()函数可能实现： template UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f) { for (; first != last; ++first) { f(*first); } return f; // C++11 起隐式移动 } lambda表达式 作用： 函数指针和仿函数较复杂，lambda表达式简洁，不需要实现类 匿名内包的形式不会产生多余的函数名 代码表达能力强，提高代码清晰度 规则： 形式 [&a, b](int i) mutable{}noexcept -> int，最简单形式为[]{} []捕获列表，指明作用域中匿名函数可以使用的变量，以&为前缀的局部名字通过引用捕获，默认以值捕获=。 [&]捕获列表可以出现this， 不在列表中的变量隐式引用捕获 [=]捕获列表不可以出现this， 不在列表中的变量隐式值捕获 ()参数列表，mutable，noexcept，->尾置类型都为可选，和函数用法一样 值捕获无法修改捕获列表的变量(const)，可以使用引用捕获修改 定义值捕获匿名函数时，相当于捕获const常量，后面变量的值更改对函数没有影响，使用mutable相当于使用了局部变量，对外部变量没有影响 可以将lambda表达式赋值和函数指针，相当于定义函数auto func = [&](){...}; lambda用在成员函数，可以引用捕获把this添加到捕获列表，[this]通过指针访问，而非拷贝。[this]和[=]不兼容，所以在多线程中可能产生竞争。 泛型lambda(C++14) lambda表达式可以像模板函数一样实现泛型，根据传入的参数自动推导类型 auto add = [](auto x, auto y) { return x + y; }; int x = add(2, 3); // 5 double y = add(2.5, 3.5); // 6.0 "},"1.C++/4.函数/7.智能指针的实现.html":{"url":"1.C++/4.函数/7.智能指针的实现.html","title":"4.7 智能指针的实现","keywords":"","body":"智能指针 shared_ptr的实现 template class shared_ptr { public: // 构造函数 shared_ptr() :_ptr((T*)0), _pCount(new int(1)){} explicit shared_ptr(T* p) :_ptr(p), _pConut(new int(1)){} // 拷贝构造函数 shared_ptr(const shared_ptr& ap): _ptr(ap._ptr) , _pCount(ap._pCount){ ++(*_pCount); } private: T* _ptr; int* _pCount; }; // 拷贝赋值函数 template shared_ptr& shared_ptr::operator=(const shared_ptr& ap){ // 处理自我赋值 if (_ptr != ap._ptr){ // 先销毁原来指向的对象 if (--(*_pCount) == 0){ delete _ptr; delete _pCount; } // 重新指向新的对象和计数器 _ptr = ap._ptr; _pCount = ap._pCount; ++(*_pCount); } return *this; } // 析构函数 shared_ptr::~shared_ptr(){ if (--(*_pCount) == 0){ delete _ptr; delete _pCount; } } // 类指针行为的定义 template T& shared_ptr::operator*(){ return *_ptr; } template T* shared_ptr::operator->(){ return _ptr; } shared_ptr sp(new Foo); f(*sp);// 调用operator* sp->method();// 调用operator->(特殊行为, 指向符会继续作用下去不会被消耗掉)编译器将sp->解析为px-> weak_ptr的实现 template class weak_ptr { public: weak_ptr(const shared_ptr sp) :ptr(sp._ptr){} weak_ptr(const weak_ptr& wp) :ptr(wp.ptr){} weak_ptr& operator=(const weak_ptr& wp){ if (this != &wp){ ptr = wp.ptr; } return *this; } private: T* ptr; }; "},"1.C++/4.函数/8.operator的作用.html":{"url":"1.C++/4.函数/8.operator的作用.html","title":"4.8 operator的作用","keywords":"","body":" 重载操作符 见运算符重载 int operator+(); // operator+整体是函数名 转换类型 见转换函数 operator int(); //operator用作声明符 可以将任意类型转换为return的类型，如把成员函数转换为函数指针 "},"1.C++/5.泛型/":{"url":"1.C++/5.泛型/","title":"5. 泛型","keywords":"","body":""},"1.C++/5.泛型/1.模板.html":{"url":"1.C++/5.泛型/1.模板.html","title":"5.1 模板","keywords":"","body":"泛型和模板 作用：将类型参数化，以完成代码复用的目的 不同数据类型以及返回值的函数（如int和double），内在逻辑和代码可能是一样的，但是需要重载几种类型不同的函数，将会浪费很多时间在代码编写，C++提供泛型来完成这一功能的代码复用 提醒: 模板对应的参数在没有使用时，是不会实例化的 分离编译(.h文件和.cpp文件将声明和实现分离)时，编译器编译某个.cpp文件不知道其他.cpp文件，导致需要的模板类型不会实例化，引起链接错误 解决方式：将模板的声明和实现放在.hpp文件中 函数模板(Function Template) 可以将函数的返回类型以及形参类型参数化 规则： 用法： template //多参数模板头 void func(const T1 &a, onst T2 &b){}; 函数声明和实现分开时，都要加上模板头，使用typename/class没有区别 类型参数typename可以有多个，它们之间以,分隔。类型参数列表以<>包围，而形参列表以()包围 使用时需要在函数旁边指定类型，如func();，否则编译器会根据给定的数据推导数据类型（注意类模板不可以） func(1, 2.0); //自动推导为func() 类模板和函数模板都支持默认参数，C++11在之前只支持类模板默认参数 根据实际调用参数类型的不同，编译器实质上是生成了不同的重载函数。例如，用五个不同参数实例化一个函数模板，相当于新定义了五个重载函数，没有使用的类型不会实例化 类模板 作用：和函数模板类似，可以将数据的类型泛化。声明了类模板后，就可以将类型参数用于类的成员函数和成员变量。 规则： 用法： template class Point{ public: Point(T x,T y):x_(x), y_(y){} void get_point(); private: T x_; T y_; }; 类外实现成员函数时，如果函数里面使用了模板类型T，仍然需要带上模板头 template void Point::get_point(){} 类模板在实例化时必须显式地指明数据类型，编译器不能根据给定的数据推演出数据类型 在类外定义成员函数时，template后面的类型参数要和类声明时的一致，可以使用auto 和函数模板一样，模板类被实例化时实际产生一种新的类型，不同的参数实例化出不同的类型。 成员模板 成员模板：类(普通类或模板类)可以包含本身是模板的成员函数。 成员模板不能是virtual函数。 普通类的成员模板 与类模板的区别是，可以不用创建对象时指定模板参数 //完成一个删除器的仿函数，代替delete class Deleter{ public: Deleter(){}; //重载operator(), 构成函数对象 template void operator()(T* p) const{ deleter p; } } 类模板的成员模板 作用：使用模板拷贝构造函数，可以进行不同类型的类之间的类型转换，也可以在构造函数中用来作向上转型(父类智能指针指向子类对象) 在外部定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表 ```cpp template struct Point{ T x; T y; Point(T x,T y):x(x), y(y){} template Point(const Point& p): x(static_cast(p.x)), y(static_cast(p.y)){} } // 可以用double模板的类拷贝构造int模板的类 Point d1{1.0, 2.0}; Point d2(d1); template template Point::Point(){...} ``` "},"1.C++/5.泛型/2.模板特化与偏特化.html":{"url":"1.C++/5.泛型/2.模板特化与偏特化.html","title":"5.2 模板特化与偏特化","keywords":"","body":"模板特化 作用：也称为模板全特化，可以对某些特定的类型进行特殊的处理(例如某个算法对int类型的点有更快的处理方法) template struct hash{}; // 对int类型进行模板特化 template<> struct hash{ // ... }; 模板偏特化 参数偏特化 作用：多个模板参数时，对其中某个模板参数进行特化 template class Point{ // ... }; // 对TypeA进行偏特化 template class Point{ // ... }; 范围偏特化 作用：可以对模板参数的某种类型(例如指针)进行特化 template class C{}; // 对指针类型进行偏特化 template class C{ // ... }; // 两个对象初始化将执行不同地方的代码 C obj1; C obj2; "},"1.C++/5.泛型/3.模板模板参数.html":{"url":"1.C++/5.泛型/3.模板模板参数.html","title":"5.3 模板模板参数","keywords":"","body":"可变参数模板 // 出口函数 void print(){} template void print(const T& firstArg,const Types&... Args){ std::cout ...用于模板参数，是一个模板参数包 ...用于函数参数，是一个函数参数包 ...用于函数参数类型，是一个函数参数类型包 sizeof...(Args)，参数数量 模板模板参数 "},"1.C++/6.断言与异常/":{"url":"1.C++/6.断言与异常/","title":"6. 断言与异常","keywords":"","body":""},"1.C++/6.断言与异常/1.断言.html":{"url":"1.C++/6.断言与异常/1.断言.html","title":"6.1 断言","keywords":"","body":"assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行 assert(expression) "},"1.C++/6.断言与异常/2.异常.html":{"url":"1.C++/6.断言与异常/2.异常.html","title":"6.1 异常","keywords":"","body":"异常 异常：程序在运行过程中可能会发生的错误 抛出（Throw）--> 检测（Try） --> 捕获（Catch） try{ // 可能抛出异常的语句 }catch(Type1 var1){ // 处理异常的语句 }catch(const exception &exception){ //可以接收标准异常 // 处理异常的语句 }catch(...){ //接收任何异常 ... } 异常可以发生在当前的 try 块中，也可以发生在 try 块所调用的某个函数中，发生异常时会立即终止当前代码，如果当前函数没有catch处理时，异常会抛到上一层函数，直到有catch处理，或最后main()函数抛出异常程序终止 可以有多级catch，用于处理不同的异常返回类型，如果实参和形参的类型不是严格匹配，那么会将实参的类型进行适当的转换，抛出的异常值会赋值给形参 异常类 C++本身抛出的异常都是exception的子类，也就是标准异常 | 异常 | 描述 | | ----------------------- | ----------------------------------------------- | | std::exception | 该异常是所有标准 C++ 异常的父类。 | | std::bad_alloc | 该异常可以通过 new 抛出。 | | std::bad_cast | 该异常可以通过 dynamic_cast 抛出。 | | std::bad_exception | 这在处理 C++ 程序中无法预期的异常时非常有用。 | | std::bad_typeid | 该异常可以通过typeid 抛出。 | | std::logic_error | 理论上可以通过读取代码来检测到的异常。 | | std::domain_error | 当使用了一个无效的数学域时，会抛出该异常。 | | std::invalid_argument | 当使用了无效的参数时，会抛出该异常。 | | std::length_error | 当创建了太长的 std::string 时，会抛出该异常。 | | std::out_of_range | 该异常可以通过方法抛出。 | | std::runtime_error | 理论上不可以通过读取代码来检测到的异常。 | | std::overflow_error | 当发生数学上溢时，会抛出该异常。 | | std::range_error | 当尝试存储超出范围的值时，会抛出该异常。 | | std::underflow_error | 当发生数学下溢时，会抛出该异常。 | 可以使用多态接收标准异常，就不用考虑异常的类型 catch(const exception &exception){} 拦截所有异常 catch(...){} 自定义抛出异常 系统不一定会捕捉到所有的异常，此时可以在可能发生异常的位置自定义异常 throw exceptionData; 抛出异常可以是任何类型，包括class 异常抛出声明 为了增强可读性和方便团队协作，如果函数内部可能抛出异常，可以在函数名后面声明抛出的异常类型 void func(){} //可能抛出任何异常 void func() throw(int){} //可能会抛出int异常 void func() noexcept{} // 不会抛出任何异常 "},"1.C++/7.内存模型/":{"url":"1.C++/7.内存模型/","title":"7. 内存模型","keywords":"","body":""},"1.C++/7.内存模型/1.内存空间模型.html":{"url":"1.C++/7.内存模型/1.内存空间模型.html","title":"7.1 内存空间模型","keywords":"","body":"进程内存分布 32位系统的进程内存布局： Kernel space 内核区，供操作系统使用，用户代码不能读写该地址，往只读段读写会报段错误“segmentation fault\" Stack 栈区，每次调用函数会给它自动分配一段连续的栈空间，存放函数的返回地址、参数、局部变量、返回值、上下文（函数调用前后需要保持不变的寄存器），函数调用完自动分配和回收。从高地址向低地址增长，在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定 Memory Mapping Segment 将文件映射到内存或匿名映射，比如用于动态链接的共享库libgl.so的存放，可用于申请大内存 Heap（自由存储区） 堆区，在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长,堆的起始地址由mm_struct结构体中的start_brk标识，结束地址由brk标识。程序运行过程中，为了能自由控制内存的生命周期、大小，会经常使用堆空间内存 C++自由存储区new/delete运算符动态分配和释放空间的内存分区的抽象概念，new操作符申请的内存可以称为自由存储区，堆与自由存储区并不等价。一般C++编译器用堆来实现自由存储，也可以用其他内存 BSS segment BSS段，未初始化的静态变量（局部/全局）和全局变量会存放在bss段，并自动被初始化为0，未指定初始化的全局变量和静态变量（包括类的对象），都会自动被初始化为0 tips：自定义了构造函数的类，显示指定了初始化的变量会被初始化为指定值，其他值初始化为0 Data segment 数据段（全局区），用于存放已初始化的全局变量、静态变量 Text segment 代码段，包括文本区和存储区，文本区存储文字常量（包括符号常量和字面常量），存储区用于存放程序的镜像机器代码，只读 参考书籍上说字符串常量不在代码区，存储在常量区，从代码分析可认为几乎是同一个区 内存地址分析 static int a = 1; int b = 3; static int c; int d; void hello(){} int main() { int e; // a, b地址相邻，说明已初始化的静态变量a和全局变量b在同一区域Data segment cout ELF文件格式 Linux系统上可执行文件为ELF文件 数据段 说明 ELF头 固定长度，索引到表 程序头表 可选，记录文件节装载到内存段的位置 .init节 .text节 代码段 .rodata节 只读数据 .data节 已初始化全局变量 .bss节 未初始化全局变量 .systab节 符号表 ... 其他 .strtab节 字符串表 节头表 索引到节 "},"1.C++/7.内存模型/2.new和delete.html":{"url":"1.C++/7.内存模型/2.new和delete.html","title":"7.2 new和delete","keywords":"","body":"new和delete new/delete、new[]/delete[]位于头文件中，返回类型为指向其类型初始化对象的指针，不负责初始化得到的内存 new操作符 作用： 规则： void *operator new(size_t); void *operator new[](size_t); 先分配内存，再调用ctor(构造函数)，内部调用malloc() Complex* pc = new Complex(1, 2); // 编译器自动转换为 Complex *pc; void* mem = operator malloc(sizeof(Complex));//内部调用malloc pc = static_cast(mem); pc->Complex::Complex(1, 2); //这里说明new会调用构造函数，malloc不会调用 没有多余内存时会抛出bad_alloc异常，有的程序不允许异常，可以使用noexcept版本： void *oparator new(size_t, const nothrow_t&) noexcept; void *oparator delete(void *pt, const nothrow_t&) noexcept; int *p = new(nothrow) int[10]; delete(nothrow, p); 在指定地方分配对象： void *operator new(size_t, void *p){return p;} X *p = new{buf} X; // 在buf处构建X delete操作符 作用：将指定地址的内存回收 注意：内存回收并不是将那部分内存清零，而是告诉操作系统这部分内存使用完，可以标记为空闲，供下一个申请内存的程序使用 void *operator delete(void *p); void *operator delete[](void *p); 先调用dtor析构函数，再释放内存，内部调用free() delete和delete[] new[]一定要搭配delete[]，否则会造成少调用析构函数 string *p = new string[3]; ... delete[] p; //调用3次dtor string *p = new string[3]; ... delete p; //调用1次dtor new/delete和malloc/free的区别 特征 new/delete malloc/free 分配内存的位置 自由存储区 堆 申请成功返回值 完整类型指针 void* 申请失败返回值 默认抛出异常 返回NULL 分配内存的大小 根据类型自动 必须显式指定字节数 申请数组 有处理数组的new版本new[] 显式计算数组的字节数后进行内存分配 扩充内存 无法直观地处理 realloc() 相互调用 可以，看具体的operator new/delete实现 不可调用new 分配内存时内存不足 客户能够指定处理函数或重新制定分配器 用户代码无法处理 函数重载 允许 不允许 构造与析构函数 调用 不调用 tips： new/delete和malloc/free成对使用，不要混合使用 当使用free()释放new申请的内存时，可能会导致没有调用对象的析构函数 C++没有规定new实现的标准，有的编译器可能不是使用malloc()实现； operator new被重载，可能会引发其他的错误 "},"1.C++/7.内存模型/3.内存对齐.html":{"url":"1.C++/7.内存模型/3.内存对齐.html","title":"7.3 内存对齐","keywords":"","body":"1. 内存对齐 对齐规则： #pragram pack(n) 表示的是设置n字节对齐，VC默认8，gcc默认4 结构体内数据成员对齐，偏移量 = min(当前数据成员, n)，当前数据成员必须在这个数的倍数的地址上 结构体对齐，整个结构体大小一定是min(max(数据成员), n)的倍数 #pragma pack(4) class Data1 { char c; // 偏移量在1 }; // 内存布局为 1 class Data2 { char c; // 偏移量在1 int a; // 偏移量在4 char d; // 偏移量在9 // 整体为4的倍数 }; // 内存布局为 1 _ _ _ | 4 4 4 4 | 1 _ _ _ class Data3 { char c; // 偏移量在1 int a; // 偏移量在4 char c2; // 偏移量在9 double d; // 偏移量在16 // 整体为4的倍数 }; // 内存布局为 1 _ _ _ | 4 4 4 4 | 1 _ _ _ | 8 8 8 8 8 8 8 8 | cout "},"1.C++/7.内存模型/4.智能指针.html":{"url":"1.C++/7.内存模型/4.智能指针.html","title":"7.4 智能指针","keywords":"","body":"智能指针 作用：智能指针自身被销毁时，会自动销毁指针指向的对象。智能能自动管理内存，实现RAII。 规则： 智能指针不能指向栈空间对象，否则会free两次 指向数组时，泛型应该使用数组shared_ptr ptr = new int[]{1,2}; 1. shared_ptr 多个shared_ptr可以指向同一个对象，没有智能指针指向对象时才会销毁对象 智能指针的实现 规则： 初始化：shared_ptr sptr(new int{}); //构造函数初始化 shared_ptr sptr = new int{}; //移动赋值初始化 // 还有拷贝构造函数、拷贝赋值函数初始化等 shared_ptr sptr = make_shared (8); // make_shared初始化 sptr.reste(); // 重置指针为空 sptr.reset(new int{1}); //使用reset重置为新的内存 智能指针的使用和普通指针一样，使用->和* shared_ptr是强引用指针，只要存在shared_ptr指向对象，对象便不会被析构 由引用计数实现，当计数为0时才销毁指向的对象 智能指针属性包含两个指针的结构：一个指向对象，一个指向计数器 shared_ptr的缺点： 用同一个裸指针初始化多个shared_ptr对象时，会造成同一个指针的多次析构(例如在函数中返回this指针的智能指针对象) 循环引用可能造成内存泄漏 shared_ptr的循环引用 当存在循环链表（循环链表内部也使用shared_ptr）时，指向链表的外部shared_ptr消亡时，由于此时引用计数为2，析构函数不会delete堆空间链表对象，造成内存泄漏 2. weak_ptr 作用：weak_ptr不能直接使用，weak_ptr用于打破shared_ptr的循环引用问题，以及多个裸指针初始化的多次析构问题 weak_ptr只能通过shared_ptr或weak_ptr构造，没有类似于shared_ptr重载operator*和->，不能对资源进行操作 weak_ptr是弱引用指针对象，不会增加shared_ptr的引用计数 wptr.use_count(); //查看shared_ptr的引用计数 wptr.expired(); // 查看指向的内存有没有被释放 sptr = wptr.lock(); //如果expired()为true，返回一个空shared_ptr，否则返回非空shared_ptr 针对多个裸指针初始化的多次析构问题(例如在函数中返回this的智能指针)，可以使用weak_ptr指向管理this的shared_ptr，再使用lock()方法返回共享的智能指针 可以直接使用std::enable_shared_from_this<>模板类解决 3. unique_ptr unique_ptr也是强引用，但 同一时间只能有一个unique_ptr指向对象 拥有一个对象，保存一个指针，并负责用释放器销毁对象 不能拷贝，但可以移交所有权p2 = std::move(p1); 4. auto_ptr 自C++11开始已经弃用 "},"1.C++/7.内存模型/5.内存泄漏.html":{"url":"1.C++/7.内存模型/5.内存泄漏.html","title":"7.5 内存泄漏","keywords":"","body":"// TODO RAII资源获取是初始化 RAII（Resource Acquisition Is Initialization） RAII 可以帮助我们将管理堆上的内存，简化为管理栈上的内存，从而达到利用编译器自动解决内存回收问题的效果 智能指针 "},"1.C++/7.内存模型/6.虚函数表与虚指针.html":{"url":"1.C++/7.内存模型/6.虚函数表与虚指针.html","title":"7.6 虚函数表与虚指针","keywords":"","body":"虚函数表与虚指针 虚函数底层实现：每个类对象中都存在一个虚函数表指针vfptr指向当前类的虚函数表vtbl，虚函数表中存储着对应虚函数的地址，同一个类的不同对象共用同一份虚函数表，编译时期创建。 同一个类的对象，共用同一份虚表 父类的虚函数，子类没有实现时，子类虚函数表仍拥有对应虚函数（子类也拥有该虚函数） 存在继承的情况：继承类的虚函数表被加在基类的后面，多继承时哪个类拥有虚函数，位置就越靠前，同时虚函数表加到该基类后面。如果基类都没有虚函数则直接指向当前类的虚函数表。 类B继承于A，A中存在虚函数vfunc1()和vfunc2()，B中覆盖了A中的虚函数vfunc1()和非虚成员函数func2()，如下述代码所示： class A{ public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int data1_; }; class B:public A{ public: virtual void vfunc1(); void func2(); private: int data2_; }; 虚函数表和虚函数的地址 A obj{}; int *vfptr = *(int*)*(int*)&obj; //第一个虚函数地址 printf(\"Address of vfunc2: %p\\n\", *(vfptr + 1)); // 第二个虚函数地址 虚函数表vtbl的结构模型 橙色线框中的内容仅限于虚拟继承的情形（若无虚继承，则无此内容） “offset to top”是指到对象起始地址的偏移值，只有多重继承的情形才有可能不为0，单继承或无继承的情形都为0。 “RTTI information”是一个对象指针，它用于唯一地标识该类型。 “virtual function pointers”也就是我们之前理解的虚函数表指针，其中存放着虚函数指针列表。 虚函数指针__vfptr位于所有的成员变量之前定义 "},"1.C++/7.内存模型/7.虚继承的虚基表.html":{"url":"1.C++/7.内存模型/7.虚继承的虚基表.html","title":"7.7 虚继承的虚基表","keywords":"","body":"虚基表内容： 虚基表指针与类起始地址的偏移量（虚基表指针的相对位置，一般是0） 属于虚基类的成员变量与当前类起始地址的偏移量 "},"1.C++/7.内存模型/8.类对象大小和空基类优化.html":{"url":"1.C++/7.内存模型/8.类对象大小和空基类优化.html","title":"7.8 类对象大小和空基类优化","keywords":"","body":"2. 类对象大小 类对象的大小 ： 数据成员的总和 + vfptr指针大小 + vbptr指针大小 + 编译器内存对齐增加的字节。 包括父类的非static数据成员，不包括所有的成员函数。虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类象的存储空间的 空基类优化，空类、单一继承的空类、多重继承的空类所占空间大小为：1字节 当类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器自动在对象里安插一个指针vPtr指向虚函数表VTable，多继承下可能不止一个，单继承时虚函数个数不会影响类对象大小； 虚承继的情况：由于涉及到虚函数表和虚基表，会同时增加一个（多重虚继承下对应多个）vfPtr指针指向虚函数表vfTable和一个vbPtr指针指向虚基表vbTable，这两者所占的空间大小总共为：8（或8乘以多继承时父类的个数）； 3. 空基类优化： 作用：当存在空的基类子对象，子类可以将其默认规定的占位字节忽略 为保证同一类型的不同对象地址始终有别，要求任何对象或成员子对象的大小至少为 1，即使该类型是空的类。 然而，空基类的子类对象不受这种制约，而且可以完全从对象布局中被优化掉 例外：第一个非静态数据成员为空基类对象时，禁用空基类优化 #include struct Base {}; // 空类 struct Derived1 : Base { int i; }; struct Derived2: Base { Base a; int i; } int main() { // 任何空类类型的对象大小至少为 1 assert(sizeof(Base) > 0); // 应用空基类优化，判定为True assert(sizeof(Derived1) == sizeof(int)); // 第一个非静态数据成员为空基类对象时，禁用空基类优化 assert(sizeof(Derived2) == 2*sizeof(int)); } "},"1.C++/8.STL标准库/":{"url":"1.C++/8.STL标准库/","title":"8. STL标准库","keywords":"","body":"STL索引 STL详细文档 "},"1.C++/8.STL标准库/1.STL容器与适配器.html":{"url":"1.C++/8.STL标准库/1.STL容器与适配器.html","title":"8.1 STL容器与适配器","keywords":"","body":"STL容器与适配器 1. 容器的分类 标准容器的成员函数 1.1 常用数据结构 数据结构 常用操作 单向链表forward_list push_front/pop_front/front/empty/双向迭代器，不支持随机访问 双链表 list front/push_front/pop_front/back/push_back/pop_back/size/empty支持双向迭代器，不支持随机访问 双端队列deque 双端队列deque 1.2 关联容器 关联容器 说明 字典map/multimap key-value对的集合，按key排序map键值唯一，multimap键值对可以重复/不同 底层实现为红黑树 无序字典unordered_map key-value对的无序集合 底层实现为哈希表 集合set/ multiset key的集合，按key排序 set键唯一，multiset键可以重复 底层实现为红黑树 无序集合unordered_set key的集合，无序 底层实现为哈希表 2. 适配器 适配器是容器遵循特定规则的一种机制 | 容器 | 说明 | | ---------------- | ------------ | | 栈stack | 元素先进后出 | | 队列queue | 元素先进先出 | | priority_queue | 优先队列(堆) | 3. 迭代器 3.1 迭代器类型 迭代器 类型 begin()/cbegin() 起始迭代器 ，指向起始元素c表示常量迭代器，不可以修改元素值 end()/cend() 末尾迭代器，指向末尾元素的后一个位置 rbegin()/crbegin() 逆向迭代器 rend()/crend() 逆向末尾迭代器 3.2 迭代器操作 操作 说明 + / - / ++ / -- / * / -> 和指针用法一样 advance(p, n) 使迭代器 p 向前或向后移动 n 个元素。 distance(p, q) 计算两个迭代器之间的距离，即迭代器 p 经过多少次 ++ 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环。 iter_swap(p, q) 用于交换两个迭代器 p、q 指向的值。 3.3 迭代器支持的容器 容器 迭代器功能 vector 随机访问 deque 随机访问 list 双向 set / multiset 双向 map / multimap 双向 stack 不支持迭代器 queue 不支持迭代器 priority_queue 不支持迭代器 3.4 使用迭代器遍历 标准库容器（如vector）都可以使用迭代器（string不属于容器，但支持迭代器） 访问安全，但性能比指针低 vector arr(3); auto b = arr.begin();//类似于指针类型，使用方法和指针一样 auto e = arr.end();//尾后迭代器（尾迭代器的下一位置） // 使用迭代器进行迭代 for(auto it = b; it != b; ++it){ ... } // 迭代器运算 iter += n //向前移动n个元素 iter -= n //向后移动n个元素 iter1 - iter2 //距离 有些容器没有定义运算符，但是都定义了==和!=，使用迭代器和!=就不用在意容器的类型 向容器添加元素或删除元素将会使迭代器失效。每次改变容器后都得正确的重新定位迭代器，原来位置的迭代器值未知 "},"1.C++/8.STL标准库/2.字符串string.html":{"url":"1.C++/8.STL标准库/2.字符串string.html","title":"8.2 字符串string","keywords":"","body":"字符串string 1. 构造函数 支持拷贝构造、复制构造、移动构造、初始化列表构造 string不同于C风格字符串，末尾没有'\\0'，长度为真实长度 #include std::string s; //空字符串 string s(\"Cplusplus\") ; // \"Cplusplus\" 等价于初始化列表构造{\"Cplusplus\"} string s(\"Cplusplus\", 5); // \"Cplus\" 取字符串前n个字符 string s(5, 's'); // \"sssss\" 字符*n，只支持单个字符 string s = R\"(\\hello)\"; // \"\\hello\" 原始字符串 原始字符串 R\"(...)\"，括号内就是原始的字符串，不需要用转义符号\\代表特殊符号 原始字符串可以自定义定界符R\"xxx(string)xxx\" string s = R\"***(\"hello\"(()())***\"; // 自定义定界符 )***\"这一部分，)和\"中间可以是任意符号，但是必须和\"***(匹配 字符串哈希 std::hash{}(str); 2. 常用操作 2.1 操作符 操作 操作符 下标访问 operator [] 拼接 operator + / operator += 比较 operator == (!= > 相关操作符C++20中移除) 2.2 元素访问 string支持双向迭代器 | 成员函数 | 说明 | | --------------------- | --------------------------------- | | at(i)/operator [] | 访问任意位置字符 | | front() | 首字符 | | back() | 尾字符 | | c_str() | 返回const char*数组，有访问范围 | | data | 返回char*数组首指针，有访问范围 | 2.3 容量 成员函数 说明 empty() 判断是否为空字符串 size()/length() 字符串长度 capacity() 当前分配的空间能保存的字符数量 shrink_to_fit() 释放没有分配字符的空间 2.4 字符串查找 字符串查找没找到时，返回npos | 成员函数 | 说明 | | ---------------------------------- | ----------------------------------- | | find()/rfind() | 查找子串，返回首次出现位置 | | substr() | 返回指定范围的子串 | | find_first_of()/find_last_of() | 匹配字符首字符/尾字符在模式串中位置 | 2.5 字符串修改 成员函数 说明 insert() 在指定位置插入字符 erase() 移除指定位置字符 clear() 清空字符串 push_back() 附加字符到末尾 append() 附加字符/字符串到末尾 pop_back() 移除末尾字符，返回void replace() 替换指定位置/范围的字符或字符串 2.6 C风格字符操作 #include 2.6.1 字符判断 函数 说明 int isalnum(int ch) 是否为字母或数字 int isalpha(int ch) 是否字母 int islower(int ch) 是否小写 int isupper(int ch) 是否大写 int isdigit(int ch) 是否十进制 int isxdigit(int ch) 是否十六进制 int isspace(int ch) 是否空白字符 int ispunct(int ch) 是否为标点 2.6.2 字符串操作 函数 说明 tolower() 字符转小int tolower(int ch)写 toupper() 字符转大int toupper(int ch)写 strcpy() 字符串拷贝 char* strcpy(char* dest, const char* src) strncpy() 拷贝n个字符 strcat() 字符串连接 strncat() 连接n个字符 memcpy() 内存复制，可以复制字符串void* memcpy( void* dest, const void* src, std::size_t count) memset 以某个字节填充内存 memmove() 内存移动 2.6.3 字符串校验 函数 说明 strlen() 字符串长度 strcmp() 字符串比较 strstr() 寻找子串 3. 字符串与数值的转换 3.1 字符串转数字 转换为整数时，可以指定进制base，将\"0x16\"或\"08\"字符串转换为十进制整数 | 公共函数 | 说明 | | ---------------- | ------------------------------------ | | stoi(string) | 将string转换为int | | stol(string) | 将string转换为long | | stoll(string) | 将string转换为long long | | stoul(string) | 将string转换为unsigned long | | stoull(string) | 将string转换为unsigned long long | | stof(string) | 将string转换为float | | stod(string) | 将string转换为double | | stold(string) | 将string转换为long double | int stoi(const std::string& str, std::size_t* pos = 0, int base = 10 ); 3.2 数字转字符串 公共函数，其中type为上述字符串转数字中的类型 std::string to_string(type) 4. 字符串分割split C++没有提供字符串分割的函数，可以用以下几种方式实现 4.1 istringstream 适用于用空格' '分隔的字符串 4.2 自实现 void split(const string& s, vector& tokens, const string& delimiters = \" \") { auto lastPos = s.find_first_not_of(delimiters, 0); auto = s.find_first_of(delimiters, lastPos); // string:npos是个特殊值，说明查找没有匹配 while (string::npos != pos || string::npos != lastPos) { //use emplace_back after C++11 tokens.push_back(s.substr(lastPos, pos - lastPos)); lastPos = s.find_first_not_of(delimiters, pos); pos = s.find_first_of(delimiters, lastPos); } } 4.3 使用c语言函数 注意：strtok()会破坏原有字符串，而且每次返回一个子串，需要多次调用 #include // 原型 char * strtok(char *s, const char *delim); char c_str[100]; strcpy(c_str,d.c_str()); str1 = strtok(c_str, \" \"); str2 = strtok(c_str, \" \"); 4.4 Boost库支持 #include boost::split( vStr, s, boost::is_any_of( \",/\" ), boost::token_compress_on ); "},"1.C++/8.STL标准库/3.动态数组vector.html":{"url":"1.C++/8.STL标准库/3.动态数组vector.html","title":"8.3 动态数组vector","keywords":"","body":"动态数组vector 作用：封装任何类型的动态数组，自动创建、释放内存，并提供数字下标越界检查 1. 构造函数 支持拷贝构造、复制构造、移动构造、初始化列表构造 vector对象可以高效添加元素，在初始时设定大小可能效率更差 #include std::vector a; //空vector std::vector a(n); //建立大小为n的int数组（vector） std::vector arr {1, 2, 3,}; //初始化列表构造 std::vector arr(arr_other.begin(), arr_other.begin()+2);//迭代器范围构造 vector a(n, 1);//n个元素全初始化为1 2. 常用操作 2.1 操作符 操作 操作符 下标访问 operator [] 比较 operator == (!= > 相关操作符C++20中移除) 2.2 元素访问 vector支持双向迭代器 成员函数 说明 at(i)/operator [] 访问任意位置元素 front() 首位置元素 back() 尾位置元素 data 返回内存中数组第一个元素的指针，有访问范围 2.3 容量 成员函数 说明 empty() 判断数组是否为空 size() 数组元素数量 capacity() 当前分配的空间能保存的元素数量 shrink_to_fit() 释放没有分配元素的空间 2.5 修改元素 成员函数 说明 insert() 在指定位置插入元素 erase() 移除指定位置元素 push_back() 在数组末尾插入元素 pop_back() 移除末尾元素，返回void(不返回元素值) emplace_back() 使用参数调用泛型对应的构造函数，插入到数组末尾 该方法不会产生临时对象，效率较高 clear() 清空数组 assign() 容器赋值，使用方法和构造函数一样 "},"1.C++/8.STL标准库/4.字典.html":{"url":"1.C++/8.STL标准库/4.字典.html","title":"8.4 字典","keywords":"","body":"1. 字典map 作用：存储key-value对，并对key排序，提供O(logn)复杂度的数据查找和插入，底层实现为红黑树 1.1 构造函数 #include std::map map1;//默认构造 map1[\"a\"] = 1; //插入元素 std::map map2{ {\"a\",1},{\"b\",2} }; // 初始化列表构造,初始化列表对应参数会自动绑定到泛型对应的构造函数 // 支持迭代器范围构造 2.1 常用操作 2.1.1 操作符 操作 操作符 下标访问 operator [] 比较 operator == (!= > 相关操作符C++20中移除) 2.1.2 元素访问 map支持双向迭代器 成员函数 说明 at(key) 访问key对应的value，不存在会抛出异常 operator [] 返回键key值的引用，如果不存在key则插入,value默认为空 2.1.3 容量 成员函数 说明 empty() 判断是否为空字典 size() 字典中元素个数 2.1.4 查找 成员函数 说明 count(key) 统计字典中key的数量,0或1 find(key) 查找key，返回迭代器，没找到返回尾迭代器end() contains(key) 字典是否包含key upper_bound() 返回指向首个大于给定键的元素的迭代器 lower_bound() 返回指向首个不小于给定键的元素的迭代器 equal_range() 返回匹配特定键的元素范围 2.1.5 修改元素 成员函数 说明 insert() 插入key-value对 erase() 移除指定元素，可以根据key、位置、范围移除 emplace_back() 使用参数调用泛型对应的构造函数原位构造，插入到字典中 该方法不会产生临时对象，效率较高 try_emplace() 若键不存在原位构造键值对，插入到字典中；若存在不做任何事(也不会更新value) (C++17) clear() 清空字典 extract(key) 从字典中释放出一个键值对,返回其引用extract是更换map的键而不重分配的唯一方式(C++17) merge(map2) 合并map2到当前字典，不存在的键值对会被移动已存在则不合并(C++17) 2.1.6 插入元素的方式 插入元素的方式： 初始化列表插入(推荐) 下标方式插入 插入pair元素 map和unordered_map利用std::pair存储键值对，插入时应该插入pair对象（或使用初始化列表将参数传入到pair的构造函数） 遍历map时，对于每一个pair可以访问pair.first和pair.second代表key和value map1.emplace_back(\"a\", 1); //emplace_back方法插入 map1.insert({\"a\", 1}); // 初始化列表插入 map1[\"a\"] = 1; // 下标方式插入，如果本来就存在则会更新value map1.insert(pair(\"a\", 1); //pair方式插入 map1.insert(make_pair(\"a\", 1); //make_pair方式插入 2. 无序字典unordered_map 和map的区别 没有顺序，不按key排序，底层实现为哈希表 只支持单向迭代器 没有范围查找lower_bound()和upper_bound() 增加了哈希表相关的接口 2.1 哈希桶接口 成员函数 说明 bucket(key) 返回带有特定key的桶的编号 bucket_size(bucket) 返回特定桶中的键值对数量 bucket_count() 返回桶的数量 max_bucket_count() 返回桶的数量 begin(bucket)/end() 返回指定的桶的迭代器 2.2 哈希策略 成员函数 说明 load_factor() 返回每个桶的平均键值对数量 max_load_factor() 返回每个桶的平均键值对数量 rehash(count) 设置桶数为count，并重哈希 "},"1.C++/8.STL标准库/5.集合.html":{"url":"1.C++/8.STL标准库/5.集合.html","title":"8.5 集合","keywords":"","body":"// TODO 与map的区别： set只有key，map存储key-value set不提供[]和at "},"1.C++/8.STL标准库/6.常用STL算法.html":{"url":"1.C++/8.STL标准库/6.常用STL算法.html","title":"8.6 常用STL算法","keywords":"","body":"STL通用算法 中函数都是函数模板在元素范围上操作，范围定义为[first, last) 不修改序列的操作 函数 作用 all_of()any_of()none_of() (C++11)检查谓词是否对范围中所有、任一或无元素为true for_each() 应用函数到范围中的元素 for_each_n() (C++17)应用一个函数对象到序列的前 n 个元素 count() count_if() 返回满足指定判别标准的元素数 mismatch() 寻找两个范围出现不同的首个位置 find()find_if()find_if_not() (C++11)寻找首个满足特定判别标准的元素 find_end() 在特定范围中寻找最后出现的元素序列 find_first_of() 搜索元素集合中的任意元素 adjacent_find() 查找首对相邻的相同（或满足给定谓词的）元素 search() 搜索一个元素范围 search_n() 在范围中搜索一定量的某个元素的连续副本 修改序列的操作 函数 作用 copy()copy_if() (C++11)将某一范围的元素复制到一个新的位置 copy_n() (C++11)将一定数目的元素复制到一个新的位置 copy_backward() 按从后往前的顺序复制一个范围内的元素 move() (C++11)将某一范围的元素移动到一个新的位置 move_backward (C++11)按从后往前的顺序移动某一范围的元素到新的位置 fill() 将一个给定值复制赋值给一个范围内的每个元素 fill_n() 将一个给定值复制赋值给一个范围内的 N 个元素 transform() 将一个函数应用于某一范围的各个元素 generate() 将相继的函数调用结果赋值给一个范围中的每个元素 generate_n() 将相继的函数调用结果赋值给一个范围中的 N 个元素 remove()remove_if() 移除满足特定判别标准的元素 remove_copy()remove_copy_if() 复制一个范围的元素，忽略满足特定判别标准的元素 replace()replace_if() 将所有满足特定判别标准的值替换为另一个值 replace_copy()replace_copy_if() 复制一个范围内的元素，并将满足特定判别标准的元素替换为另一个值 swap() 交换两个对象的值 swap_ranges() 交换两个范围的元素 iter_swap() 交换两个迭代器所指向的元素 reverse() 逆转范围中的元素顺序 reverse_copy() 创建一个范围的逆向副本 shift_left()shift_right() (C++20)迁移范围中的元素 rotate() 旋转范围中的元素顺序 rotate_copy() 复制并旋转元素范围 random_shuffle()shuffle() (C++17 前)(C++11)随机重排范围中的元素 sample() (C++17)从一个序列中随机选择 n 个元素 unique() 移除范围内的连续重复元素 unique_copy() 创建某范围的不含连续重复元素的副本 划分操作 函数 作用 is_partitioned() (C++11)判断范围是否已按给定的谓词划分 partition() 将范围中的元素分为两组 partition_copy() (C++11)复制一个范围，将各元素分为两组 stable_partition() 将元素分为两组，同时保留其相对顺序 partition_point() (C++11)定位已划分范围的划分点 排序操作 函数 作用 is_sorted()(C++11) 检查范围是否已按升序排列 is_sorted_until()(C++11) 找出最大的已排序子范围 sort() 将范围按升序排序 partial_sort() 排序一个范围的前 N 个元素 partial_sort_copy() 对范围内的元素进行复制并部分排序 stable_sort() 将范围内的元素排序，同时保持相等的元素之间的顺序 nth_element() 将给定的范围部分排序，确保其按给定元素划分 二分搜索操作 函数 作用 lower_bound() 返回指向第一个不小于给定值的元素的迭代器 upper_bound() 返回指向第一个大于给定值的元素的迭代器 binary_search() 确定元素是否存在于某范围中 equal_range() 返回匹配特定键值的元素范围 集合操作（已排序范围） 函数 作用 merge() 归并两个已排序的范围 inplace_merge() 就地归并两个有序范围 includes() 若一个集合是另一个的子集则返回true set_difference() 计算两个集合的差集 set_intersection() 计算两个集合的交集 set_symmetric_difference() 计算两个集合的对称差 set_union() 计算两个集合的并集 堆操作 函数 作用 is_heap() 检查给定范围是否为一个最大堆 is_heap_until() (C++11)查找能成为最大堆的最大子范围 make_heap() 从一个元素范围创建出一个最大堆 push_heap() 将一个元素加入到一个最大堆 pop_heap() 从最大堆中移除最大元素 sort_heap() 将一个最大堆变成一个按升序排序的元素范围 最大/最小操作 函数 作用 max() 返回各给定值中的较大者 max_element() 返回范围内的最大元素 min() 返回各给定值中的较小者 min_element() 返回范围内的最小元素 minmax() (C++11)返回两个元素的较小和较大者 minmax_element() (C++11)返回范围内的最小元素和最大元素 clamp() (C++17)在一对边界值间夹逼一个值 比较操作 函数 作用 equal() 确定两个元素集合是否是相同的 lexicographical_compare() 当一个范围按字典顺序小于另一个范围时，返回true lexicographical_compare_three_way() (C++20)用三路比较比较两个范围 排列操作 函数 作用 is_permutation() (C++11)判断一个序列是否为另一个序列的排列 next_permutation() 产生某个元素范围的按字典顺序的下一个较大的排列 prev_permutation() 产生某个元素范围的按字典顺序的下一个较小的排列 数值运算 函数 作用 iota() 用从起始值开始连续递增的值填充一个范围 (C++11) accumulate() 对一个范围内的元素求和 inner_product() 计算两个范围的元素的内积 adjacent_difference() 计算范围内各相邻元素之间的差 partial_sum() 计算范围内元素的部分和 reduce() 类似std::accumulate，但不依序执行(C++17) exclusive_scan() 类似std::partial_sum，第 i 个和中排除第 i 个输入(C++17) inclusive_scan() 类似std::partial_sum，第 i 个和中包含第 i 个输入(C++17) transform_reduce() 应用一个函数对象，然后以乱序规约(C++17) transform_exclusive_scan() 应用一个函数对象，然后进行排除扫描(C++17) transform_inclusive_scan() 应用一个函数对象，然后进行包含扫描(C++17) 为初始化内存上的操作 函数 作用 uninitialized_copy() 将范围内的对象复制到未初始化的内存区域 uninitialized_copy_n() 将指定数量的对象复制到未初始化的内存区域(C++11) uninitialized_fill() 复制一个对象到以范围定义的未初始化内存区域 uninitialized_fill_n() 复制一个对象到以起点和计数定义的未初始化内存区域 uninitialized_move() 移动一个范围的对象到未初始化的内存区域(C++17) uninitialized_move_n() 移动一定数量对象到未初始化内存区域(C++17) uninitialized_default_construct() 在范围所定义的未初始化的内存区域以默认初始化构造对象(C++17) uninitialized_default_construct_n() 在起始和计数所定义的未初始化内存区域用默认初始化构造对象(C++17) uninitialized_value_construct() 在范围所定义的未初始化内存中用值初始化构造对象(C++17) uninitialized_value_construct_n() 在起始和计数所定义的未初始化内存区域以值初始化构造对象(C++17) destroy_at() 销毁在给定地址的对象(C++17) destroy() 销毁一个范围中的对象(C++17) destroy_n() 销毁范围中一定数量的对象(C++17) "},"1.C++/8.STL标准库/7.bitset.html":{"url":"1.C++/8.STL标准库/7.bitset.html","title":"8.7 bitset","keywords":"","body":"bitset 作用：类模板bitset表示一个N位的固定大小序列。可以用标准逻辑运算符操作位集，并将它与字符串和整数相互转换。 1. 构造函数 #include std::bitset bit_set1; //将8个bit位全初始化为0 std::bitset bit_set2(15); //以整数变量初始化[00001111] std::bitset bit_set2(0xf); //十六进制[00001111] std::bitset bit_set2(\"001111\"); // 以字符串数组初始化[00001111] std::bitset bit_set2(string(\"001111\"), 1, 4); // 以string初始化 // 函数原型，pos为选取的字符位置，n为长度 template bitset(string, pos, n, zero='0', one='1'); 2. 常用操作 2.1 操作符 成员函数操作符 | 成员函数 | 说明 | | ----------------------------------------------------------- | ----------------------------------- | | operator[] | 访问指定的bit是否相等 | | operator== | 比较bitset | | operator&=operator|=operator^=operator~ | 与其他bitset二进制与/或/异或/非等于 | | operator/ operator>> | 二进制左移/右移 | 非成员函数操作符： | 非成员函数 | 说明 | | -------------------------------------------------------- | ------------------------------- | | operator&operator|operator^operator~ | 与其他bitset二进制与/或/异或/非 | | operator/operator>> | 输入输出流 | 2.2 元素访问 成员函数 说明 operator[] 访问某个bit位 test() 访问某个bit位，test提供边界检查 2.3 容量 成员函数 说明 all()/any()/none() 是否所有/任一/没有bit为被设为1(C++11) count() 返回设置为1的位的数量 size() 位集占的位大小 2.4 修改元素 成员函数 说明 >> & ` `^ ~ 位运算 set(pos, value=true) 设置指定位置为value reset(pos) 指定位置设为0 flip(pos) 指定位置取反 2.5 转换 成员函数 说明 to_string() 转为字符串表示 to_ulong() 转换为unsigned long整数表示 to_ullong() 转换为unsigned long long整数表示 "},"1.C++/8.STL标准库/附：STL速查表.html":{"url":"1.C++/8.STL标准库/附：STL速查表.html","title":"附：STL速查表","keywords":"","body":"STL索引 STL详细文档 字符串和整数 atoi() itoa() 随机数 整数和浮点数 include const int l = 1; const int r = 5; std::mt19937 gen{std::random_device{}()}; std::uniform_int_distribution<> dis1(l, r); std::uniform_real_distribution<> dis2(l, r); // 整数 int a = dis1(gen); // C语言方法 int a1 = rand()%(r - l + 1) + l; // 浮点数 double b = dis2(gen); "},"1.C++/9.设计模式/":{"url":"1.C++/9.设计模式/","title":"9. 设计模式","keywords":"","body":""},"1.C++/9.设计模式/1.单例模式.html":{"url":"1.C++/9.设计模式/1.单例模式.html","title":"9.1 单例模式","keywords":"","body":"单例模式 作用：确保一个类只有一个实例，并提供该实例的全局访问点。 实现: 外部不能直接创建/销毁对象：private构造函数和析构函数 仅有一个实例：利用一个静态指针变量指向实例，创建时判断指针是否为空指针，否则不创建 实例的创建：使用public静态成员函数访问静态指针变量，指针为空时在堆上创建对象 单例模式应该禁止掉拷贝构造函数和 operator = 操作符重载（= delete） 懒汉式单例模式 // 懒汉式单例模式 class Singleton { private: Singleton() { } static Singleton* sp_instance_; Singleton(const Singleton&)=delete; void operator=(const Singleton&)=delete; public: static Singleton* GetInstance() { if (pInstance == nullptr) //这里没有考虑线程安全 sp_instance_ = new Singleton(); return spInstance_; } static void delete_instance(); }; 上述代码中，当在多线程环境中，pInstance == nullptr同时判定，sp_instance_ = new Singleton();可能执行多次 线程安全的单例模式 仅有一个实例：把单个对象设为static，在static成员函数中实例化，并返回引用 // 线程安全的单例模式 class Singleton { private: Singleton() { } ~Singleton() { } Singleton(const Singleton &)=delete; void operator=(const Singleton &)=delete; public: static Singleton & GetInstance(){ static Singleton instance; return instance; } }; "},"1.C++/9.设计模式/2.工厂模式.html":{"url":"1.C++/9.设计模式/2.工厂模式.html","title":"9.2 工厂模式","keywords":"","body":"简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。 在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。 // 抽象工厂模式 class Factory { public: enum FACTORY_TYPE { BENZ_FACTORY, // 奔驰工厂 BMW_FACTORY, // 宝马工厂 AUDI_FACTORY // 奥迪工厂 }; virtual ICar* CreateCar() = 0; // 生产汽车 virtual IBike* CreateBike() = 0; // 生产自行车 static Factory * CreateFactory(FACTORY_TYPE factory); // 创建工厂 }; // TODO 完成设计模式 "},"1.C++/9.设计模式/3.观察者模式.html":{"url":"1.C++/9.设计模式/3.观察者模式.html","title":"9.3 观察者模式","keywords":"","body":"当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。 关键代码：在抽象类里有一个 ArrayList 存放观察者们。 "},"1.C++/9.设计模式/4.装饰器模式.html":{"url":"1.C++/9.设计模式/4.装饰器模式.html","title":"9.4 装饰器模式","keywords":"","body":""},"1.C++/10.多线程与并发/":{"url":"1.C++/10.多线程与并发/","title":"10. 多线程与并发","keywords":"","body":""},"1.C++/10.多线程与并发/1.多线程.html":{"url":"1.C++/10.多线程与并发/1.多线程.html","title":"10.1 多线程","keywords":"","body":"多线程 1. 线程多种创建方式 1.1 线程的创建 函数对象都可作为线程的任务执行 // 线程类的构造函数如下 thread() noexcept; //从其他即将消亡的线程构造，转移线程所有权，之后other不在执行线程 thread( thread&& other ) noexcept; template explicit thread( Function&& f, Args&&... args ); // 线程禁用了拷贝构造函数和拷贝赋值函数(`=delete`)，不能复制相同对象的 thread( const thread& ) = delete; 1.1.1 通过普通函数创建 #include #include #include std::mutex m_mutex; void test01() { std::unique_lock locker(mmutex); std::cout locker(mmutex); n++; std::cout 1.1.2 带参的方式创建线程 传引用使用std::ref(s)包装引用值 1.1.3 类成员函数 需要传入指定的对象 thread t(class1::func, obj) 1.1.4 lambda表达式 1.1.5 仿函数 1.1.6 带智能指针的方式创建线程 需要使用std::move传智能指针(传入后智能指针将置空) 2. 子线程的处理 2.1 join() 作用：子线程对象调用，连接子线程到主线程，主动地等待线程的终止（线程阻塞），任务执行完毕之后join()会清理当前子线程中的相关资源然后返回 joinable()函数可以判断当前线程能否join() // 函数原型 void std::thread::join(); 2.2 detach() 作用：线程分离，主线程不用像join()一样需要阻塞等待结束，子线程可以独立脱离主线程运行，执行完毕之后自动释放占用的资源。 void std::thread::detach(); 2.3 joinable() 判断是否可以join/detach bool std::thread::joinable() const noexcept; 2.4 get_id() 作用：每个被创建出的线程实例都对应一个线程 ID，这个 ID 是唯一的 std::thread::id std::thread::get_id() const noexcept; 2.5 hardware_concurrency()获取CPU核心数 static unsigned std::thread::hardware_concurrency() noexcept; 3. thread_local关键字 作用：被thread_local修饰的变量，每个子线程调用时，在每个线程中都拥有独立的所有权(相当于在每个子线程都有一个镜像)，具有线程周期的作用域和生命期 可以使用thread_local的变量 命名空间下的全局变量 类的static成员变量 局部变量 4. std::call_once() 作用：来保证函数在多个子线程中总共只被调用一次 // 使用 call_once() 的时候，需要一个 once_flag 作为 call_once() 的传入参数 // 该函数的原型如下 // #include template void call_once( std::once_flag& flag, Callable&& f, Args&&... args ); // 使用方法 std::one_flag g_flag; std::call_one(g_flag, func); "},"1.C++/10.多线程与并发/2.信号量与锁.html":{"url":"1.C++/10.多线程与并发/2.信号量与锁.html","title":"10.2 信号量与锁","keywords":"","body":"互斥量 作用：解决多线程数据混乱的方案就是进行线程同步，最常用的就是互斥锁，在 C++11 中一共提供了四种互斥锁 1. 互斥量的使用 std::mutex mn_mutex; mn_mutex.lock() ... // 临界代码区 mn_mutex.unlock() { // 互斥量作用域 std::lock_guard locker(mn_mutex); ... // 临界代码区 } { // 互斥量作用域 std::unique_lock locker(mn_mutex); ... // 临界代码区 } 1.1 lock() lock() 函数用于给临界区加锁，并且只能有一个线程获得锁的所有权 try_lock()不会阻塞线程，lock()会阻塞线程 void std::mutex<>::lock(); 1.2 unlock() 给临界区解锁 void std::mutex<>::unlock(); 1.3 lock_guard() lock_guard是 C++11 新增的一个模板类，使用这个类，可以简化互斥锁 lock() 和 unlock() 的写法，同时也更安全。 // 类的定义，定义于头文件 template class lock_guard; // 常用构造函数 explicit lock_guard( mutex_type& m ); 1.4 unique_lock() void std::lock_guard(); 2. 互斥量类型 互斥量 说明 std::mutex 独占的非递归互斥锁 std::timed_mutex 带超时的独占非递归互斥锁 std::recursive_mutex 不带超时功能的递归互斥锁 std::recursive_timed_mutex 带超时的递归互斥锁 "},"1.C++/10.多线程与并发/3.原子操作.html":{"url":"1.C++/10.多线程与并发/3.原子操作.html","title":"10.3 原子操作","keywords":"","body":"原子操作 作用：在多线程操作中，使用原子变量之后就不需要再使用互斥量来保护该变量了，用起来更简洁 原子锁：使用CPU指令级别实现，不会陷入内核态，但是循环CAS会消耗时间，适用于低并发、单个数据类型的数据安全； 非阻塞互斥量：会陷入内核，由内核判断是否可以获取锁，其消耗主要是内核态与用户态切换开销，适用于高并发、代码块的类型安全 #include template struct atomic; // 使用方法，m_value为临界区变量 std::atoimc_int m_value = 0; // atoimc_int = atomic 在 C++20 版本中添加了新的功能函数，可以通过原子类型来阻塞线程，和条件变量中的等待 / 通知函数是一样的。 公共成员函数 说明 wait() 阻塞线程直至被提醒且原子值更改(C++20) notify_one() 通知（唤醒）至少一个在原子对象上阻塞的线程(C++20) notify_all() 通知（唤醒）所有在原子对象上阻塞的线程(C++20) "},"1.C++/10.多线程与并发/4.同步与异步.html":{"url":"1.C++/10.多线程与并发/4.同步与异步.html","title":"10.4 同步与异步","keywords":"","body":"1. 线程同步 1.1 条件变量 C++11提供条件变量作为用于等待的同步机制，条件变量能够阻塞一个线程，直到另一个线程(给出资源)发起通知，唤醒当前阻塞的线程。 条件变量需要和互斥量配合起来使用，C++11 提供了两种条件变量： condition_variable 配合std::unique_lock使用 condition_variable 配合 unique_lock使用更灵活一些，可以在在任何时候自由地释放互斥锁，但是condition_variable 只能和独占的非递归互斥锁mutex配合使用，有一定的局限性 condition_variable_any 可以和任意带有lock()、unlock() 语义的mutex搭配使用，可以使用 #include 1.2 原子操作 可以通过原子类型来阻塞线程，和条件变量中的等待 / 通知函数是一样的 1.3 阻塞与唤醒 公共成员函数 说明 wait() 原子值更改(C++20)/互斥量上锁时阻塞线程直至被提醒 notify_one() 通知（唤醒）至少一个在原子对象上阻塞的线程(C++20) notify_all() 通知（唤醒）所有在原子对象上阻塞的线程(C++20) 2.线程异步 // TODO #include "},"1.C++/10.多线程与并发/5.线程池.html":{"url":"1.C++/10.多线程与并发/5.线程池.html","title":"10.5 线程池","keywords":"","body":"线程池 作用：处理新任务时要创建、销毁线程，可能造成效率低下。线程池可以预先创建一定数量的线程，有新任务时放到线程池中交给线程执行。 1. 线程池的实现 可以用生产者-消费者模型实现线程池，用信号量/条件变量实现生产者和消费者的线程同步 生产者线程：将待处理的新任务放到任务队列 消费者线程：取出任务队列中的任务，交给线程执行 管理者线程：线程繁忙时增加线程数量，空闲时减少线程数量 1.1 任务队列类 1.1.1 任务结点类型 任务队列类 // 定义任务结构体 using _function_type = void(*)(void*); struct Task { Task() { function = nullptr; arg = nullptr; } Task(_function_type f, void* arg) { function = f; this->arg = arg; } _function_type function; void* arg; }; // 任务队列 class TaskQueue { public: TaskQueue(); ~TaskQueue(); // 添加任务 void addTask(Task& task); void addTask(_function_type func, void* arg); // 取出一个任务 Task takeTask(); // 获取当前队列中任务个数 inline int taskNumber() { return m_queue.size(); } private: std::mutex m_mutex; // 互斥锁 std::queue m_queue; // 任务队列 }; 1.2 线程池类 "},"1.C++/附：C++面试题/":{"url":"1.C++/附：C++面试题/","title":"附：C++面试题","keywords":"","body":""},"1.C++/附：C++面试题/C++进阶目录.html":{"url":"1.C++/附：C++面试题/C++进阶目录.html","title":"C++进阶目录","keywords":"","body":" C++基础知识 1.1 C++标准 文字常量和变量 const的用法 const_cast的用法 mutable的用法 求余运算符% sizeof的用法 引用与指针常量 左值的概念 goto语句 volatile的用法 typedef的用法 关于字符串 链式操作 名字空间 定义复杂的宏(Macro) explicit的用法 数据类型与程序结构 C++的数据类型 布尔类型 void的用法 枚举类型 结构与联合 数据类型转换 声明与定义的区别 关于初始化 作用域和生命期 关于头文件 什么是分离编译模式 函数 main()函数 函数参数如何传递 函数调用时堆栈的变化 函数参数的默认值 怎么禁止传值调用 可变参数函数 函数指针 函数重载 操作符重载 类成员函数与外部函数的区别 内联函数 函数的返回值在哪 extern \"C\"的作用 类与对象 类定义后面为什么要加分号 初始化列表 对象的生成方式 临时对象 关于点操作符 嵌套类与局部类 对象之间的比较 静态成员 类的设计及实现规范 抽象类与纯虚函数 类对象的内存布局 为什么基类的析构函数要定义为虚函数 对象数据成员的初始值 对象产生和销毁的顺序 拷贝构造函数 数组与指针 数组名的意义 什么是指针 数组与指针的关系 数组的初始化 多维数组与多重指针 成员数据指针 this指针 什么是悬挂指针 什么是解引用 指针与句柄 模板与标准模板库 模板参数 模板实例化 函数声明对函数模板实例化的屏蔽 将模板声明为友元 模板与分离编译模式 模板特化 输入/输出迭代子的用法 bitset的简单用法 typename的简单用法 什么是仿函数 什么是引用计数 什么是ADL 内存管理 C++程序的内存布局 new操作的实现过程 禁止在堆或栈上创建对象 new和delete的使用规范 delete和delete[]区别 什么是定位放置new 在函数中创建动态对象 什么是内存池技术 继承与多态 私有成员会被继承吗 怎么理解构造函数不能被继承 什么是虚拟继承 怎么编写一个不能被继承的类 关于隐藏 什么是RTTI 虚调用的几种情形 不要在构造函数或析构函数中调用虚函数 虚函数可以是私有的吗 动态联编是怎样实现的 !操作符重载 *操作符重载 赋值操作符重载 输入输出操作符重载 输入输出流 什么是IO流 IO流的优点 endl是什么 实现不带缓冲的输入 提高输入输出操作的稳健性 为什么要设定locale char*和wchar_T*之间的转换 获取文件信息 管理网文件和目录操作 二进制文件的IO操作 异常处理 为什么要引入异常处理机制 抛出异常和传递参数的不同 抛出和接收异常的顺序 在构造函数中抛出异常 用传引用的方式捕捉异常 在堆栈展开时如何防止内存泄漏 "},"1.C++/附：C++面试题/C语言常用函数.html":{"url":"1.C++/附：C++面试题/C语言常用函数.html","title":"C语言常用函数","keywords":"","body":"1. 字符串 链接 | 序号 | 函数 & 描述 | | ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | 1 | void *memchr(const void *str, int c, size_t n)在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。 | | 2 | int memcmp(const void *str1, const void *str2, size_t n)把 str1 和 str2 的前 n 个字节进行比较。 | | 3 | void *memcpy(void *dest, const void *src, size_t n)从 src 复制 n 个字符到 dest。 | | 4 | void *memmove(void *dest, const void *src, size_t n)另一个用于从 src 复制 n 个字符到 dest 的函数。 | | 5 | void *memset(void *str, int c, size_t n)复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。 | | 6 | char *strcat(char *dest, const char *src)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。 | | 7 | char *strncat(char *dest, const char *src, size_t n)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。 | | 8 | char *strchr(const char *str, int c)在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。 | | 9 | int strcmp(const char *str1, const char *str2)把 str1 所指向的字符串和 str2 所指向的字符串进行比较。 | | 10 | int strncmp(const char *str1, const char *str2, size_t n)把 str1 和 str2 进行比较，最多比较前 n 个字节。 | | 11 | int strcoll(const char *str1, const char *str2)把 str1 和 str2 进行比较，结果取决于 LC_COLLATE 的位置设置。 | | 12 | char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest。 | | 13 | char *strncpy(char *dest, const char *src, size_t n)把 src 所指向的字符串复制到 dest，最多复制 n 个字符。 | | 14 | size_t strcspn(const char *str1, const char *str2)检索字符串 str1 开头连续有几个字符都不含字符串 str2 中的字符。 | | 15 | char *strerror(int errnum)从内部数组中搜索错误号 errnum，并返回一个指向错误消息字符串的指针。 | | 16 | size_t strlen(const char *str)计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。 | | 17 | char *strpbrk(const char *str1, const char *str2)检索字符串 str1 中第一个匹配字符串 str2 中字符的字符，不包含空结束字符。也就是说，依次检验字符串 str1 中的字符，当被检验字符在字符串 str2 中也包含时，则停止检验，并返回该字符位置。 | | 18 | char *strrchr(const char *str, int c)在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。 | | 19 | size_t strspn(const char *str1, const char *str2)检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。 | | 20 | char *strstr(const char *haystack, const char *needle)在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。 | | 21 | char *strtok(char *str, const char *delim)分解字符串 str 为一组字符串，delim 为分隔符。 | | 22 | size_t strxfrm(char *dest, const char *src, size_t n)根据程序当前的区域选项中的 LC_COLLATE 来转换字符串 src 的前 n 个字符，并把它们放置在字符串 dest 中。 | 2. 标准库 序号 函数 & 描述 1 double atof(const char *str)把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 2 int atoi(const char *str)把参数 str 所指向的字符串转换为一个整数（类型为 int 型）。 3 long int atol(const char *str)把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。 4 double strtod(const char *str, char **endptr)把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）。 5 long int strtol(const char *str, char **endptr, int base)把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）。 6 unsigned long int strtoul(const char *str, char **endptr, int base)把参数 str 所指向的字符串转换为一个无符号长整数（类型为 unsigned long int 型）。 7 void *calloc(size_t nitems, size_t size)分配所需的内存空间，并返回一个指向它的指针。 8 void free(void *ptr)释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。 9 void *malloc(size_t size)分配所需的内存空间，并返回一个指向它的指针。 10 void *realloc(void *ptr, size_t size)尝试重新调整之前调用 malloc 或 calloc 所分配的 ptr 所指向的内存块的大小。 11 void abort(void)使一个异常程序终止。 12 int atexit(void (*func)(void))当程序正常终止时，调用指定的函数 func。 13 void exit(int status)使程序正常终止。 14 char *getenv(const char *name)搜索 name 所指向的环境字符串，并返回相关的值给字符串。 15 int system(const char *string)由 string 指定的命令传给要被命令处理器执行的主机环境。 16 void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *))执行二分查找。 17 void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))数组排序。 18 int abs(int x)返回 x 的绝对值。 19 div_t div(int numer, int denom)分子除以分母。 20 long int labs(long int x)返回 x 的绝对值。 21 ldiv_t ldiv(long int numer, long int denom)分子除以分母。 22 int rand(void)返回一个范围在 0 到 RAND_MAX 之间的伪随机数。 23 void srand(unsigned int seed)该函数播种由函数 rand 使用的随机数发生器。 24 int mblen(const char *str, size_t n)返回参数 str 所指向的多字节字符的长度。 "},"2.数据结构与算法/":{"url":"2.数据结构与算法/","title":"第二部分 数据结构与算法","keywords":"","body":""},"2.数据结构与算法/1.排序与查找/":{"url":"2.数据结构与算法/1.排序与查找/","title":"1. 排序与查找","keywords":"","body":""},"2.数据结构与算法/1.排序与查找/1.排序算法.html":{"url":"2.数据结构与算法/1.排序与查找/1.排序算法.html","title":"1.1 排序算法","keywords":"","body":" 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性 冒泡排序 O(n2)O(n^2)O(n​2​​) O(n2)O(n^2)O(n​2​​) O(1)O(1)O(1) 稳定 选择排序 O(n2)O(n^2)O(n​2​​) O(n2)O(n^2)O(n​2​​) O(1)O(1)O(1) 数组不稳定、链表稳定 插入排序 O(n2)O(n^2)O(n​2​​) O(n2)O(n^2)O(n​2​​) O(1)O(1)O(1) 稳定 快速排序 O(n∗log2n)O(n*log_2n)O(n∗log​2​​n) O(n2)O(n^2)O(n​2​​) O(log2n)O(log_2n)O(log​2​​n) 不稳定 堆排序 O(n∗log2n)O(n*log_2n)O(n∗log​2​​n) O(n∗log2n)O(n*log_2n)O(n∗log​2​​n) O(1)O(1)O(1) 不稳定 归并排序 O(n∗log2n)O(n*log_2n)O(n∗log​2​​n) O(n∗log2n)O(n*log_2n)O(n∗log​2​​n) O(n)O(n)O(n) 稳定 希尔排序 O(n∗log2n)O(n*log_2n)O(n∗log​2​​n) O(n2)O(n^2)O(n​2​​) O(1)O(1)O(1) 不稳定 计数排序 O(n+m)O(n+m)O(n+m) O(n+m)O(n+m)O(n+m) O(n+m)O(n+m)O(n+m) 稳定 桶排序 O(n)O(n)O(n) O(n)O(n)O(n) O(m)O(m)O(m) 稳定 基数排序 O(k∗n)O(k*n)O(k∗n) O(n2)O(n^2)O(n​2​​) 稳定 冒泡排序 原理：(从头部到尾部)每一次比较相邻元素，将最大元素移动到数组尾部，重复这个步骤 优化：设定一个标志，如果没有发生交换则已经有序，排序完成 vector bubble_sort(const vector& vec) { int n = vec.size(); auto vec1 = vec; for (int i = 0; i i; j--) { if (vec1[j] 选择排序 原理：从剩余未排序序列找出最大（最小）元素放到序列尾部（头部），重复这个步骤 ```cpp vector selection_sort(const vector& vec) { int n = vec.size(); auto vec_copy = vec; for (int i = 0; i // 优化，减少交换次数 if (i != min_idx) swap(vec_copy[i], vec_copy[min_idx]); } return vec_copy; } --- ## 插入排序 > 原理：将待排序序列每个元素插入到前面已排序序列合适的位置 > 优化：用一个变量保存待插入元素，将大于该数的元素后移，用赋值代替交换 > - 插入排序用于接近有序的数组效率是最高的 ![插入排序](http://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571058280-228509668da9939.gif) ```cpp // 插入排序 vector insertion_sort(const vector& vec) { int n = vec.size(); auto vec_copy = vec; for (int i = 1; i 0 and elem 希尔排序 原理： // 希尔排序：每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。 template void shell_sort(T array[], int length) { int h = 1; while (h = 1) { for (int i = h; i = h && array[j] 归并排序 原理：分治，将两个有序序列合并成一个有序数列。可以将序列从中间分成两部分，递归进行 优化：当归并的左边序列都比右边小时，可以不用执行归并 自顶向下(递归) ```cpp //递归的归并排序 void merge(vector& vec, int l, int mid, int r) { vector tmp(begin(vec) + l, begin(vec) + r + 1); int i = 0, j = mid + 1 - l, k = l; while (i & vec, int l, int r) { if (l > 1); _merge_sort(vec, l, mid); _merge_sort(vec, mid + 1, r); // 优化，当左边序列有比右边序列大的数才执行归并 if (vec[mid] > vec[mid + 1]) merge(vec, l, mid, r); } } // 对输入参数进行统一 void merge_sort(vector& vec) { int n = vec.size(); _merge_sort(vec, 0, n - 1); } ### 自底向上(迭代) ```cpp // 自底向上的归并算法 void merge_sort_BU(vector& vec) { int n = vec.size(); for (int sz = 1; sz 快速排序 原理：分治，从序列中选一个基准数，将小于该数的移到序列左边，大于该数的移到右边， 该数就放在了正确的位置上；对左边序列和右边序列递归执行 优化：随机选择基准，避免在对接近有序序列排序的效率退化；序列中重复元素很多时可以选择三路快排 ```cpp // 快速排序 // 划分操作 int partition(vector& vec, int l, int r) { // 优化1：随机选择基准 swap(vec[l], vec[rand() % (r - l + 1) + l]); int elem = vec[l]; int lt = l; for (int i = l + 1; i // 优化2：三路快排 int partition_3(vector& vec, int l, int r) { // 优化1：随机选择基准 swap(vec[l], vec[rand() % (r - l + 1) + l]); int elem = vec[l]; // [l+1,lt]e int lt = l, gt = r + 1; for (int i = l + 1; i elem) { // gt-1处元素大小未知，交换之后继续处理 swap(vec[i], vec[--gt]); } else { i++; } } swap(vec[l], vec[lt]); return lt; } void _quick_sort(vector& vec, int l, int r) { if (l void quick_sort(vector& vec) { int n = vec.size(); _quick_sort(vec, 0, n - 1); } --- ## 堆排序 > 原理： ![堆排序](http://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571058283-2d3c9e36ffad169.gif) ```cpp // 堆排序：（最大堆，有序区）。从堆顶把根卸出来放在有序区之前，再恢复堆。 void shift_up(std::vector &arr, int pos) { for (; pos > 1 and arr[pos] > arr[pos / 2]; pos >>= 1) { std::swap(arr[pos], arr[pos / 2]); } } void shift_down(std::vector &arr, int pos, int range) { int elem = arr[pos]; while (2 * pos arr[i]) break; arr[pos] = arr[i]; pos = i; } arr[pos] = elem; } void HeapSort(std::vector &arr) { arr.insert(arr.begin(), 0); int n = arr.size(); for (int i = 2; i 1; i--) { std::swap(arr[i], arr[1]); shift_down(arr, 1, i - 1); } arr.erase(arr.begin()); } 计数排序 原理： ```cpp /* 算法的步骤如下： 找出待排序的数组中最大和最小的元素 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1 */ // 计数排序 void CountSort(vector& vecRaw, vector& vecObj) { // 确保待排序容器非空 if (vecRaw.size() == 0) return; // 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小 int vecCountLength = (*max_element(begin(vecRaw), end(vecRaw))) + 1; vector vecCount(vecCountLength, 0); // 统计每个键值出现的次数 for (int i = 0; i 0; i--) // 此处逆序是为了保持相同键值的稳定性 vecObj[--vecCount[vecRaw[i - 1]]] = vecRaw[i - 1]; } --- ## 桶排序 > 原理：将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。 ![桶排序](http://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571058284-b56accdbe5a63db.gif) ```cpp /***************** 桶排序：将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。 桶排序序思路： 1. 设置一个定量的数组当作空桶子。 2. 寻访序列，并且把项目一个一个放到对应的桶子去。 3. 对每个不是空的桶子进行排序。 4. 从不是空的桶子里把项目再放回原来的序列中。 假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序，然后把各个桶中的数据合并。 *****************/ const int BUCKET_NUM = 10; struct ListNode{ explicit ListNode(int i=0):mData(i),mNext(NULL){} ListNode* mNext; int mData; }; ListNode* insert(ListNode* head,int val){ ListNode dummyNode; ListNode *newNode = new ListNode(val); ListNode *pre,*curr; dummyNode.mNext = head; pre = &dummyNode; curr = head; while(NULL!=curr && curr->mDatamNext; } newNode->mNext = curr; pre->mNext = newNode; return dummyNode.mNext; } ListNode* Merge(ListNode *head1,ListNode *head2){ ListNode dummyNode; ListNode *dummy = &dummyNode; while(NULL!=head1 && NULL!=head2){ if(head1->mData mData){ dummy->mNext = head1; head1 = head1->mNext; }else{ dummy->mNext = head2; head2 = head2->mNext; } dummy = dummy->mNext; } if(NULL!=head1) dummy->mNext = head1; if(NULL!=head2) dummy->mNext = head2; return dummyNode.mNext; } void BucketSort(int n,int arr[]){ vector buckets(BUCKET_NUM,(ListNode*)(0)); for(int i=0;imData; head = head->mNext; } } 基数排序 原理：基数排序：一种多关键字的排序算法，可用桶排序实现。 int maxbit(int data[], int n) //辅助函数，求数据的最大位数 { int maxData = data[0]; ///= p) { //p *= 10; // Maybe overflow maxData /= 10; ++d; } return d; /* int d = 1; //保存最大的位数 int p = 10; for(int i = 0; i = p) { p *= 10; ++d; } } return d;*/ } void radixsort(int data[], int n) //基数排序 { int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for(i = 1; i = 0; j--) //将所有桶中记录依次收集到tmp中 { k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; } for(j = 0; j "},"2.数据结构与算法/2.数据结构/1.线性表.html":{"url":"2.数据结构与算法/2.数据结构/1.线性表.html","title":"2.1 线性表","keywords":"","body":" 顺序表 vector 链表 class Node{ public: Node(){}; } "},"2.数据结构与算法/2.数据结构/2.栈和队列.html":{"url":"2.数据结构与算法/2.数据结构/2.栈和队列.html","title":"2.2 栈和队列","keywords":"","body":""},"2.数据结构与算法/2.数据结构/3.树.html":{"url":"2.数据结构与算法/2.数据结构/3.树.html","title":"2.3 树","keywords":"","body":"二叉搜索树 红黑树 结点必须为红色或黑色 根结点为黑色 叶子结点(null)为黑色 红色结点不能连在一起 根据这个性质，可以得到 -> 任何结点到根结点的黑色结点个数必须相同，就满足了近似的平衡 变色规则 存在结点两个子结点都为为红色时，将子结点设为黑色，当前结点设为红色 左旋 插入结点默认为红色，当前结点和父亲结点都为红色(失衡)，且当前结点为右子树时左旋： (只用关心当前失衡的结点和父亲结点) 子结点到父结点位置，父结点作为其左子树，原来的左子树作为原父结点的右子树 右旋 右旋需要在爷爷结点和父亲结点上进行 右旋时需要将父结点设为黑色，爷爷变为红色 B树：平衡多路查找树 "},"2.数据结构与算法/2.数据结构/4.堆.html":{"url":"2.数据结构与算法/2.数据结构/4.堆.html","title":"2.4 堆","keywords":"","body":"// TODO 索引堆 "},"2.数据结构与算法/2.数据结构/5.图.html":{"url":"2.数据结构与算法/2.数据结构/5.图.html","title":"2.5 图","keywords":"","body":"邻接矩阵和邻接表 邻接矩阵适合稀疏图 邻接表适合稠密图 "},"2.数据结构与算法/3.算法/":{"url":"2.数据结构与算法/3.算法/","title":"3. 算法","keywords":"","body":""},"2.数据结构与算法/3.算法/1.数组.html":{"url":"2.数据结构与算法/3.算法/1.数组.html","title":"1.数组","keywords":"","body":"1.数组 "},"2.数据结构与算法/3.算法/2.字符串.html":{"url":"2.数据结构与算法/3.算法/2.字符串.html","title":"2.字符串","keywords":"","body":"2.字符串 "},"2.数据结构与算法/3.算法/3.链表.html":{"url":"2.数据结构与算法/3.算法/3.链表.html","title":"3.链表","keywords":"","body":"3.链表 "},"2.数据结构与算法/3.算法/4.栈与队列.html":{"url":"2.数据结构与算法/3.算法/4.栈与队列.html","title":"4.栈与队列","keywords":"","body":"注意，单调栈和单调队列进入的都是索引 单调栈：比较前后元素的大小关系 单调队列：一个窗口中的最大值/最小值 "},"2.数据结构与算法/3.算法/5.二叉树树与递归.html":{"url":"2.数据结构与算法/3.算法/5.二叉树树与递归.html","title":"5.二叉树与递归","keywords":"","body":"5.二叉树与递归 "},"2.数据结构与算法/3.算法/6.DFS与BFS.html":{"url":"2.数据结构与算法/3.算法/6.DFS与BFS.html","title":"6.DFS与BFS","keywords":"","body":""},"2.数据结构与算法/3.算法/7.贪心与回溯.html":{"url":"2.数据结构与算法/3.算法/7.贪心与回溯.html","title":"7.贪心与回溯","keywords":"","body":"7.贪心与回溯 "},"2.数据结构与算法/3.算法/8.动态规划.html":{"url":"2.数据结构与算法/3.算法/8.动态规划.html","title":"8.动态规划","keywords":"","body":"动态规划 应用：最值问题(具有最优子结构，即子问题拥有最值) 递归问题 -> 重叠子结构，子问题有最值 -> 动态规划 # 初始化 base case dp[0][0][...] = base # 进行状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) dp数组的遍历方向 遍历的终点是最终存储的结果 点击查看示例图片 动态规划的步骤： 定义数组元素的含义(关键，不一定是直接最后的结果，但是和子问题间的关系较为简单) 找出数组元素之间的关系式(状态转移方程，难点) 找出边界初始值 例题1：不同路径 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ dp数组定义：dp[i][j]为机器人到达[i,j]处的路径个数 机器人可以从上边以及左边到达[i,j]处，状态转移方程dp[i][j] = dp[i-1][j] + dp[i][j-1] 初始值在左边界和上边界为1，代码如下： class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [[0]*n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1] 例题2：编辑距离 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1: 输入: word1 = \"horse\", word2 = \"ros\" 输出: 3 解释: horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e') dp[i][j]定义为word1的前i个字母到word2的前j个字母的操作数 第[i,j]个字母相同时，dp[i][j] = dp[i-1][j-1](不执行任何操作)，不相同时dp[i-1][j]+1代表插入元素，dp[i][j-1]+1代表删除当前元素，dp[i-1][j-1]+1代表替换当前元素，转移方程dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1或dp[i][j] = dp[i-1][j-1] (w1[i]==w2[j]时) 初始值dp[0][0...n]=0...n，dp[0...m][0]=0...m，表示从0到n需要插入的元素个数，以及从0到m需要删除的元素个数 class Solution: def minDistance(self, word1: str, word2: str) -> int: m, n = len(word1), len(word2) dp = [[0] * (n+1) for _ in range(m+1)] # 初始值 for i in range(m+1): dp[i][0] = i for j in range(n+1): dp[0][j] = j for i in range(m): for j in range(n): # 状态转移 if word1[i] == word2[j]: dp[i+1][j+1] = dp[i][j] else: dp[i+1][j+1] = min(dp[i][j+1], dp[i+1][j], dp[i][j]) + 1 return dp[-1][-1] 动态规划的优化步骤 当dp矩阵计算当前值只跟上一行和当前行有关时，可以考虑优化dp矩阵，减少空间复杂度 对于dp矩阵，在计算第三行的值时，第一行的值实际上是没有利用到的，因此dp矩阵可以优化为只保存矩阵的一行，而状态转移方程也从dp[i][j] = dp[i-1][j] + dp[i][j-1] → dp[j] = dp[j] + dp[j-1](dp[j]保存的是上一行dp[i-1][j]的值，dp[j-1]为当前行dp[i][j-1]的值) 例题1 优化代码如下： class Solution: def uniquePaths(self, m: int, n: int) -> int: dp = [1]*n for i in range(1, m): # 相当于初始化矩阵第0列 dp[0] = 1 for j in range(1, n): dp[j] = dp[j] + dp[j-1] return dp[-1] 例题2 class Solution: def minDistance(self, word1: str, word2: str) -> int: m, n = len(word1), len(word2) # 矩阵第0行，初始化 dp = list(range(n+1)) for i in range(m): # 保存上一列第0个元素 tmp = dp[0] # 相当于初始化矩阵第0列，即当前行第0个元素 dp[0] = i+1 for j in range(n): # 使用上一列保存的元素 pre = tmp # 保存[i,j+1]供下一列元素使用 tmp = dp[j+1] if word1[i] == word2[j]: dp[j+1] = pre else: dp[j+1] = min(dp[j+1], dp[j], pre) + 1 return dp[-1] "},"2.数据结构与算法/3.算法/9.哈希.html":{"url":"2.数据结构与算法/3.算法/9.哈希.html","title":"9.哈希","keywords":"","body":""},"2.数据结构与算法/3.算法/10.算法思想.html":{"url":"2.数据结构与算法/3.算法/10.算法思想.html","title":"10.算法思想","keywords":"","body":"10.算法思想 "},"2.数据结构与算法/3.算法/11.附：高频算法题.html":{"url":"2.数据结构与算法/3.算法/11.附：高频算法题.html","title":"附：高频算法题","keywords":"","body":"附：高频算法题 "},"3.操作系统/":{"url":"3.操作系统/","title":"第三部分 操作系统","keywords":"","body":""},"3.操作系统/1.体系结构.html":{"url":"3.操作系统/1.体系结构.html","title":"1.体系结构","keywords":"","body":" 运行机制 两种指令 特权指令 如内存清零指令 非特权指令 如加减乘除运算指令 两种处理器状态 用程序状态寄存器(PSW)的标志位来标识处理器状态。如0为用户态，1为核心态 用户态（目态） 只能执行非特权指令。用户态→核心态的切换只能通过中断实现 核心态（管态） 特权指令、非特权指令都可以执行。核心态→用户态一种特权指令将程序状态字PSW设为用户态 两种程序 内核程序 运行在核心态，特权指令+非特权指令，是系统的管理者 应用程序 只能执行非特权指令，运行在用户态 操作系统内核 时钟管理 // TODO 时间片轮换 中断和异常 中断作用 引入中断机制，实现多道程序并发执行 本质：CPU收到中断信号，立即切换到核心态，对中断进行处理 中断是用户态→核心态的唯一途径 中断 外中断 狭义的中断。来自CPU外部的信号，与当前执行指令无关。 外设请求 如IO操作完成发出中断 人工干预 如用户强制终止进程 异常（内中断、例外、陷入） 信号来自当前执行的指令 自愿中断——指令中断(trap) 如系统调用使用的访管指令(也叫陷入、trap指令) 强迫中断 硬件故障(fault) 如缺页中断 软件中断(abort) 如整数除0 原语： 是一种特殊的程序，处于操作系统最底层，最接近硬件的部分 运行具有原子性，不可中断 运行时间短，调用频繁系统调用 系统资源管理 进程管理 存储管理 设备管理大内核与微内核 大内核 将操作系统主要功能模块都作为核心态 优点：高性能 缺点：代码庞大，结构混乱，难以维护微内核 只把最基本的功能保留在内核 优点：内核功能少，结构清晰，方便维护 缺点：性能低，需要在用户态和核心态频繁切换 "},"3.操作系统/2.进程与线程.html":{"url":"3.操作系统/2.进程与线程.html","title":"2.进程与线程","keywords":"","body":"进程与线程 1. 进程 进程实体的运行过程（动态的） 系统进行资源分配和调度的独立单位1.1 进程实体 程序段：程序的代码等 数据段：程序处理的数据和变量 PCB（进程存在唯一标志） 进程描述信息：进程标识符PID，用户标识符UID 进程控制和管理信息 进程当前状态 进程优先级 资源分配清单 程序段指针 数据段指针 外设 处理机相关信息 各种寄存器的值 进程之间私有和共享的资源 私有：地址空间、堆、全局变量、栈、寄存器 共享：代码段，公共数据，进程目录，进程 ID 1.2 进程状态转换 就绪态-->运行态：程序被调度，CPU开始执行 运行态-->就绪态：时间片用完或者更高优先级的进程执行 运行态-->阻塞态：进程通过系统调用申请某种资源(如打印机等)，请求等待事件发生完才能继续执行（主动行为） 阻塞态-->就绪态：申请的资源被分配，可以继续执行（被动行为） 1.3 父进程与子进程 Linux使用fork()创建子进程，先fork再execve，是为了创建子进程时，子进程能够处理文件描述符，以完成对标准输入，标准输出以及标准出错的重定向。 Windows中，调用Win32函数CreateProcess直接创建新的子进程 复制父进程的资源需要大量的操作，十分浪费时间与系统资源，因此Linux内核采取了写时拷贝技术（copy on write）来提高效率// 返回值0代表子进程，>0代表父进程，值为子进程PID，-1代表出错，在两个进程中返回两个值 pid_t fork(); 相同：子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息 区别：子进程与父进程的区别有进程号、资源使用情况和计时器等。 exec函数族 提供了让进程运行另一个程序的方法。exec函数族内的函数可以根据指定的文件名或目录名找到可执行程序，并加载新的可执行程序，替换掉旧的代码区、数据区、堆区、栈区与其他系统资源。这里的可执行程序既可以是二进制文件，也可以是脚本文件。在执行exec函数族函数后，除了该进程的进程号PID，其他内容(当前进程的正文、数据、堆和栈段)都被替换了。 1.3.1 守护进程 守护进程是一类在后台工作的特殊进程，通常情况下，守护进程用于执行特定的系统任务。守护进程却能够（或者说，必须）突破终端的限制，不受终端的影响在后台工作。许多的系统服务都是通过守护进程实现的 编写一个守护进程的步骤如下： 1.fork()子进程，kill -9强制杀死父进程 2.在子进程内创建新会话 3.改变工作目录 4.重设文件权限掩码 5.关闭文件描述符 1.3.2 孤儿进程 孤儿进程指的是在其父进程执行完成或被终止后仍继续运行的一类进程，其会被init进程收养 一般情况下，子进程是由父进程创建，而子进程和父进程的退出是无顺序的，两者之间都不知道谁先退出。正常情况下父进程先结束会调用wait或者waitpid函数等待子进程完成再退出，而一旦父进程不等待直接退出，则剩下的子进程会被init(pid=1)进程接收，成会孤儿进程。（进程树中除了init都会有父进程） 解决：会被init进程收养，没有危害 1.3.3 僵尸进程 僵尸进程是指完成执行（通过exit系统调用，或运行时发生致命错误或收到终止信号所致）但在操作系统的进程表中仍然有一个表项（进程控制块PCB），处于\"终止状态 \"的进程 如果子进程先退出了，父进程还未结束并且没有调用 wait 或者 waitpid 函数获取子进程的状态信息，则子进程残留的状态信息（task_struct结构和少量资源信息）会变成僵尸进程 解决：kill父进程 2. 进程通信 2.1 管道（PIPE） 2.1.1 有名管道 一种半双工的通信方式，它允许无亲缘关系进程间的通信 优点：可以实现任意关系的进程间的通信 缺点： 长期存于系统中，使用不当容易出错 缓冲区有限2.1.2 无名管道 一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程） 优点：简单方便 缺点： 局限于单向通信 只能创建在它的进程以及其有亲缘关系的进程之间 缓冲区有限 2.2 信号量（Semaphore） 一个计数器，可以用来控制多个线程对共享资源的访问 优点：可以同步进程 缺点：信号量有限2.3 信号（Signal） 一种比较复杂的通信方式，用于通知接收进程某个事件已经发生2.4 消息队列（Message Queue） 消息的链表队列，存放在内核中并由消息队列标识符标识，是一个生产者消费者模型 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合2.5 共享内存（Shared Memory） 映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问 优点：无须复制，快捷，信息量大 缺点： 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信2.6 套接字（Socket） 可用于网络上不同主机间的进程通信 优点： 传输数据为字节级，传输数据可自定义，数据量小效率高 传输数据时间短，性能高 适合于客户端和服务器端之间信息实时交互 可以加密,数据安全性强 缺点：需对传输的数据进行解析，转化成应用级的数据。 线程 线程之间私有和共享的资源 私有：线程栈，寄存器，程序寄存器 共享：堆，地址空间，全局变量，静态变量 进程与线程区别 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU利用率低 占用内存少，切换简单，CPU利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 适应于多核分布式 进程占优 "},"3.操作系统/3.进程同步与互斥.html":{"url":"3.操作系统/3.进程同步与互斥.html","title":"3.进程同步与互斥","keywords":"","body":"进程同步与互斥 异步性：各并发执行的进程以各自独立、不可预知的速度向前推进 同步(直接制约关系)：进程直接因为资源，需要协调工作次序 进程同步 详细见Linux内核的同步机制1, Linux内核的同步机制2 同步方式 原子操作 信号量（semaphore） 读写信号量（rw_semaphore） 自旋锁（spinlock） 大内核锁（BKL，Big Kernel Lock） 读写锁（rwlock） 大读者锁（brlock-Big Reader Lock） 读-拷贝修改(RCU，Read-Copy Update) 顺序锁（seqlock） 进程互斥 对临界资源的访问，需要互斥进行 临界资源与临界区 临界资源：一个时间段内只允许一个进程使用，如：打印机等 临界区：进入临界资源的代码段进程互斥原则 空闲让进：临界区空闲时，可允许进程立即进入相应临界区 忙则等待：已有进程进入临界区时，其他进程应该等待 有限等待：不能让进程饥饿 让权等待：进程无法进入临界区时，应立即释放处理机，进入阻塞态信号量 机制：一对原语PV操作类型 整型信号量 用整数变量作为信号量，表示某种资源的数量 不满足让权等待，会一直占用处理机记录型型号量 P(S)如果剩余资源数不够，使用block原语将进程阻塞，并挂到信号量S的阻塞队列中；V(S)释放资源后，阻塞队列还有进程，便使用wakeup原语唤醒，变为就绪态 同步与互斥问题 实现进程互斥步骤： 确定临界区 设置互斥信号量mutex=1 进入临界区之前执行P操作 离开临界区时执行V操作 实现进程同步步骤： 找出同步关系 设置同步信号量初始值为0 在前置操作后执行V操作 在后置操作前执行P操作 生产者-消费者问题 互斥：只有一个进程能访问缓冲区mutex=1 同步：生产者需要空余缓冲区empty=n，消费者需要产品full=0 PV操作先后问题：互斥P操作必须在进入临界区之前，否则可能发生死锁，V操作先后顺序没影响(互斥PV在临界区前后)多生产者-消费者问题 互斥：只有一个进程能访问缓冲区mutex=1 同步：生产者A生产的产品a只能由α消费，生产者B生产的产品b只能由β消费，a=0, b=0, 缓冲区buffer=1// 生产者 A{ // 生产a P(buffer) P(mutex) // a放入缓冲区 V(mutex) V(a) } // 消费者 a{ P(a) P(mutex) // 从缓冲区取出a V(mutex) V(buffer) // 消费a } 读者-写者模型 互斥量：读-写进程互斥，写-写进程互斥，读-读进程互不干扰，mutex=1 处理方法：增加读进程cnt,cnt为0时对文件加锁P(mutex), cnt++，读完后cnt--，cnt为0时再解锁V(mutex)，同时应该对cnt变量的互斥操作mutex_count=1(cnt检查和赋值需要一气呵成，否则两个读进程可能cnt判断同时通过从而死锁) // 读者(读优先) P(mutex_count) if cnt==0: P(mutex) V(mutex_count) // 读文件 P(mutex_count) if cnt==0: V(mutex) V(mutex_count) 实现读写公平：增加互斥量w=1, 写者在先后进行互斥，读者在读文件之前进行互斥 哲学家进餐模型 问题：只有互斥关系，避免临界资源分配不当造成死锁 定义互斥信号量数组v(5,1),哲学家编号i=0~4，左边筷子编号为i，右边为(i+1)%5 "},"3.操作系统/4.内存管理.html":{"url":"3.操作系统/4.内存管理.html","title":"4.内存管理","keywords":"","body":"内存管理 1. 虚拟地址转换 绝对装入：编译器负责地址转换 可重定位装入：装入程序负责地址转换(早期阶段) 动态运行时装入：运行时才进行地址转换(现代操作系统) 2. 物理内存分配与回收 2.1 连续分配管理 系统为进程所分配的必须是连续的一块内存 首次适应算法：每次从低地址查找满足大小的空闲分区 最佳适应算法：优先分配满足要求的最小的空闲分区 缺点：会产生很多外部碎片 最坏适应算法：优先分配最大的连续空闲分区 缺点：会很快将大分区分配完，导致后续大进程没有内存空间 邻近适应算法：从上次分配完的地址开始查找满足大小的分区2.2 非连续分配(离散分配方式) 分页内存管理 把内存分为大小相等的分区，按照分区大小把进程拆分开，一般为4kb=2^12 分段内存管理 区别：段的大小可以不相同，页的大小相同 分段是信息的逻辑单位，对用户是可见的；分页是信息的物理单位，用户不可见 段页式内存管理3. 虚拟内存 覆盖技术：程序分成几个模块，按时间先后运行 交换技术：进程在内存与磁盘间动态调度3.1 虚拟内存特征 特征： 多次性：程序允许被分成多次调入内存 对换性：程序运行时无需常驻内存，可以在运行过程中换入换出 虚拟性：逻辑上扩充了内存的容量 虚拟地址空间的最大容量由CPU寻址范围确定，32位系统为4GB 3.1 页面置换算法 3.1.1 最佳置换算法OPT 每次淘汰以后最长时间不被访问的页面（理想化算法，无法实现） 3.1.2 先进先出置换算法FIFO 每次淘汰最早进入内存的页面，可能导致Belady异常：为进程分配的物理块增多时，缺页中断不减反增的异常现象 3.1.3 最近最久未使用置换算法LRU 将前面最久没有使用过的页面置换，性能最接近OPT算法，但是实现困难，需要硬件支持，开销大 3.1.4 时钟置换算法CLOCK 将页面链接成循环队列，并增加访问位。访问过的页面访问位置为1；缺页中断时遇到访问位为1则置0，为0则置换，循环扫描 3.1.5 改进时钟算法 思想：被淘汰的页面如果没被修改，不需要写回外存浪费I/O，因此优先置换没被修改、没被访问的页面(访问位，修改位)为(0,0) 在CLOCK算法基础上增加修改位。先扫描第一个(0,0)置换，不修改标志位；再扫描第一个(0,1)置换，访问位置0；再扫描第一个(0,0)置换，不修改标志位；再扫描第一个(0,1)置换 "},"3.操作系统/5.死锁与处理.html":{"url":"3.操作系统/5.死锁与处理.html","title":"5.死锁与处理","keywords":"","body":"死锁 1. 死锁的四个必要条件 互斥条件：对临界区资源的争抢 不剥夺条件：资源只能由进程主动释放，不能被抢夺 请求和保持条件：进程拥有了至少一个临界区资源，同时对其他临界区资源进行请求 循环等待条件：存在资源的循环等待环，每个进程的已拥有资源被下一个进程所请求 2. 预防死锁 破坏某个或多个必要条件 破坏互斥条件 方式：将互斥使用资源改为允许共享使用。例：用SPOOLing技术把独占设备改造成共享设备，如改造打印机。 缺点：不是所有资源都可以改造 破坏不剥夺条件 方式：进程请求资源得不到满足时，主动释放已保持的资源，操作系统将优先级更高进程想要的资源强行剥夺 缺点：1.实现复杂；2.重复请求释放资源导致低效；3.有可能会导致进程饥饿 破坏请求和保持条件 方式：静态分配，运行之前一次性分配需要的全部资源 缺点：1.资源利用率低；2.会导致进程饥饿 破坏循环等待条件 方式：顺序资源分配，给系统资源编号，必须按编号递增的顺序请求资源，已持有大编号的进程就不能逆向申请小编号资源 缺点：1.不方便增加新的设备；2.使用资源顺序和递增顺序可能不一致，导致资源浪费；3.用户编程实现比较麻烦 3. 避免死锁(银行家算法) 思想：在资源分配之前先判断是否会导致系统进入不安全状态 步骤： 1.找出进程最大需求矩阵和已分配资源列表，计算各进程的need矩阵(待分配资源) 2.将系统可用资源列表和每个进程的need列表对比，将能够满足待分配的进程加入安全序列，同时将该进程所有资源回收 3.依次将各个进程加入安全序列 4. 死锁的检测和解除 允许死锁发生，然后检测出死锁并采取措施接触死锁 死锁检测 死锁检测算法化简资源分配图 死锁解除 资源剥夺法 终止进程法 进程回退法 "},"3.操作系统/6.文件管理.html":{"url":"3.操作系统/6.文件管理.html","title":"6.文件管理","keywords":"","body":"文件管理 文件的物理结构 连续分配(类似于顺序表) 每个文件在磁盘上占有一组连续的块 支持顺序访问和随机访问，在顺序读写时速度最快 存在大量磁盘碎片，存储空间利用率低，同时不方便拓展文件链接分配 隐式链接(类似于链表) 每个磁盘块保存指向下一个块的指针 只支持顺序访问，不支持随机访问 查找效率低，指针耗费少量空间，但是不会产生碎片，空间利用率高 显示链接 将链接文件物理块的指针存放在文件分配表(FAT)中 一个磁盘仅设置一张FAT，并常驻内存 块号转换不需要访问磁盘，因此支持顺序访问也支持随机访问索引分配 每个文件建立一张索引表(类似于页表)，记录文件各逻辑块对应的物理块。索引表存放的磁盘块成为索引块 一个文件对应一张索引表，支持随机访问，蛋索引表占据存储空间文件存储空间管理 几种管理方法 空闲表法 空闲链表法 空闲盘块链 空闲盘区链 位示图法 成组链接法文件共享 基于索引结点的共享(硬链接) 将除了文件名之外的其他信息放到索引结点中 删除文件时只删除了目录项，且cnt--, cnt为0时才真正删除基于符号链的共享(软链接) link类型文件，类似于\"快捷方式\"，记录了文件的存放路径 软链接指向的文件删除时，软链接仍存在 Linux文件系统 详见Linux文件系统 "},"3.操作系统/7.锁的分类.html":{"url":"3.操作系统/7.锁的分类.html","title":"7.锁的分类","keywords":"","body":"锁 1. 重量级锁 如果你学过多线程，那么你肯定知道锁这个东西，至于为什么需要锁，我就不给你普及了，就当做你是已经懂的了。 我们知道，我们要进入一个同步、线程安全的方法时，是需要先获得这个方法的锁的，退出这个方法时，则会释放锁。如果获取不到这个锁的话，意味着有别的线程在执行这个方法，这时我们就会马上进入阻塞的状态，等待那个持有锁的线程释放锁，然后再把我们从阻塞的状态唤醒，我们再去获取这个方法的锁。 这种获取不到锁就马上进入阻塞状态的锁，我们称之为重量级锁。 1.1 自旋锁 线程从运行态进入阻塞态这个过程，是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到用户态到内核态的转换。当然，把线程从阻塞态唤醒也是一样，也是非常消耗时间的。 刚才我说线程拿不到锁，就会马上进入阻塞状态，然而现实是，它虽然这一刻拿不到锁，可能在下 0.0001 秒，就有其他线程把这个锁释放了。如果它慢0.0001秒来拿这个锁的话，可能就可以顺利拿到了，不需要经历阻塞/唤醒这个花时间的过程了。 然而重量级锁就是这么坑，它就是不肯等待一下，一拿不到就是要马上进入阻塞状态。为了解决这个问题，我们引入了另外一种愿意等待一段时间的锁 --- 自旋锁。 自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看看这段时间有没其他人把这锁给释放了。怎么等呢？这个就类似于线程在那里做空循环，如果循环一定的次数还拿不到锁，那么它才会进入阻塞的状态。 至于是循环等待几次，这个是可以人为指定一个数字的。 1.2 自适应自旋锁 自旋锁每个线程循环等待的次数都是一样的，例如设置为 100次的话，那么线程在空循环 100 次之后还没拿到锁，就会进入阻塞状态了。 自适应自旋锁不需要我们人为指定循环几次，它自己本身会进行判断要循环几次，而且每个线程可能循环的次数也是不一样的。而之所以这样做，主要是我们觉得，如果一个线程在不久前拿到过这个锁，或者它之前经常拿到过这个锁，那么我们认为它再次拿到锁的几率非常大，所以循环的次数会多一些。 而如果有些线程从来就没有拿到过这个锁，或者说，平时很少拿到，那么我们认为，它再次拿到的概率是比较小的，所以我们就让它循环的次数少一些。因为你在那里做空循环是很消耗 CPU 的。 所以这种能够根据线程最近获得锁的状态来调整循环次数的自旋锁，我们称之为自适应自旋锁。 2. 轻量级锁 2.1 CAS 上面我们介绍的三种锁：重量级、自旋锁和自适应自旋锁，他们都有一个特点，就是进入一个方法的时候，就会加上锁，退出一个方法的时候，也就释放对应的锁。 之所以要加锁，是因为他们害怕自己在这个方法执行的时候，被别人偷偷进来了，所以只能加锁，防止其他线程进来。这就相当于，每次离开自己的房间，都要锁上门，人回来了再把锁解开。 这实在是太麻烦了，如果根本就没有线程来和他们竞争锁，那他们不是白白上锁了？要知道，加锁这个过程是需要操作系统这个大佬来帮忙的，是很消耗时间的，。为了解决这种动不动就加锁带来的开销，轻量级锁出现了。 轻量级锁认为，当你在方法里面执行的时候，其实是很少刚好有人也来执行这个方法的，所以，当我们进入一个方法的时候根本就不用加锁，我们只需要做一个标记就可以了，也就是说，我们可以用一个变量来记录此时该方法是否有人在执行。也就是说，如果这个方法没人在执行，当我们进入这个方法的时候，采用CAS机制，把这个方法的状态标记为已经有人在执行，退出这个方法时，在把这个状态改为了没有人在执行了。 之所以要用CAS机制来改变状态，是因为我们对这个状态的改变，不是一个原子性操作，所以需要CAS机制来保证操作的原子性。不知道CAS的可以看这篇文章：并发的核心：CAS 是什么？Java8是如何优化 CAS 的？。 显然，比起加锁操作，这个采用CAS来改变状态的操作，花销就小多了。 然而可能会说，没人来竞争的这种想法，那是你说的而已，那如果万一有人来竞争说呢？也就是说，当一个线程来执行一个方法的时候，方法里面已经有人在执行了。 如果真的遇到了竞争，我们就会认为轻量级锁已经不适合了，我们就会把轻量级锁升级为重量级锁了。 所以轻量级锁适合用在那种，很少出现多个线程竞争一个锁的情况，也就是说，适合那种多个线程总是错开时间来获取锁的情况。 偏向锁 偏向锁就更加牛逼了，我们已经觉得轻量级锁已经够轻，然而偏向锁更加省事，偏向锁认为，你轻量级锁每次进入一个方法都需要用CAS来改变状态，退出也需要改变，多麻烦。 偏向锁认为，其实对于一个方法，是很少有两个线程来执行的，搞来搞去，其实也就一个线程在执行这个方法而已，相当于单线程的情况，居然是单线程，那就没必要加锁了。 不过毕竟实际情况的多线程，单线程只是自己认为的而已了，所以呢，偏向锁进入一个方法的时候是这样处理的：如果这个方法没有人进来过，那么一个线程首次进入这个方法的时候，会采用CAS机制，把这个方法标记为有人在执行了，和轻量级锁加锁有点类似，并且也会把该线程的 ID 也记录进去，相当于记录了哪个线程在执行。 然后，但这个线程退出这个方法的时候，它不会改变这个方法的状态，而是直接退出来，懒的去改，因为它认为除了自己这个线程之外，其他线程并不会来执行这个方法。 然后当这个线程想要再次进入这个方法的时候，会判断一下这个方法的状态，如果这个方法已经被标记为有人在执行了，并且线程的ID是自己，那么它就直接进入这个方法执行，啥也不用做 你看，多方便，第一次进入需要CAS机制来设置，以后进出就啥也不用干了，直接进入退出。 然而，现实总是残酷的，毕竟实际情况还是多线程，所以万一有其他线程来进入这个方法呢？如果真的出现这种情况，其他线程一看这个方法的ID不是自己，这个时候说明，至少有两个线程要来执行这个方法论，这意味着偏向锁已经不适用了，这个时候就会从偏向锁升级为轻量级锁。 偏向锁适用于那种，始终只有一个线程在执行一个方法的情况 悲观锁和乐观锁 最开始我们说的三种锁，重量级锁、自旋锁和自适应自旋锁，进入方法之前，就一定要先加一个锁，这种我们为称之为悲观锁。悲观锁总认为，如果不事先加锁的话，就会出事，这种想法确实悲观了点，这估计就是悲观锁的来源了。 而乐观锁却相反，认为不加锁也没事，我们可以先不加锁，如果出现了冲突，我们在想办法解决，例如 CAS 机制，上面说的轻量级锁，就是乐观锁的。不会马上加锁，而是等待真的出现了冲突，在想办法解决。 "},"4.TCP-IP详解/":{"url":"4.TCP-IP详解/","title":"第四部分 TCP/IP详解","keywords":"","body":"常见面试题 面试题：一次完整的HTTP请求过程/从输入url到页面展现发生了什么？ 三次握手和四次挥手详解 socket流程 [可靠UDP] "},"4.TCP-IP详解/1.TCP-IP网络模型.html":{"url":"4.TCP-IP详解/1.TCP-IP网络模型.html","title":"1.TCP/IP网络模型","keywords":"","body":"网络协议模型 OSI参考模型是国际标准，TCP/IP模型是这一标准的具体实现 物理层：定义物理设备标准，如网线接口类型、介质传输速率。面向比特流(Bit) 数据链路层：主机间通信。数据链路层在不可靠的物理介质上提供可靠的传输。面向以太网帧(Frame) 网络层：网络层负责对子网间的数据包进行路由选择，以及实现拥塞控制、网络互连等功能。面向数据包(Packet) 传输层：传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话，即端口到端口的连接(Segment) 会话层、表示层、应用层：规定应用程序的数据格式 分层 作用 协议 物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器） 数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机） 网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器） 运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX 会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC 表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII 应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS TCP/IP数据包封装 用户数据自顶向下层层封装，传输到目的主机再自底向上得到用户数据。 "},"4.TCP-IP详解/2.网络接口层.html":{"url":"4.TCP-IP详解/2.网络接口层.html","title":"2.网络接口层","keywords":"","body":"网络接口层 以太网帧首部 目的地址/源地址：通信双方的MAC地址，目的地址未知时用FF:FF:FF:FF:FF:FF填充 类型：协议类型编码 数据：不超过最大传输单元MTU(1500)字节，因此以太网帧范围为64~1518。MTU的选择是资源占用和效率的综合考量 CRC：尾部校验，提供差错控制 MAC地址： 网卡的硬件地址，6字节48位，前24位用于分配给不同厂商，后24位厂商自己分配，全球唯一。系统中的MAC地址是ARP协议ROM中记录的硬件地址，是可以修改的，因此可能有两个相同的MAC地址 ARP协议 作用：获取局域网中目标主机的物理地址(MAC地址) ARP协议流程 检查ARP缓存表，查看目的主机是否有IP地址对应的目的MAC； 目的地址未知时用FF:FF:FF:FF:FF:FF填充，并发送广播帧，交换机将广播帧转发 所有收到帧的主机会解析目的地址为FF:FF:FF:FF:FF:FF的以太帧，如果IP地址符合则接收，并将其IP和MAC记录到ARP缓存表，同时发送ARP应答 源主机收到应答后记录目的主机的MAC地址 RARP协议 作用：利用MAC地址获取目标主机的IP地址(已经被DHCP协议取代) RARP协议流程 发送主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址； 本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址； 如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；如果不存在，RARP服务器对此不做任何的响应； 源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。 "},"4.TCP-IP详解/3.网络层.html":{"url":"4.TCP-IP详解/3.网络层.html","title":"3.网络层","keywords":"","body":"IP协议 IP首部格式 4位版本：指明IPv4或IPv6 总长度字段：整个IP数据报的长度，字节为单位 16位标识：唯一标识主机发送的每一份数据报，通常每发送一份报文值就加1 3位标志：前1位保留，第2位DF不分片标志，DF=0表示已经分片；第3位MF更多分片，MF=0表示该数据报是最后一个分片 8位生存时间TTL：当前主机到目的主机的路由器间最大跳数，每经过一个路由器便减1，TTL=0则丢弃数据报。目的为了防止出现循环回路，且TTL=0时会发送不可达ICMP给源IP 13位偏移量：以8字节为单位，计算从数据报开始的片段偏移量 IP分片 作用：IP数据报最大长度65535字节，超过了链路层最大传输单元MTU的限制。 分片缺点： IP层没有超时重传机制，一个分片丢失，所有分片都要依赖传输层协议重传一遍，降低传输数据的成功率 分片、重组带来性能消耗 有安全隐患 因此IPv6不允许路由器执行分片，在发送数据包之前确定MTU 避免IP分片 TCP协议通过三次握手的过程，互相通告最大报文段长度MSS(MTU1500 - IP首部20 - TCP首部20 = 1460字节)，每次发送数据不会超过MSS UDP包在应用层限制每个包大小不超过MTU1500 - IP首部20 - UDP首部8 = 1472字节 IP选路 概念：搜索路由表并决定向哪个网络接口发送分组 相关命令 列出主机当前路由表netstat -rn 手动添加路由route 路由表 目的网络IP地址 子网掩码 下一跳IP地址 接口 路由表包含： 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。 子网掩码（subnet mask）：用来判断 IP 所属网络 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。 根据应用和执行的不同，路由表可能含有如下附加信息： 花费（Cost）：就是数据发送过程中通过路径所需要的花费。 路由的服务质量 路由中需要过滤的出/入连接列表 ICMP协议 作用：ICMP封装在IP数据报内部，用来发送网络控制消息，包括主机探测、路由维护、IP选路等 报文分类 应用： PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性 TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量 NAT协议 http://www.52im.net/thread-50-1-1.html NAT穿透 http://www.52im.net/thread-50-1-1.html "},"4.TCP-IP详解/4.传输层.html":{"url":"4.TCP-IP详解/4.传输层.html","title":"4.传输层","keywords":"","body":"1. UDP协议 UDP封装 UDP首部 特点： 无连接 尽最大努力交付 面向应用程序交付的报文(对报文不拆分不合并) 没有流量控制 支持一对一、多对多的交互通信(视频、语音等) 拓展：可靠UDP 移步TCP、IP面试题 2. TCP协议 首部格式 TCP首部 序号seq：16位(4字节)，本报文段发送第一个字节的序号 确认号ack：16位，期望收到的下一个报文的seq 数据偏移：首部长度 ACK：只有ACK=1时，确认号ack才有效 复位RST：表明连接中出现严重差错，需要重新建立连接 同步SYN：仅用于建立连接时，SYN=1表示请求连接或接受连接 终止FIN：仅用于释放连接，FIN=1表示数据发送完毕，请求释放连接 窗口字段：向对方建议发送窗口的大小 选项字段：包括最大报文段长度MSS等 TCP连接特点： 面向连接 提供全双工通信 每个连接只能有两个端点(一对一) 提供可靠交付的服务 面向字节流连接控制 三次握手 四次挥手 面试官，不要再问我三次握手和四次挥手 请画出三次握手和四次挥手的示意图 为什么连接的时候是三次握手？ 什么是半连接队列？ ISN(Initial Sequence Number)是固定的吗？ 三次握手过程中可以携带数据吗？ 如果第三次握手丢失了，客户端服务端会如何处理？ 服务端状态为SYN_RECV,并且会根据TCP的超时重传机制，会等待1秒、2秒、4秒后重新发送SYN+ACK包，以便Client重新发送ACK包如果重传都一直失败，会在指数退避达64s后发RTS包，断开连接。 SYN攻击是什么？ 挥手为什么需要四次？ 四次挥手释放连接时，等待2MSL的意义?TIME_WAIT、CLOSE_WAIT TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭 流量控制 滑动窗口 慢启动 拥塞避免 超时重传 快速重传 快速恢复 TCP黏包 原因：TCP为了保证可靠传输并减少额外的开销，采用基于字节流的传输服务（UDP 基于报文的），TCP所传输的数据是没有消息边界的，所以可能会出现两个数据包黏在一起的情况。 TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事： 只有上一个分组得到确认，才会发送下一个分组 收集多个小分组，在一个确认到来时一起发送 举例：客户端调用两次send()发送1k和2k大小的数据，服务端调用一次recv()读出3k大小的数据 解决： 发送方： 对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。 应用层 接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。 应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。 循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？ 格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。 发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。 "},"4.TCP-IP详解/5.应用层.html":{"url":"4.TCP-IP详解/5.应用层.html","title":"5.应用层","keywords":"","body":" 1. 域名解析DNS协议 域名系统（DNS）是一个分布的数据库，由它来提供IP地址和域名之间的映射信息 https://www.jianshu.com/p/766bef2f6470 名字空间 DNS指针查询 DNS缓存 2. FTP协议 工作模式 PASV PORT 指令和响应码 断点续传 匿名FTP 3. 超文本传输HTTP协议 面试题1：一次完整的HTTP请求过程 面试题2：你知道一个TCP连接上能发起多少个HTTP请求吗？ 报文格式 请求报文 请求行：由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如：GET /index.html HTTP/1.1 请求头部：由关键字/值对组成，每行一对，关键字和值用:分隔。请求头部通知服务器有关于客户端请求的信息 空行：回车符和换行符，通知服务器不再有请求头 请求数据：不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合 请求方法： | 方法 | 意义 | | ------- | ------------------------------------------------------------------------------------------------------------------------------------- | | OPTIONS | 请求一些选项信息，允许客户端查看服务器的性能 | | GET | 请求指定的页面信息，并返回实体主体 | | HEAD | 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头 | | POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改 | | PUT | 从客户端向服务器传送的数据取代指定的文档的内容 | | DELETE | 请求服务器删除指定的页面 | | TRACE | 回显服务器收到的请求，主要用于测试或诊断 | 响应报文 HTTP状态码 4. HTTPS协议 https://www.jianshu.com/p/9b18791bc01b 详细握手过程 安全算法 HTTPS 是如何解决上面的三个风险的？ 对称加密和非对称加密结合的「混合加密」方式，解决了窃听的风险。 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。 将服务器公钥放入到数字证书中，解决了冒充的风险。 摘要算法 摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。 数字签名 数字证书 客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。 这就存在些问题，如何保证公钥不被篡改和信任度？所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。 HTTP和HTTPS区别 HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。 HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。 HTTP 的端口号是 80，HTTPS 的端口号是 443。 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 附：常用端口号 端口号 服务 21端口 FTP 文件传输服务 22端口 SSH 端口 23端口 TELNET 终端仿真服务 25端口 SMTP 简单邮件传输服务 53端口 DNS 域名解析服务 80端口 HTTP 超文本传输服务 110端口 POP3 “邮局协议版本3”使用的端口 443端口 HTTPS 加密的超文本传输服务 1433端口 MS SQL*SERVER数据库 默认端口号 1521端口 Oracle数据库服务 1863端口 MSN Messenger的文件传输功能所使用的端口 3306端口 MYSQL 默认端口号 3389端口 Microsoft RDP 微软远程桌面使用的端口 5631端口 Symantec pcAnywhere 远程控制数据传输时使用的端口 5632端口 Symantec pcAnywhere 主控端扫描被控端时使用的端口 5000端口 MS SQL Server使用的端口 8000端口 腾讯QQ "},"4.TCP-IP详解/6.socket网络编程.html":{"url":"4.TCP-IP详解/6.socket网络编程.html","title":"6.socket网络编程","keywords":"","body":"Socket 网络编程(套接字编程)就是编写程序使两台联网的计算机互相交换数据，而套接字就是用来连接网络的工具。 网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用open –> write/read –> close模式来操作。 网络中进程之间如何通信？ socket是一个五元组 源IP：源端口 目的IP：目的端口 协议(UDP/TCP) 就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。 socket流程 #include #include \"Client.h\" using namespace std; // 客户端类成员函数 // 客户端类构造函数 Client::Client(){ // 初始化要连接的服务器地址和端口 serverAddr.sin_family = PF_INET; serverAddr.sin_port = htons(SERVER_PORT); serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP); // 初始化socket sock = 0; // 初始化进程号 pid = 0; // 客户端状态 isClientwork = true; // epool fd epfd = 0; } // 连接服务器 void Client::Connect() { cout 0 父进程 //父进程负责读管道数据，因此先关闭写端 close(pipe_fd[1]); // 主循环(epoll_wait) while(isClientwork) { int epoll_events_count = epoll_wait( epfd, events, 2, -1 ); //处理就绪事件 for(int i = 0; i Tips:在Linux上，可使用man命令去查询每一个函数或者头文件 生成套接字socket() #include int socket(int domain, int type, int protocol); 返回: 成功：套接字文件描述符 失败：-1 绑定地址bind() #include int bind(int socket, const struct sockaddr *address, socklen_t address_len); 返回： 成功：0 失败：-1 监听连接listen() #include int listen(int socket, int backlog); 返回： 成功：0 失败：-1 接受请求accept() #include int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 返回： 成功：返回请求连接端的套接字文件描述符 失败：-1 请求连接connect() #include int connect(int socket, const struct sockaddr *address, socklen_t address_len); 返回： 成功：0 失败：-1 Linux文件操作 在Linux里，socket也被认为是文件的一种，故在网络传输过程中亦可使用文件I/O的相关函数。 文件描述符(文件句柄) 文件描述符是系统分配给文件或套接字的整数。 系统文件描述符 文件描述符 对象 0 标准输入：Standard Input 1 标准输出：Standard Output 2 标准错误：Standard Error I/O函数 打开文件open() #include #include #include int open(const char *path, int flag); 返回： 成功：返回文件描述符 失败：-1 文件打开模式(flag)： 打开模式 含义 O_CREAT 必要时创建文件 O_TRUNC 删除全部现有数据 O_APPEND 追加到已有数据后面 O_RDONLY 只读打开 O_WRONLY 只写打开 O_RDWR 读写打开 关闭文件 使用文件后必须关闭close() #include int close(int fd); 返回： 成功：0 失败：-1 写文件write() #include ssize_t write(int fd, const void *buf, size_t nbytes); 返回： 成功：返回写入的字节数 失败：-1 读文件read() #include int read(int fd, void *buf, size_t nbytes); 返回： 成功：返回接收的字节数，遇到文件尾(EOF)则返回0 失败：-1 主机字节序与网络字节序 主机字节序 概念：主机字节序又叫CPU字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。 单字符来说是没有字节序问题的 主机字节序分为两种： 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址 存储方式 32 位整数0x12345678是从起始位置为0x00的地址开始存放，则： 内存地址 0x00 0x01 0x02 0x03 大端 12 34 56 78 小端 78 56 34 12 大端 小端 判断大端、小端 // 判断大端、小端 int i = 0x12345678; if (*((char*)&i) == 0x12) cout 网络字节序 网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保重数据在不同主机之间传输时能够被正确解释。 网络字节顺序采用：大端（Big Endian）排列方式。 "},"4.TCP-IP详解/7.select、poll与epoll.html":{"url":"4.TCP-IP详解/7.select、poll与epoll.html","title":"7.selcet, poll与epoll","keywords":"","body":"// TODO poll epoll select、poll和epoll区别 "},"4.TCP-IP详解/8.信息安全.html":{"url":"4.TCP-IP详解/8.信息安全.html","title":"8.信息安全","keywords":"","body":"// TODO SQL注入 "},"4.TCP-IP详解/附：可靠性UDP.html":{"url":"4.TCP-IP详解/附：可靠性UDP.html","title":"附：可靠性UDP","keywords":"","body":"可靠UDP 如何让不可靠的UDP变的可靠？ https://www.jianshu.com/p/4d12ad2e7500 可靠的UDP协议KCP https://www.cnblogs.com/wetest/p/9190786.html QUIC协议 "},"4.TCP-IP详解/附：一次完整的HTTP请求过程.html":{"url":"4.TCP-IP详解/附：一次完整的HTTP请求过程.html","title":"附：一次完整的HTTP请求过程","keywords":"","body":""},"5.数据库/":{"url":"5.数据库/","title":"第五部分 数据库","keywords":"","body":" 面试题：SQL语句执行很慢的原因 "},"5.数据库/1.数据库原理.html":{"url":"5.数据库/1.数据库原理.html","title":"1.数据库原理","keywords":"","body":"数据库体系结构 数据（data）：描述事物的符号记录称为数据。 数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点（，数据库即是一个文件）。 数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。 数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。 数据库完整性 数据库的完整性是指数据的正确性和相容性。 完整性：为了防止数据库中存在不符合语义（不正确）的数据。 安全性：为了保护数据库防止恶意破坏和非法存取。 触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。 关系数据理论 数据依赖 数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。 最重要的数据依赖：函数依赖、多值依赖。 范式 第一范式（1NF）：属性（字段）是最小单位不可再分。 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）。 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。 事务 事务的 ACID 特性 A 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 C 一致性：要求同一事务中的SQL语句，必须保证同时成功或者失败。 I 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 D 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 在MySQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 事务的隔离性 事务的隔离性可分为四种 ( 性能从高到低，安全性从低到高 ) ： READ UNCOMMITTED ( 读取未提交 ) 如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。 READ COMMITTED ( 读取已提交 ) 只能读取到其他事务已经提交的数据。 REPEATABLE READ ( 可被重复读 ) 如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。 SERIALIZABLE ( 串行化 ) 所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。 并发控制 事务隔离级别 脏读 不可重复读 幻读 读未提交（READ UNCOMMITTED） 是 是 是 不可重复读（READ COMMITTED） 否 是 是 可重复读（REPEATABLE READ） 否 否 是 串行化（SERIALIZABLE） 否 否 否 事务的并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 乐观锁与悲观锁 见操作系统死锁与处理 基本概念 实体：客观存在可相互区别的事物 属性：实体具有的某一特性 联系：实体之间的联系通常是指不同实体集之间的联系。 码：唯一标识实体的属性集。 实体型 比如学生 实体集 比如全体学生 模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。 常用数据模型 • 层次模型（hierarchical model） • 网状模型（network model） • 面向对象数据模型（object oriented data model） • 对象关系数据模型（object relational data model） • 半结构化数据模型（semistructure data model） • 关系模型（relational model） 关系模型 关系（relation）：一个关系对应通常说的一张表 元组（tuple）：表中的一行即为一个元组 属性（attribute）：表中的一列即为一个属性 码（key）：表中可以唯一确定一个元组的某个属性组 超码：能在关系中唯一标志一个元组 候选码：最小超码 主键：用户明确定义的候选码，通常用下划线标记 外码：关系R上的属性B在关系S上是主键，则R上的属性B是参照S的外码，R为外码依赖的参照关系 域（domain）：一组具有相同数据类型的值的集合D1,D2,...Dn D_1,D_2,...D_n D​1​​,D​2​​,...D​n​​ 分量：元组中的一个属性值 关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, ..., 属性n) 笛卡儿积：每个域的基数相乘=行数，$ D_i $域的笛卡尔积D1×D2×...×Dn {D_1}\\times{D_2}\\times{...}\\times{D_n} D​1​​×D​2​​×...×D​n​​ 关系操作 基本关系操作： 查询： 选择Select 运算符σ\\sigma σ，选择指定条件构成新关系 投影Project 运算符Π\\PiΠ，投影指定属性名构成新关系，去除其中数据重复 连接(等值连接 自然连接Natural join 外连接) 运算符⋈ \\bowtie ⋈两个关系必须有同名属性，连接两个关系同名属性值相等的元组 除Division 并Union 运算符∪\\cup∪ 差set difference r−sr-sr−s，在r里去除s出现的元组 交Set intersection 运算符∩\\cap∩ 笛卡尔积Cartesian product 运算符r×sr\\times sr×s 插入 删除 修改： 赋值Assignment ρX(A1,...An)(E)\\rho {_X(A1,...An)}(E)ρ​X​​(A1,...An)(E)返回E的结果，对关系E及属性重命名，也可以只重命名属性或关系名 重命名Rename 运算符示例： σA=C(r×s)\\sigma_{A=C}(r \\times s) σ​A=C​​(r×s) 选择属性A=C的 ΠA,C(r)\\Pi_{A,C}(r)Π​A,C​​(r) 投影关系r属性名AC的两列，并去除数据重复 "},"5.数据库/2.MySQL基础操作.html":{"url":"5.数据库/2.MySQL基础操作.html","title":"2.MySQL基础操作","keywords":"","body":"MySQL学习笔记 基本操作 登录和退出MySQL服务器 # 启动mysql服务器 sudo service mysql start # 登录MySQL $ mysql -u root -p12345612 # 退出MySQL数据库服务器 exit; # 停止mysql服务器 sudo service mysql stop 创建CREATE -- 创建数据库 CREATE DATABASE test; -- 创建数据表 CREATE TABLE pet ( name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE ); 显示SHOW -- 显示所有数据库 SHOW DATABASES; -- 创建数据库 CREATE DATABASE test; -- 切换数据库 use test; -- 显示数据库中的所有表 show tables; -- 创建数据表 CREATE TABLE pet ( name VARCHAR(20), owner VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth DATE, death DATE ); -- 查看数据表结构 -- describe pet; desc pet; -- 查询表 SELECT * from pet; -- 插入数据 INSERT INTO pet VALUES ('puffball', 'Diane', 'hamster', 'f', '1990-03-30', NULL); -- 修改数据 UPDATE pet SET name = 'squirrel' where owner = 'Diane'; -- 删除数据 DELETE FROM pet where name = 'squirrel'; -- 删除表 DROP TABLE myorder; 建表约束 主键约束 -- 主键约束 -- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。 CREATE TABLE user ( id INT PRIMARY KEY, name VARCHAR(20) ); -- 联合主键 -- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。 CREATE TABLE user ( id INT, name VARCHAR(20), password VARCHAR(20), PRIMARY KEY(id, name) ); -- 自增约束 -- 自增约束的主键由系统自动递增分配。 CREATE TABLE user ( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20) ); -- 添加主键约束 -- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）： ALTER TABLE user ADD PRIMARY KEY(id); ALTER TABLE user MODIFY id INT PRIMARY KEY; -- 删除主键 ALTER TABLE user drop PRIMARY KEY; 唯一主键 -- 建表时创建唯一主键 CREATE TABLE user ( id INT, name VARCHAR(20), UNIQUE(name) ); -- 添加唯一主键 -- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）： ALTER TABLE user ADD UNIQUE(name); ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE; -- 删除唯一主键 ALTER TABLE user DROP INDEX name; 非空约束 -- 建表时添加非空约束 -- 约束某个字段不能为空 CREATE TABLE user ( id INT, name VARCHAR(20) NOT NULL ); -- 移除非空约束 ALTER TABLE user MODIFY name VARCHAR(20); 默认约束 -- 建表时添加默认约束 -- 约束某个字段的默认值 CREATE TABLE user2 ( id INT, name VARCHAR(20), age INT DEFAULT 10 ); -- 移除非空约束 ALTER TABLE user MODIFY age INT; 外键约束 -- 班级 CREATE TABLE classes ( id INT PRIMARY KEY, name VARCHAR(20) ); -- 学生表 CREATE TABLE students ( id INT PRIMARY KEY, name VARCHAR(20), -- 这里的 class_id 要和 classes 中的 id 字段相关联 class_id INT, -- 表示 class_id 的值必须来自于 classes 中的 id 字段值 FOREIGN KEY(class_id) REFERENCES classes(id) ); -- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的； -- 2. 主表中的记录被副表引用时，主表不可以被删除。 数据库的三大设计范式 1NF 只要字段值还可以继续拆分，就不满足第一范式。 范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。 2NF 在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下： -- 订单表 CREATE TABLE myorder ( product_id INT, customer_id INT, product_name VARCHAR(20), customer_name VARCHAR(20), PRIMARY KEY (product_id, customer_id) ); 实际上，在这张订单表中，product_name 只依赖于 product_id ，customer_name 只依赖于 customer_id 。也就是说，product_name 和 customer_id 是没用关系的，customer_name 和 product_id 也是没有关系的。 这就不满足第二范式：其他列都必须完全依赖于主键列！ CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT ); CREATE TABLE product ( id INT PRIMARY KEY, name VARCHAR(20) ); CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20) ); 拆分之后，myorder 表中的 product_id 和 customer_id 完全依赖于 order_id 主键，而 product 和 customer 表中的其他字段又完全依赖于主键。满足了第二范式的设计！ 3NF 在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。 CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT, customer_phone VARCHAR(15) ); 表中的 customer_phone 有可能依赖于 order_id 、 customer_id 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。 CREATE TABLE myorder ( order_id INT PRIMARY KEY, product_id INT, customer_id INT ); CREATE TABLE customer ( id INT PRIMARY KEY, name VARCHAR(20), phone VARCHAR(15) ); "},"5.数据库/3.MYSQL查询.html":{"url":"5.数据库/3.MYSQL查询.html","title":"3.MySQL查询","keywords":"","body":"查询 准备数据 -- 创建数据库 CREATE DATABASE select_test; -- 切换数据库 USE select_test; -- 创建学生表 CREATE TABLE student ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, -- 生日 class VARCHAR(20) -- 所在班级 ); -- 创建教师表 CREATE TABLE teacher ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, sex VARCHAR(10) NOT NULL, birthday DATE, profession VARCHAR(20) NOT NULL, -- 职称 department VARCHAR(20) NOT NULL -- 部门 ); -- 创建课程表 CREATE TABLE course ( no VARCHAR(20) PRIMARY KEY, name VARCHAR(20) NOT NULL, t_no VARCHAR(20) NOT NULL, -- 教师编号 -- 表示该 tno 来自于 teacher 表中的 no 字段值 FOREIGN KEY(t_no) REFERENCES teacher(no) ); -- 成绩表 CREATE TABLE score ( s_no VARCHAR(20) NOT NULL, -- 学生编号 c_no VARCHAR(20) NOT NULL, -- 课程号 degree DECIMAL, -- 成绩 -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值 FOREIGN KEY(s_no) REFERENCES student(no), FOREIGN KEY(c_no) REFERENCES course(no), -- 设置 s_no, c_no 为联合主键 PRIMARY KEY(s_no, c_no) ); -- 查看所有表 SHOW TABLES; -- 添加学生表数据 INSERT INTO student VALUES('101', '曾华', '男', '1977-09-01', '95033'); INSERT INTO student VALUES('102', '匡明', '男', '1975-10-02', '95031'); INSERT INTO student VALUES('103', '王丽', '女', '1976-01-23', '95033'); INSERT INTO student VALUES('104', '李军', '男', '1976-02-20', '95033'); INSERT INTO student VALUES('105', '王芳', '女', '1975-02-10', '95031'); INSERT INTO student VALUES('106', '陆军', '男', '1974-06-03', '95031'); INSERT INTO student VALUES('107', '王尼玛', '男', '1976-02-20', '95033'); INSERT INTO student VALUES('108', '张全蛋', '男', '1975-02-10', '95031'); INSERT INTO student VALUES('109', '赵铁柱', '男', '1974-06-03', '95031'); -- 添加教师表数据 INSERT INTO teacher VALUES('804', '李诚', '男', '1958-12-02', '副教授', '计算机系'); INSERT INTO teacher VALUES('856', '张旭', '男', '1969-03-12', '讲师', '电子工程系'); INSERT INTO teacher VALUES('825', '王萍', '女', '1972-05-05', '助教', '计算机系'); INSERT INTO teacher VALUES('831', '刘冰', '女', '1977-08-14', '助教', '电子工程系'); -- 添加课程表数据 INSERT INTO course VALUES('3-105', '计算机导论', '825'); INSERT INTO course VALUES('3-245', '操作系统', '804'); INSERT INTO course VALUES('6-166', '数字电路', '856'); INSERT INTO course VALUES('9-888', '高等数学', '831'); -- 添加添加成绩表数据 INSERT INTO score VALUES('103', '3-105', '92'); INSERT INTO score VALUES('103', '3-245', '86'); INSERT INTO score VALUES('103', '6-166', '85'); INSERT INTO score VALUES('105', '3-105', '88'); INSERT INTO score VALUES('105', '3-245', '75'); INSERT INTO score VALUES('105', '6-166', '79'); INSERT INTO score VALUES('109', '3-105', '76'); INSERT INTO score VALUES('109', '3-245', '68'); INSERT INTO score VALUES('109', '6-166', '81'); -- 查看表结构 SELECT * FROM course; SELECT * FROM score; SELECT * FROM student; SELECT * FROM teacher; 1 到 10 -- 查询 student 表的所有行 SELECT * FROM student; -- 查询 student 表中的 name、sex 和 class 字段的所有行 SELECT name, sex, class FROM student; -- 查询 teacher 表中不重复的 department 列 -- department: 去重查询 SELECT DISTINCT department FROM teacher; -- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询） -- BETWEEN xx AND xx: 查询区间, AND 表示 \"并且\" SELECT * FROM score WHERE degree BETWEEN 60 AND 80; SELECT * FROM score WHERE degree > 60 AND degree 分组计算平均成绩 查询每门课的平均成绩。 -- AVG: 平均值 SELECT AVG(degree) FROM score WHERE c_no = '3-105'; SELECT AVG(degree) FROM score WHERE c_no = '3-245'; SELECT AVG(degree) FROM score WHERE c_no = '6-166'; -- GROUP BY: 分组查询 SELECT c_no, AVG(degree) FROM score GROUP BY c_no; 分组条件与模糊查询 查询 score 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。 SELECT * FROM score; -- c_no 课程编号 +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 分析表发现，至少有 2 名学生选修的课程是 3-105 、3-245 、6-166 ，以 3 开头的课程是 3-105 、3-245 。也就是说，我们要查询所有 3-105 和 3-245 的 degree 平均分。 -- 首先把 c_no, AVG(degree) 通过分组查询出来 SELECT c_no, AVG(degree) FROM score GROUP BY c_no +-------+-------------+ | c_no | AVG(degree) | +-------+-------------+ | 3-105 | 85.3333 | | 3-245 | 76.3333 | | 6-166 | 81.6667 | +-------+-------------+ -- 再查询出至少有 2 名学生选修的课程 -- HAVING: 表示持有 HAVING COUNT(c_no) >= 2 -- 并且是以 3 开头的课程 -- LIKE 表示模糊查询，\"%\" 是一个通配符，匹配 \"3\" 后面的任意字符。 AND c_no LIKE '3%'; -- 把前面的SQL语句拼接起来， -- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。 SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_no HAVING COUNT(c_no) >= 2 AND c_no LIKE '3%'; +-------+-------------+----------+ | c_no | AVG(degree) | COUNT(*) | +-------+-------------+----------+ | 3-105 | 85.3333 | 3 | | 3-245 | 76.3333 | 3 | +-------+-------------+----------+ 多表查询 - 1 查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree 。 SELECT no, name FROM student; +-----+-----------+ | no | name | +-----+-----------+ | 101 | 曾华 | | 102 | 匡明 | | 103 | 王丽 | | 104 | 李军 | | 105 | 王芳 | | 106 | 陆军 | | 107 | 王尼玛 | | 108 | 张全蛋 | | 109 | 赵铁柱 | +-----+-----------+ SELECT s_no, c_no, degree FROM score; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 通过分析可以发现，只要把 score 表中的 s_no 字段值替换成 student 表中对应的 name 字段值就可以了，如何做呢？ -- FROM...: 表示从 student, score 表中查询 -- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。 SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no; +-----------+-------+--------+ | name | c_no | degree | +-----------+-------+--------+ | 王丽 | 3-105 | 92 | | 王丽 | 3-245 | 86 | | 王丽 | 6-166 | 85 | | 王芳 | 3-105 | 88 | | 王芳 | 3-245 | 75 | | 王芳 | 6-166 | 79 | | 赵铁柱 | 3-105 | 76 | | 赵铁柱 | 3-245 | 68 | | 赵铁柱 | 6-166 | 81 | +-----------+-------+--------+ 多表查询 - 2 查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列。 只有 score 关联学生的 no ，因此只要查询 score 表，就能找出所有和学生相关的 no 和 degree ： SELECT s_no, c_no, degree FROM score; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 然后查询 course 表： +-------+-----------------+ | no | name | +-------+-----------------+ | 3-105 | 计算机导论 | | 3-245 | 操作系统 | | 6-166 | 数字电路 | | 9-888 | 高等数学 | +-------+-----------------+ 只要把 score 表中的 c_no 替换成 course 表中对应的 name 字段值就可以了。 -- 增加一个查询字段 name，分别从 score、course 这两个表中查询。 -- as 表示取一个该字段的别名。 SELECT s_no, name as c_name, degree FROM score, course WHERE score.c_no = course.no; +------+-----------------+--------+ | s_no | c_name | degree | +------+-----------------+--------+ | 103 | 计算机导论 | 92 | | 105 | 计算机导论 | 88 | | 109 | 计算机导论 | 76 | | 103 | 操作系统 | 86 | | 105 | 操作系统 | 75 | | 109 | 操作系统 | 68 | | 103 | 数字电路 | 85 | | 105 | 数字电路 | 79 | | 109 | 数字电路 | 81 | +------+-----------------+--------+ 三表关联查询 查询所有学生的 name 、课程名 ( course 表中的 name ) 和 degree 。 只有 score 表中关联学生的学号和课堂号，我们只要围绕着 score 这张表查询就好了。 SELECT * FROM score; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 只要把 s_no 和 c_no 替换成 student 和 srouse 表中对应的 name 字段值就好了。 首先把 s_no 替换成 student 表中的 name 字段： SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no; +-----------+-------+--------+ | name | c_no | degree | +-----------+-------+--------+ | 王丽 | 3-105 | 92 | | 王丽 | 3-245 | 86 | | 王丽 | 6-166 | 85 | | 王芳 | 3-105 | 88 | | 王芳 | 3-245 | 75 | | 王芳 | 6-166 | 79 | | 赵铁柱 | 3-105 | 76 | | 赵铁柱 | 3-245 | 68 | | 赵铁柱 | 6-166 | 81 | +-----------+-------+--------+ 再把 c_no 替换成 course 表中的 name 字段： -- 课程表 SELECT no, name FROM course; +-------+-----------------+ | no | name | +-------+-----------------+ | 3-105 | 计算机导论 | | 3-245 | 操作系统 | | 6-166 | 数字电路 | | 9-888 | 高等数学 | +-------+-----------------+ -- 由于字段名存在重复，使用 \"表名.字段名 as 别名\" 代替。 SELECT student.name as s_name, course.name as c_name, degree FROM student, score, course WHERE student.NO = score.s_no AND score.c_no = course.no; 子查询加分组求平均分 查询 95031 班学生每门课程的平均成绩。 在 score 表中根据 student 表的学生编号筛选出学生的课堂号和成绩： -- IN (..): 将筛选出的学生号当做 s_no 的条件查询 SELECT s_no, c_no, degree FROM score WHERE s_no IN (SELECT no FROM student WHERE class = '95031'); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ 这时只要将 c_no 分组一下就能得出 95031 班学生每门课的平均成绩： SELECT c_no, AVG(degree) FROM score WHERE s_no IN (SELECT no FROM student WHERE class = '95031') GROUP BY c_no; +-------+-------------+ | c_no | AVG(degree) | +-------+-------------+ | 3-105 | 82.0000 | | 3-245 | 71.5000 | | 6-166 | 80.0000 | +-------+-------------+ 子查询 - 1 查询在 3-105 课程中，所有成绩高于 109 号同学的记录。 首先筛选出课堂号为 3-105 ，在找出所有成绩高于 109 号同学的的行。 SELECT * FROM score WHERE c_no = '3-105' AND degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105'); 子查询 - 2 查询所有成绩高于 109 号同学的 3-105 课程成绩记录。 -- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。 SELECT * FROM score WHERE degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105'); YEAR 函数与带 IN 关键字查询 查询所有和 101 、108 号学生同年出生的 no 、name 、birthday 列。 -- YEAR(..): 取出日期中的年份 SELECT no, name, birthday FROM student WHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108)); 多层嵌套子查询 查询 '张旭' 教师任课的学生成绩表。 首先找到教师编号： SELECT NO FROM teacher WHERE NAME = '张旭' 通过 sourse 表找到该教师课程号： SELECT NO FROM course WHERE t_no = ( SELECT NO FROM teacher WHERE NAME = '张旭' ); 通过筛选出的课程号查询成绩表： SELECT * FROM score WHERE c_no = ( SELECT no FROM course WHERE t_no = ( SELECT no FROM teacher WHERE NAME = '张旭' ) ); 多表查询 查询某选修课程多于5个同学的教师姓名。 首先在 teacher 表中，根据 no 字段来判断该教师的同一门课程是否有至少5名学员选修： -- 查询 teacher 表 SELECT no, name FROM teacher; +-----+--------+ | no | name | +-----+--------+ | 804 | 李诚 | | 825 | 王萍 | | 831 | 刘冰 | | 856 | 张旭 | +-----+--------+ SELECT name FROM teacher WHERE no IN ( -- 在这里找到对应的条件 ); 查看和教师编号有有关的表的信息： SELECT * FROM course; -- t_no: 教师编号 +-------+-----------------+------+ | no | name | t_no | +-------+-----------------+------+ | 3-105 | 计算机导论 | 825 | | 3-245 | 操作系统 | 804 | | 6-166 | 数字电路 | 856 | | 9-888 | 高等数学 | 831 | +-------+-----------------+------+ 我们已经找到和教师编号有关的字段就在 course 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 score 表来查询： -- 在此之前向 score 插入一些数据，以便丰富查询条件。 INSERT INTO score VALUES ('101', '3-105', '90'); INSERT INTO score VALUES ('102', '3-105', '91'); INSERT INTO score VALUES ('104', '3-105', '89'); -- 查询 score 表 SELECT * FROM score; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 103 | 3-105 | 92 | | 103 | 3-245 | 86 | | 103 | 6-166 | 85 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | | 105 | 3-245 | 75 | | 105 | 6-166 | 79 | | 109 | 3-105 | 76 | | 109 | 3-245 | 68 | | 109 | 6-166 | 81 | +------+-------+--------+ -- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。 SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5; +-------+ | c_no | +-------+ | 3-105 | +-------+ 根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号： SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5 ); +------+ | t_no | +------+ | 825 | +------+ 在 teacher 表中，根据筛选出来的教师编号找到教师姓名： SELECT name FROM teacher WHERE no IN ( -- 最终条件 SELECT t_no FROM course WHERE no IN ( SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5 ) ); 子查询 - 3 查询 “计算机系” 课程的成绩表。 思路是，先找出 course 表中所有 计算机系 课程的编号，然后根据这个编号查询 score 表。 -- 通过 teacher 表查询所有 `计算机系` 的教师编号 SELECT no, name, department FROM teacher WHERE department = '计算机系' +-----+--------+--------------+ | no | name | department | +-----+--------+--------------+ | 804 | 李诚 | 计算机系 | | 825 | 王萍 | 计算机系 | +-----+--------+--------------+ -- 通过 course 表查询该教师的课程编号 SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department = '计算机系' ); +-------+ | no | +-------+ | 3-245 | | 3-105 | +-------+ -- 根据筛选出来的课程号查询成绩表 SELECT * FROM score WHERE c_no IN ( SELECT no FROM course WHERE t_no IN ( SELECT no FROM teacher WHERE department = '计算机系' ) ); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-245 | 86 | | 105 | 3-245 | 75 | | 109 | 3-245 | 68 | | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 103 | 3-105 | 92 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | | 109 | 3-105 | 76 | +------+-------+--------+ UNION 和 NOTIN 的使用 查询 计算机系 与 电子工程系 中的不同职称的教师。 -- NOT: 代表逻辑非 SELECT * FROM teacher WHERE department = '计算机系' AND profession NOT IN ( SELECT profession FROM teacher WHERE department = '电子工程系' ) -- 合并两个集 UNION SELECT * FROM teacher WHERE department = '电子工程系' AND profession NOT IN ( SELECT profession FROM teacher WHERE department = '计算机系' ); ANY 表示至少一个 - DESC ( 降序 ) 查询课程 3-105 且成绩 至少 高于 3-245 的 score 表。 SELECT * FROM score WHERE c_no = '3-105'; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 103 | 3-105 | 92 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | | 109 | 3-105 | 76 | +------+-------+--------+ SELECT * FROM score WHERE c_no = '3-245'; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-245 | 86 | | 105 | 3-245 | 75 | | 109 | 3-245 | 68 | +------+-------+--------+ -- ANY: 符合SQL语句中的任意条件。 -- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件， -- 最后根据降序查询结果。 SELECT * FROM score WHERE c_no = '3-105' AND degree > ANY( SELECT degree FROM score WHERE c_no = '3-245' ) ORDER BY degree DESC; +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | | 102 | 3-105 | 91 | | 101 | 3-105 | 90 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | | 109 | 3-105 | 76 | +------+-------+--------+ 表示所有的 ALL 查询课程 3-105 且成绩高于 3-245 的 score 表。 -- 只需对上一道题稍作修改。 -- ALL: 符合SQL语句中的所有条件。 -- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。 SELECT * FROM score WHERE c_no = '3-105' AND degree > ALL( SELECT degree FROM score WHERE c_no = '3-245' ); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 103 | 3-105 | 92 | | 104 | 3-105 | 89 | | 105 | 3-105 | 88 | +------+-------+--------+ 复制表的数据作为条件查询 查询某课程成绩比该课程平均成绩低的 score 表。 -- 查询平均分 SELECT c_no, AVG(degree) FROM score GROUP BY c_no; +-------+-------------+ | c_no | AVG(degree) | +-------+-------------+ | 3-105 | 87.6667 | | 3-245 | 76.3333 | | 6-166 | 81.6667 | +-------+-------------+ -- 查询 score 表 SELECT degree FROM score; +--------+ | degree | +--------+ | 90 | | 91 | | 92 | | 86 | | 85 | | 89 | | 88 | | 75 | | 79 | | 76 | | 68 | | 81 | +--------+ -- 将表 b 作用于表 a 中查询数据 -- score a (b): 将表声明为 a (b)， -- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。 SELECT * FROM score a WHERE degree 子查询 - 4 查询所有任课 ( 在 course 表里有课程 ) 教师的 name 和 department 。 SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course); +--------+-----------------+ | name | department | +--------+-----------------+ | 李诚 | 计算机系 | | 王萍 | 计算机系 | | 刘冰 | 电子工程系 | | 张旭 | 电子工程系 | +--------+-----------------+ 条件加组筛选 查询 student 表中至少有 2 名男生的 class 。 -- 查看学生表信息 SELECT * FROM student; +-----+-----------+-----+------------+-------+ | no | name | sex | birthday | class | +-----+-----------+-----+------------+-------+ | 101 | 曾华 | 男 | 1977-09-01 | 95033 | | 102 | 匡明 | 男 | 1975-10-02 | 95031 | | 103 | 王丽 | 女 | 1976-01-23 | 95033 | | 104 | 李军 | 男 | 1976-02-20 | 95033 | | 105 | 王芳 | 女 | 1975-02-10 | 95031 | | 106 | 陆军 | 男 | 1974-06-03 | 95031 | | 107 | 王尼玛 | 男 | 1976-02-20 | 95033 | | 108 | 张全蛋 | 男 | 1975-02-10 | 95031 | | 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 | | 110 | 张飞 | 男 | 1974-06-03 | 95038 | +-----+-----------+-----+------------+-------+ -- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。 SELECT class FROM student WHERE sex = '男' GROUP BY class HAVING COUNT(*) > 1; +-------+ | class | +-------+ | 95033 | | 95031 | +-------+ NOTLIKE 模糊查询取反 查询 student 表中不姓 \"王\" 的同学记录。 -- NOT: 取反 -- LIKE: 模糊查询 mysql> SELECT * FROM student WHERE name NOT LIKE '王%'; +-----+-----------+-----+------------+-------+ | no | name | sex | birthday | class | +-----+-----------+-----+------------+-------+ | 101 | 曾华 | 男 | 1977-09-01 | 95033 | | 102 | 匡明 | 男 | 1975-10-02 | 95031 | | 104 | 李军 | 男 | 1976-02-20 | 95033 | | 106 | 陆军 | 男 | 1974-06-03 | 95031 | | 108 | 张全蛋 | 男 | 1975-02-10 | 95031 | | 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 | | 110 | 张飞 | 男 | 1974-06-03 | 95038 | +-----+-----------+-----+------------+-------+ YEAR 与 NOW 函数 查询 student 表中每个学生的姓名和年龄。 -- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。 SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student; +-----------+------+ | name | age | +-----------+------+ | 曾华 | 42 | | 匡明 | 44 | | 王丽 | 43 | | 李军 | 43 | | 王芳 | 44 | | 陆军 | 45 | | 王尼玛 | 43 | | 张全蛋 | 44 | | 赵铁柱 | 45 | | 张飞 | 45 | +-----------+------+ MAX 与 MIN 函数 查询 student 表中最大和最小的 birthday 值。 SELECT MAX(birthday), MIN(birthday) FROM student; +---------------+---------------+ | MAX(birthday) | MIN(birthday) | +---------------+---------------+ | 1977-09-01 | 1974-06-03 | +---------------+---------------+ 多段排序 以 class 和 birthday 从大到小的顺序查询 student 表。 SELECT * FROM student ORDER BY class DESC, birthday; +-----+-----------+-----+------------+-------+ | no | name | sex | birthday | class | +-----+-----------+-----+------------+-------+ | 110 | 张飞 | 男 | 1974-06-03 | 95038 | | 103 | 王丽 | 女 | 1976-01-23 | 95033 | | 104 | 李军 | 男 | 1976-02-20 | 95033 | | 107 | 王尼玛 | 男 | 1976-02-20 | 95033 | | 101 | 曾华 | 男 | 1977-09-01 | 95033 | | 106 | 陆军 | 男 | 1974-06-03 | 95031 | | 109 | 赵铁柱 | 男 | 1974-06-03 | 95031 | | 105 | 王芳 | 女 | 1975-02-10 | 95031 | | 108 | 张全蛋 | 男 | 1975-02-10 | 95031 | | 102 | 匡明 | 男 | 1975-10-02 | 95031 | +-----+-----------+-----+------------+-------+ 子查询 - 5 查询 \"男\" 教师及其所上的课程。 SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex = '男'); +-------+--------------+------+ | no | name | t_no | +-------+--------------+------+ | 3-245 | 操作系统 | 804 | | 6-166 | 数字电路 | 856 | +-------+--------------+------+ MAX 函数与子查询 查询最高分同学的 score 表。 -- 找出最高成绩（该查询只能有一个结果） SELECT MAX(degree) FROM score; -- 根据上面的条件筛选出所有最高成绩表， -- 该查询可能有多个结果，假设 degree 值多次符合条件。 SELECT * FROM score WHERE degree = (SELECT MAX(degree) FROM score); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 103 | 3-105 | 92 | +------+-------+--------+ 子查询 - 6 查询和 \"李军\" 同性别的所有同学 name 。 -- 首先将李军的性别作为条件取出来 SELECT sex FROM student WHERE name = '李军'; +-----+ | sex | +-----+ | 男 | +-----+ -- 根据性别查询 name 和 sex SELECT name, sex FROM student WHERE sex = ( SELECT sex FROM student WHERE name = '李军' ); +-----------+-----+ | name | sex | +-----------+-----+ | 曾华 | 男 | | 匡明 | 男 | | 李军 | 男 | | 陆军 | 男 | | 王尼玛 | 男 | | 张全蛋 | 男 | | 赵铁柱 | 男 | | 张飞 | 男 | +-----------+-----+ 子查询 - 7 查询和 \"李军\" 同性别且同班的同学 name 。 SELECT name, sex, class FROM student WHERE sex = ( SELECT sex FROM student WHERE name = '李军' ) AND class = ( SELECT class FROM student WHERE name = '李军' ); +-----------+-----+-------+ | name | sex | class | +-----------+-----+-------+ | 曾华 | 男 | 95033 | | 李军 | 男 | 95033 | | 王尼玛 | 男 | 95033 | +-----------+-----+-------+ 子查询 - 8 查询所有选修 \"计算机导论\" 课程的 \"男\" 同学成绩表。 需要的 \"计算机导论\" 和性别为 \"男\" 的编号可以在 course 和 student 表中找到。 SELECT * FROM score WHERE c_no = ( SELECT no FROM course WHERE name = '计算机导论' ) AND s_no IN ( SELECT no FROM student WHERE sex = '男' ); +------+-------+--------+ | s_no | c_no | degree | +------+-------+--------+ | 101 | 3-105 | 90 | | 102 | 3-105 | 91 | | 104 | 3-105 | 89 | | 109 | 3-105 | 76 | +------+-------+--------+ 按等级查询 建立一个 grade 表代表学生的成绩等级，并插入数据： CREATE TABLE grade ( low INT(3), upp INT(3), grade char(1) ); INSERT INTO grade VALUES (90, 100, 'A'); INSERT INTO grade VALUES (80, 89, 'B'); INSERT INTO grade VALUES (70, 79, 'C'); INSERT INTO grade VALUES (60, 69, 'D'); INSERT INTO grade VALUES (0, 59, 'E'); SELECT * FROM grade; +------+------+-------+ | low | upp | grade | +------+------+-------+ | 90 | 100 | A | | 80 | 89 | B | | 70 | 79 | C | | 60 | 69 | D | | 0 | 59 | E | +------+------+-------+ 查询所有学生的 s_no 、c_no 和 grade 列。 思路是，使用区间 ( BETWEEN ) 查询，判断学生的成绩 ( degree ) 在 grade 表的 low 和 upp 之间。 SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp; +------+-------+-------+ | s_no | c_no | grade | +------+-------+-------+ | 101 | 3-105 | A | | 102 | 3-105 | A | | 103 | 3-105 | A | | 103 | 3-245 | B | | 103 | 6-166 | B | | 104 | 3-105 | B | | 105 | 3-105 | B | | 105 | 3-245 | C | | 105 | 6-166 | C | | 109 | 3-105 | C | | 109 | 3-245 | D | | 109 | 6-166 | B | +------+-------+-------+ 连接查询 准备用于测试连接查询的数据： CREATE DATABASE testJoin; CREATE TABLE person ( id INT, name VARCHAR(20), cardId INT ); CREATE TABLE card ( id INT, name VARCHAR(20) ); INSERT INTO card VALUES (1, '饭卡'), (2, '建行卡'), (3, '农行卡'), (4, '工商卡'), (5, '邮政卡'); SELECT * FROM card; +------+-----------+ | id | name | +------+-----------+ | 1 | 饭卡 | | 2 | 建行卡 | | 3 | 农行卡 | | 4 | 工商卡 | | 5 | 邮政卡 | +------+-----------+ INSERT INTO person VALUES (1, '张三', 1), (2, '李四', 3), (3, '王五', 6); SELECT * FROM person; +------+--------+--------+ | id | name | cardId | +------+--------+--------+ | 1 | 张三 | 1 | | 2 | 李四 | 3 | | 3 | 王五 | 6 | +------+--------+--------+ 分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。 内连接 要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。 -- INNER JOIN: 表示为内连接，将两张表拼接在一起。 -- on: 表示要执行某个条件。 SELECT * FROM person INNER JOIN card on person.cardId = card.id; +------+--------+--------+------+-----------+ | id | name | cardId | id | name | +------+--------+--------+------+-----------+ | 1 | 张三 | 1 | 1 | 饭卡 | | 2 | 李四 | 3 | 3 | 农行卡 | +------+--------+--------+------+-----------+ -- 将 INNER 关键字省略掉，结果也是一样的。 -- SELECT * FROM person JOIN card on person.cardId = card.id; 注意：card 的整张表被连接到了右边。 左外连接 完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。 -- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。 SELECT * FROM person LEFT JOIN card on person.cardId = card.id; +------+--------+--------+------+-----------+ | id | name | cardId | id | name | +------+--------+--------+------+-----------+ | 1 | 张三 | 1 | 1 | 饭卡 | | 2 | 李四 | 3 | 3 | 农行卡 | | 3 | 王五 | 6 | NULL | NULL | +------+--------+--------+------+-----------+ 右外链接 完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。 SELECT * FROM person RIGHT JOIN card on person.cardId = card.id; +------+--------+--------+------+-----------+ | id | name | cardId | id | name | +------+--------+--------+------+-----------+ | 1 | 张三 | 1 | 1 | 饭卡 | | 2 | 李四 | 3 | 3 | 农行卡 | | NULL | NULL | NULL | 2 | 建行卡 | | NULL | NULL | NULL | 4 | 工商卡 | | NULL | NULL | NULL | 5 | 邮政卡 | +------+--------+--------+------+-----------+ 全外链接 完整显示两张表的全部数据。 -- MySQL 不支持这种语法的全外连接 -- SELECT * FROM person FULL JOIN card on person.cardId = card.id; -- 出现错误： -- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause' -- MySQL全连接语法，使用 UNION 将两张表合并在一起。 SELECT * FROM person LEFT JOIN card on person.cardId = card.id UNION SELECT * FROM person RIGHT JOIN card on person.cardId = card.id; +------+--------+--------+------+-----------+ | id | name | cardId | id | name | +------+--------+--------+------+-----------+ | 1 | 张三 | 1 | 1 | 饭卡 | | 2 | 李四 | 3 | 3 | 农行卡 | | 3 | 王五 | 6 | NULL | NULL | | NULL | NULL | NULL | 2 | 建行卡 | | NULL | NULL | NULL | 4 | 工商卡 | | NULL | NULL | NULL | 5 | 邮政卡 | +------+--------+--------+------+-----------+ "},"5.数据库/4.事务.html":{"url":"5.数据库/4.事务.html","title":"4.事务","keywords":"","body":"4.事务 "},"5.数据库/5.索引.html":{"url":"5.数据库/5.索引.html","title":"5.索引","keywords":"","body":""},"6.Python/":{"url":"6.Python/","title":"第六部分 Python","keywords":"","body":""},"6.Python/1.输入输出.html":{"url":"6.Python/1.输入输出.html","title":"1.输入输出","keywords":"","body":"1. 输入输出 input()读取的格式为字符串，需要先转换为其他类型 1.1 读取单行 # 读取整数 arr = list(map(int, input().strip().split())) 1.2 读取多行 # 原生方法 lines = [] while True: line = input() if line != \"\": lines.append(line) else: break; // sys的readlines方法 import sys lines = sys.stdin.readlines() # 需要ctrl+D终止输入，会带上结尾的回车符，例如输入1 2\\n3 4, lines=[\"1 2\\n\", \"3, 4\"\\n] lines = [line.strip() for line in lines] # 去掉回车符 代码结构示意图 #!/usr/bin/python3 # she-bang符号(#!)：在Unix系统第一行开头使用指明python的解释器 # coding:utf-8 # 指明文件编码类型为utf-8,python3不需要 # -*- coding:encoding name -*- 这种用的多一些 import sys # 用于测试，在该代码块内可以直接执行，import到其他代码内不会被执行 if __name__ == \"__main__\"： print(\"hello\") # TODO(作者/邮件) 用于标记需要去做的工作 "},"6.Python/2.数字类型.html":{"url":"6.Python/2.数字类型.html","title":"2.数字类型","keywords":"","body":"数字型 数字型变量可以直接进行算数计算 | 整形 | 浮点型 | 布尔型 | 复数型 | | ----- | ------- | ------ | --------- | | int | float | bool | complex | 1. 运算符 1.1 算数运算符 运算符 描述 + - * 乘以、字符串重复次数 / 除以 // 整除 % 取余 ** 幂 1.2 关系运算符 运算符 描述 == 判断是否等于，条件成立返回True != 不等于，python2还使用<> > 数字型变量不能和其他类型变量比较 >= 字符串、列表、元组都可以比较，字典不能比较 1.3 逻辑运算符 运算符 描述 and 逻辑与 or 逻辑或 not 逻辑非 1.4 (复合)赋值运算符 = += -= *= /= //= %= **= a=b a+=b a-=b a*=b a/=b a//=b a%=b a**=b→a=a**b 1.5 按位运算符 ` ` & ^ ~ >> 按位或 按位与 按位异或 按位非 按位左移 按位右移 2. 数学函数 import math 函数 返回值 ( 描述 ) abs(x) 绝对值 ceil(x) 向上取整 cmp(x, y) 比较，/==/>返回-1/0/1 exp(x) e^x fabs(x) 绝对值 floor(x) 向下取整 log(x) 对数函数 log10(x) 10为基数的x的对数 max() 最大值 min() 最小值 modf(x) 返回x的整数部分与小数部分 pow(x, y) == x**y == x^y round(x [,n]) 返回浮点数 x 的四舍五入值 sqrt(x) 平方根。 字符串转换 # eval会计算字符串表达式的值，字符串可以包含变量，变量也会被计算 eval(\"expr\") # 将任意进制转换为整数 int(str, base=10) # 浮点数 float(str) 数字转字符串 格式化字符串 进制转换函数# 进制转换会带上相应的前缀 bin(15) # '0b1111' oct(15) # '0o17' hex(15) # '0xf' "},"6.Python/4.字典与集合.html":{"url":"6.Python/4.字典与集合.html","title":"4.字典与集合","keywords":"","body":"1. 字典dictionary 字典是无序键值对容器，可存储任意类型对象。 字典的key只能使用不可变类型的数据(数字、字符串) 字典是无序的，不支持切片，但是支持in/len()/del/max()/min()公共方法 d = {key1 : value1, key2 : value2, key3 : value3 } 1.1 常用操作 成员函数 说明 []/del/in key访问(或增加、更新)/删除/判断及迭代 d.add(key) 添加元素 d.get(key) 访问，不存在会报错 d.update(d2)) 合并到d中(d2不改变)，相同项覆盖/更新 d.setdefault(key, value=None) 访问key，不存在就新建 d.fromkeys(key_seq, value) 从序列中构建新字典 d.pop(key) 删除键值对 d.popitem(key) 随机删除键值对 d.clear(key) 清空字典 d.keys(key) 返回所有key的列表 d.keys(value) 返回所有value的列表 d.items(value) 返回所有(key,value)的列表 d.copy() 返回浅拷贝 1.2 字典的遍历 for key in d: # 等价于for key in d.keys() ... for value in d.values(): # 遍历值 ... for key,value in d.items(): # 遍历字典项 ... 2. 集合 set是一个无序的不重复元素序列，和字典相比只有key没有value 集合的key只能使用不可变类型的数据(数字、字符串) 集合是无序的，不支持切片，但是支持in/len()/del/max()/min()公共方法 # 使用set()或{}创建，空集合不能使用{}，因为{}创建空字典 s1 = set() s2 = {1,2,3} 2.1 常用操作 成员函数 说明 del/in 删除/判断及迭代，不支持访问 s.update(s2)) 合并到s中(d2不改变)，相同项覆盖 s.union(s2)) 返回并集 s.defference(s2)) 返回多集合差异的集合 s.defference_updata(s2)) 删除s中在s2中不存在的key s.insertion(s2)) 交集 s.insertion_updata(s2)) 交集的结果更新s s.isdisjoint(s2)) 判断是否有交集 s.issubset(s2) 判断是否为子集 s.issuperset(s2) 判断s2是否是s子集 s.pop()/remove() 随机删除key/删除指定key s.symmetric_difference(s2) 对称差集 s.symmetric_difference——update(s2) 对称差集更新 "},"6.Python/5.字符串.html":{"url":"6.Python/5.字符串.html","title":"5.字符串","keywords":"","body":"字符串 python使用\"\"和''定义字符串 字符串内部需要输出\"时，就使用''定义字符串，反之同理 字符串支持切片、len()、del、in、[]、*公共方法 1. 字符串判断 成员函数 说明 str.isspace() 判断是否只包含空白字符\\r \\n \\t str.isalnum() 判断是否只包含字母和数字，且字符串非空 str.isalpha() 判断是否都是字母，且字符串非空 str.isdecimal() 判断是否只包含全角数字 str.isdigit() 判断是否只包含全角数字以及unicode字符 str.isnumeric() 判断是否只包含全角数字、汉字数字、unicode字符 str.istitle() 判断字符串单词首字母是否大写 str.islower() 判断所有字符都是小写 str.isupper() 判断所有字符都是大写 str.endwith(s) 判断str是否以s结尾 2. 字符串修改 2. 字符串修改 成员函数 说明 []/+/*n/del/in 下标访问/连接字符串/重复字符串n次/删除/判断及迭代 str.replace(old, new) 替换指定字符串，替换长度默认为旧子串长度 str.capitalize() 第一个字符大写 str.title() 每个单词首字母转换为大写 str.lower()/casefold() 将字符串所有字符转换为小写 str.upper() 将字符串所有字符转换为大写 str.swapcase() 反转字符串的大小写 str.ljust(w) 指定宽度左对齐，填充指定字符，默认\" \" str.rjust(w) 右对齐，同上 str.center() 居中对齐，同上 str.strip()/rstrip() 去掉字符串首尾/末尾的空白字符 str.partition(s) 以字符串s将str分割为3部分 str.rpartition(s) 同上，从末尾往前寻找字符串 str.split(str=\" \") 以指定字符分割字符串，返回列表 str.splitlines() 以换行符分割字符串 str.join(seq) split逆向版，以str为分隔符连接seq 3. 字符串匹配 成员函数 说明 str.find()/rfind() 匹配字符串，返回首个匹配索引，没找到返回-1 str.index()/rindex() 查询字符串匹配索引，不存在会引起异常 4. 信息查询 函数 说明 str.encode() 查询字符串编码方式 ord(char) 返回字符的ASCII码的0-255数值 chr(n) 返回0-255的对应ASCII码 5. 格式化字符串 5.1 %格式化 \"%d, %d\" % (a, b) 5.1.1 进制 转换说明符 说明 %d/%i %o %x/%X 带符号的十进制、八进制、十六进制整数 %f/%F 十进制浮点数 %e/%E 科学计数法表示的浮点数(对应e大小写) %g/%G 浮点表示和科学技术智能显示 %c/%s 字符以及字符串 %r 使用正则表达式repr()转换字符串 5.1.2 输出控制 格式控制 格式 输出宽度 %05.03f 输出宽度控制，默认空格填充 对齐方式 %-5d左对齐/默认右对齐/%+5d总是带符号输出(+和-) 5.2 format()格式化 format使用{}字符串标记格式的位置，:标志格式控制 \"{:b},{:b}\".format(a, b) 5.2.1 位置控制 方式 说明 位置 '{0},{1}'.format('a','b') 关键字 '{k1},{k2}'.format(k1='a',k2='b') 对象属性 '{obj.a1},{obj.a2}'.format(obj) 下标 '{0[0]},{0[1]}'.format(arr) 5.2.2 输出控制 格式控制 格式 进制 b/o/d/x/f 二进制/八进制/十进制/十六进制/浮点数 宽度 {:7.5f}整数宽度7浮点数5 填充对齐 {:左对齐0填充，{:^07}中间对齐，{:>a7}右对齐，字符填充 6. 与数字类型的转换 6.1 字符串转数字 # eval会计算字符串表达式的值，字符串可以包含变量，变量也会被计算 eval(\"expr\") # 将任意进制转换为整数 int(str, base=10) # 浮点数 float(str) 6.2 数字转字符串 格式化字符串 进制转换函数# 进制转换会带上相应的前缀 bin(15) # '0b1111' oct(15) # '0o17' hex(15) # '0xf' "},"6.Python/6.切片与常用函数.html":{"url":"6.Python/6.切片与常用函数.html","title":"6.切片与常用函数","keywords":"","body":"切片 切片返回序列根据切片规则的临时对象，原对象不会改变 # 切片 a = [[1,2],[3,4]] a = list(map((lambda x:x[::-1], a))) 切片(字符串/列表/元组) [开始索引:结束索引:步长] • 切片不包含结束索引的值（如图），步长处也会被切掉 • 顺序0,1,2,… 逆序-1,-2,-3,… 最后一个元素-1 • 切到末尾就不指定结束索引 • 逆序切片步长可以指定为负,逆序字符串：str[::-1] 公共方法： list解析 [i.fun() for i in a_list if 条件] # if可选 print([i ** 3 for i in range(1,10) if i%2 == 0]) # 打印1~9内偶数立方的列表 序列sequence取值 [] 删除 del(item) # 两种方式是一样的 成员运算 item in item not in # item为字典的key, 列表元组为元素 遍历(支持字典) for item in # 不要用遍历修改对象！！！ 计算长度、最大值/最小值 len(item) (支持字典) max(item) # 如果是字典，只针对key比较 min(item) 链接/重复(字符串/列表/元组) [1, 2] + [3, 4] # = [1, 2, 3, 4] [1] * 4 # = [1, 1, 1, 1] enumerate(nums) "},"6.Python/7.类型的转换.html":{"url":"6.Python/7.类型的转换.html","title":"7.类型的转换","keywords":"","body":" 互相转换 list(), tuple()直接转换 列表对应元素组成元组 如 a=[1, 2] b=['a', 'b'] zip(a, b) [(1, 'a'), (2, 'b')] 反转操作 元组反转(1, 2)反转成1, 2 ** 字典反转 {'p1':1, 'p2':2}反转成p1=1,p2=2 ▫ 列表和元组之间的转换： a_list = list(a_tuple) # 元组转换为列表 a_tuple = tuple(a_list) # 列表转换为元组 计算字符串表达式的值(可以包含变量) eval(str ) "},"6.Python/8.迭代器.html":{"url":"6.Python/8.迭代器.html","title":"8.迭代器","keywords":"","body":"iterl=iter(l) next(iterl) "},"6.Python/9.闭包与装饰器.html":{"url":"6.Python/9.闭包与装饰器.html","title":"9.闭包与装饰器","keywords":"","body":""},"6.Python/附：Python速查表.html":{"url":"6.Python/附：Python速查表.html","title":"Python速查表","keywords":"","body":"Python Cheatsheet "},"6.Python/高级数据结构.html":{"url":"6.Python/高级数据结构.html","title":"高级数据结构","keywords":"","body":" 数据结构/算法 语言内置 内置库 线性结构 list(列表)/tuple(元祖) array(数组,不常用)/collection.namedtuple 链式结构 collections.deque(双端队列) 字典结构 dict(字典) collections.Counter(计数器)/OrderedDict(有序字典) 集合结构 set(集合)/frozenset(不可变集合) 排序算法 sort() 二分算法 bisect模块 堆算法 heapq模块 "},"7.图形学/":{"url":"7.图形学/","title":"第七部分 图形学","keywords":"","body":""},"7.图形学/shader.html":{"url":"7.图形学/shader.html","title":"shader","keywords":"","body":" 1. 顶点着色器(Vertex Shader) 它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。 2. 图元装配(Primitive Assembly) 将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。 3. 几何着色器(Geometry Shader)。 几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。 4. 光栅化阶段(Rasterization Stage) 这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。 5. 片段着色器 OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。 5. Alpha测试和混合(Blending) 在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，。这个阶段检测片段的对应的深度（和模板）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同 "},"8.非技术面试/":{"url":"8.非技术面试/","title":"第八部分 非技术面试","keywords":"","body":""},"8.非技术面试/1.智力题.html":{"url":"8.非技术面试/1.智力题.html","title":"1.智力题","keywords":"","body":"智力题 分金条问题 问题：有个商人雇用了一位手艺高超的工匠了为他做一个精致产品，工作一星期七天的代价是一条金条。商人手头上有一条金条，刚好有可以付工匠一星期的工钱。但工匠要求工钱要按每天来付。虽然他并不急着用钱，每天有钱进账，老人心里总是踏实一些。但商人家中有个规矩，金条每星期只能切二刀。后来商人想出以了个切割金条的办法，满足了工匠的要求。你知道商人是怎么切割金条才能满足工匠的吗？ 答案：两刀平均切成1、2、4大小的，可以组合成任意一天。 解释：这三个二进制数的组合能表示0-7中的任何一个。 赛马问题 25匹马5条跑道找最快的3匹马，需要跑几次？答案：7 64匹马8条跑道找最快的4匹马，需要跑几次？答案：11 25匹马5条跑道找最快的5匹马，需要跑几次？答案：最少8次最多9次 毒药老鼠 问题描述：有100只一模一样的瓶子，编号1-100。其中99瓶是水，一瓶是看起来像水的毒药。只要老鼠喝下一小口毒药，一天后则死亡。现在，你有7只老鼠和一天的时间，如何检验出哪个号码瓶子里是毒药？ 答案：首先，将瓶子的10进制编号数改成7位的2进制码。然后，让第1只老鼠喝所有2进制码第1位是1的瓶子中的水；让第2只老鼠喝所有2进制码第2位是1的瓶子中的水；以此类推下去。这样，每个老鼠第二天的死活情况就决定了毒水瓶子二进制码这一位的数字：老鼠死，对应1，反之为0。 这儿把它叫做‘问题1’，解决此题的方法可谓二进制应用的经典： 首先，将瓶子的10进制编号数改成7位的2进制码。然后，让第1只老鼠喝所有2进制码第1位是1的瓶子中的水；让第2只老鼠喝所有2进制码第2位是1的瓶子中的水；以此类推下去。这样，每个老鼠第二天的死活情况就决定了毒水瓶子二进制码这一位的数字：老鼠死，对应1，反之为0。换言之，将7只老鼠死活情况排成一排。比如说结果是“死活死死活活死”的话，毒水瓶子的二进制标签就是：1011001，转换成10进制，得到89。 桶称水 如果你有无穷多的水，一个3夸脱的和一个5夸脱的提桶，你如何准确称出 4夸脱的水？ 参考答案: 思路：4夸脱最后必定是在大桶桶中，3+1=4只要能称出1就行，3+3-5=1，只要小桶往大桶倒两次水，满了后小桶就剩1，再加一小桶水就是4夸脱了。 天平称砝码 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？ 将砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？ 至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个； 第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个； 答：至少称2次． 猜颜色(眼睛颜色，头巾颜色) 海盗分金币 问题：5个海盗抢到了100枚金币，每一颗都一样的大小和价值。 他们决定这么分： 抽签决定自己的号码（1，2，3，4，5） 首先，由1号提出分配方案，然后大家5人进行表决，当 半数以上的人同意时（ 不包括半数，这是重点），按照他的提案进行分配，否则将被扔入大海喂鲨鱼。 如果1号死后，再由2号提出分配方案，然后大家4人进行表决，当且仅当半超过半数的人同意时，按照他的提案进行分配，否则将被扔入大海喂鲨鱼。 依次类推...... 假设每一位海盗都足够聪明，并且利益至上，能多分一枚金币绝不少分，那么1号海盗该怎么分金币才能使自己分到最多的金币呢？ 答案： 从后向前推，如果1至3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。 3号知道这一点，就会提出“100，0，0”的分配方案，对4号、5号一毛不拔而将全部金币归为已有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票，他的方案即可通过。 不过，2号推知3号的方案，就会提出“98，0，1，1”的方案，即放弃3号，而给予4号和5号各一枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。 同样，2号的方案也会被1号所洞悉，1号并将提出（97，0，1，2，0）或（97，0，1，0，2）的方案，即放弃2号，而给3号一枚金币，同时给4号（或5号）2枚金币。由于1号的这一方案对于3号和4号（或5号）来说，相比2号分配时更优，他们将投1号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入囊中。这无疑是1号能够获取最大收益的方案了！答案是：1号强盗分给3号1枚金币，分给4号或5号强盗2枚，自己独得97枚。分配方案可写成（97，0，1，2，0）或（97，0，1，0，2）。 轮流拿石子 问题：一共有N颗石子（或者其他乱七八糟的东西），每次最多取M颗最少取1颗，A，B轮流取，拿到最后一颗的获胜，谁最后会获胜？（假设他们每次都取最优解）。 答案：简单的巴什博奕：https://www.cnblogs.com/StrayWolf/p/5396427.html 猴子搬香蕉 一个小猴子边上有100根香蕉，它要走过50米才能到家，每次它最多搬50根香蕉，（多了就被压死了），它每走1米就要吃掉一根，请问它最多能把多少根香蕉搬到家里。（提示：他可以把香蕉放下往返的走，但是必须保证它每走一米都能有香蕉吃。也可以走到n米时，放下一些香蕉，拿着n根香蕉走回去重新搬50根。） 答案：当需要搬大于100根香蕉时，每走一步消耗3根，走到16米剩余52根，17米剩49根，走完剩下的33米要33根，剩下16根 送花瓶 问题：古时候有一位商人要让伙计将一个精致的花瓶送到买主的手里。只要把花瓶锁在箱子里就可以安全地送到目的地。商人还准备了一把精致的铁锁将花瓶锁在箱子里。这把铁锁的钥匙是独一无二的，没有这把钥匙，按照当时的技术箱子是绝对打不开的。但问题来了，土匪只要见到钥匙就会没收。钥匙都是没法安全地送到买主的手里的。买主也不能把自己的锁送给卖主用。在几经周折后，买主终于得到了他心爱的花瓶。请问这花瓶是如何送到买主的手里的？ 这是一个故事，但故事里的技术是实在的，也确实运用到了如今的高科技中。在互联网中怎样将信息安全地送到目的地而不被黑客在中途截获，也是成功地运用了类似的方法。你知道故事的答案吗？ 答案：(只要让箱子一直处在锁着的安全状态)，商人先上锁把箱子运给买主，买主再上锁送回来，商人再把自己的锁打开再运给买主 烧绳子 问题描述：有两根导火索，它们的长度都是正好1分钟烧完。但是它们燃烧的速度是不均匀的。也就是说，你不能用一小段的长度与总长度的比值来确定燃烧完这一小段的时间。用这两根导火索和一只打火机，没有其它计时器的帮助，请你给我报告两次时间信号：开始的时间t1、结束的时间t2。时间t1和t2准确地相差45秒。 答案：将其中一根的两头，以及另一根的一头，同时点燃，这个时刻定为t1。当第一根烧完时，立即后点燃第二根的另一端，第二根烧完的时刻便是t2。 解释:见下图：第一根两头点燃，直到烧完，时间是30秒。这时第二根也烧了30秒，因第二根只点了一端，因而只烧完了一半时间，剩下的部分还能烧30秒，这时马上点燃它的另一端，变成从两头同时烧，因而烧完的时间是15 秒，加上开始的30秒，总共历时45秒。 iPhone四位数密码 问题描述：1．在一个四位数的代码中，只使用三个数字对安全是否确实有帮助？2．如果只重复使用两个独立的数字会不会更好呢？ 答案：用三个数字最安全，两个数字最不安全，四个数字居中。 解释：1)、4个位置不同时,排列数=4321=24；2)、3个位置不同时,排列数=C(4,2)23=36；选择三个数中哪个数重复3种情况，再进行排列12中，总共312=36种 3)、2个位置不同时,排列数=3个重复情况（4+4）+两两重复情况（6）=14。 扑克牌反转问题 问题：一付54张扑克牌，其中有十张是翻过来的。现在把你的眼睛蒙上（绝对没有偷看的可能），让你把扑克牌分成两叠（两叠的多少可以不一样）。要求在两叠中翻过来的扑克牌是相等的。请问该怎么做？除了扑克牌的数目，其它因数（扑克牌大小，重量，颜色，表面触摸的感觉，等等）不参与题目之中。扑克牌可以任意次重新排序、翻转。10张翻过来的扑克牌是随机分布在扑克牌中。 答案：第一步，你在这54张牌中任意取出10张，现在，扑克牌分成了两叠。44张和10张；第二步，44张那叠不动，将10张这叠每张都翻过来，便得到了符合条件的两叠牌。 解释：第一步之后，设44张那叠中正面牌x张，10张那叠中正面牌则为10-x张。第二步之后，44张那叠中正面牌保持x张，10张那叠反过来了：反面牌为10-x张，正面牌x张。 书有多少页 问题描述：一本书有N页厚。书的页数是从1 到N。所知道的是，所有的页数总共用了1095个数码字。请问这本书有多少页？ 答案：401页 解释：有9页个位数的书页，每页用一个数码字。90页两位数的书页，每页用2个数码字。首先假设没有四位数的书页，而三位数书页的数目为x。因为总共用了1095个数字，所以列出x的方程：9+290+3x=1095。解出x=302，总的书页数=302+9+90=401。 左轮枪 问题描述：某公司招聘员工面试时提的问题：“让我们来玩个游戏”，招聘人开始了。“你现在被牢牢地绑在椅子上不能动。这是一把枪，一把六星左轮抢，六个弹槽都空着。现在，我把两颗子弹装入弹槽。看到我把子弹装入两个相邻的弹槽了吗？我把轮子合上，然后用手拨动让轮子转动几圈。我把枪对着你的头，扣动了扳机，…，叭。你真幸运！第一枪撞针没打中子弹。然后，我要再扣一次扳机。”招聘人接着说：“我可以直接扣动扳机，或旋转轮子一下再扣扳机，你可以选择其中一种，请问，你选哪一种方法呢？”庆幸的是这只是一把想象中的枪。招聘人只是用手势做出旋转轮子和扣动扳机的样子。但不幸的是你的前程却掌握在挥舞着‘手枪’的家伙的手里。 当然，这两种方法都不是你要的，但其中一种方法的生存的机会会大一些。你到底应该选择哪一种方法呢？ 答案：选择‘不转’，因为被打死的概率更小。 解释：题中说：子弹是装入两个相邻的弹槽，左轮枪是一格一格往下转的，如右图所示。1) 第一枪没有打出子弹，因此，第一枪的位置只可能是A、B、C、D。那么，接连第二枪的位置就会是第一枪的下面一个，也就是：B、C、D、E，这4个位置中，只有E有子弹。所以，如果直接扣动扳机，几率=1/4。2) 如果重新把轮子转一下，左轮枪将处于随机的位置，6个格子有2颗子弹，这时挨枪的机率为2/6=1/3。3. )1/4 测量砖头的对角线 问题描述：单凭三个砖块和一把尺子，不使用任何公式，怎样才能测量一个砖头的立体对角线？就是穿过砖头内部的那条对角线。 答案：将三块砖头如图迭起来，就可测量。 距离问题 有一辆火车以每小时15公里的速度离开洛杉矶直奔纽约，另一辆火车以小时20公里的速度从纽约开往洛杉矶。如果有一只鸟，以外30公里每小时的速度和 两辆火车现时启动，从洛杉矶出发，碰到另辆车后返回，依次在两辆火车来回的飞 行，直道两面辆火车相遇，请问，这只小鸟飞行了多长距离？ 参考答案:答案很容易计算的： 假设洛杉矶到纽约的距离为s 那小鸟飞行的距离就是(s/(15+20))*30。 计时沙漏 问题描述：沙漏（hourglass）是最早使用的计时仪器之一。如下图（a）中所示的沙漏，是上下对称的，可以倒来倒去地计时。比如说，如果有一个2分钟的沙漏，你便可以漏一次得到2分钟，漏完后立即倒过来，再漏完，总共得到4分钟的时间。 现在，给你一个4分钟的沙漏，和一个7分钟的沙漏，它们都是可以倒来倒去的对称沙漏。如何将它们配合使用，才能得到准确的、从开始到结束总共9分钟的时间？ 用图形，我们可以更方便地说明这个问题。一个沙漏某时刻的状态可以用上下重叠的两个带数字的方格表示，例如，上图（b）所表示的是7分钟沙漏的初始状态和漏了2分钟后的状态。上图中的（c）则是要请你回答的问题。 解释：设7分钟的沙漏为A，4分钟的为B，A，B同时漏，4分钟后， 状态为 （A ： 3，4）；（ B：0，4）；B倒过来， 3分钟A漏完全后， 状态为（A ： 0，7）； （B：1，3）；A倒过来， 1分钟B漏完全后， 状态为（A ： 1，6）； （B：0，4），A倒过来, 1分钟后，状态为（A ： 0，7）； 猜生日 小明和小强是赵老师的学生，张老师的生日是M月N日，张老师把M值告诉小明，N值告诉小强，给他们六个选项 3月1日 3月3日 7月3日 7月5日9月1日 11月7日 小明说:我猜不出来 小强说:本来我也猜不出来，但是现在我知道了 问:张老师生日多少 答案：3月1日 排除法： 1.小明说猜不出来，说明小明拿到的不是单独出现的9或者11，说明老师生日只能是3月或者7月 2.小强原本不知道，说明小强拿到的不是单独出现的5或者7，说明老是生日是1日或3日 3.小强现在知道了，说明小强拿到的是1，因为如果拿到的是3，那么小强就不知道是3月3日还是7月3日了 综上，老师生日是3月1日 "},"8.非技术面试/2.计算几何.html":{"url":"8.非技术面试/2.计算几何.html","title":"2.计算几何","keywords":"","body":" 面积 计算原点到每个相邻顶点的向量，叉乘向量的积(注意有方向)相加，最后除以2 是否在多边形内 内点内角和为2PI，外点内角和为0 光线投射算法 考虑以该点为端点引出一条射线，如果这条射线与多边形有奇数个交点，则该点在多边形内部，否则该点在多边形外部，我们简记为奇内偶外。这个算法同样被称为奇偶规则 ，就具体实现而言，可以把射线变成长的线段，然后对每一条边做跨立实验即可。 直线相交 AB与CD相交，AB在CD的两侧 AB与CD相交，CD在AB的两侧 用叉乘判断 AC×AB与AD×AB异号 且CA×CD与CB×CD异号 交点 切割多边形 逆时针依次判断线段是否相交，如果相交就把相交点作为顶点加入图形，否则加入原来的顶点 是否为凸 计算顶点0，1，2是顺时针还是逆时针(可以用叉乘判断)，后面出现三个点和这个方向不相同就是非凸 最小圆覆盖 判断一个点是否在多边形内部(射线法) 在圆上任意选取三个点，三个点构成锐角三角形的概率？ 设计随机函数，在圆内任意点概率相同 随机在 有N个三角形，怎样找出所有相交的三角形 判断三角形包含：判断三个顶点在不在另一个三角形内 直线相交 剩下的就是相离 "}}