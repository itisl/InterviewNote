- C++基础知识
  - 1.1 C++标准
  - 文字常量和变量
  - const的用法
  - const_cast的用法
  - mutable的用法
  - 求余运算符%
  - sizeof的用法
  - 引用与指针常量
  - 左值的概念
  - goto语句
  - volatile的用法
  - typedef的用法
  - 关于字符串
  - 链式操作
  - 名字空间
  - 定义复杂的宏(Macro)
  - explicit的用法
- 数据类型与程序结构
  - C++的数据类型
  - 布尔类型
  - void的用法
  - 枚举类型
  - 结构与联合
  - 数据类型转换
  - 声明与定义的区别
  - 关于初始化
  - 作用域和生命期
  - 关于头文件
  - 什么是分离编译模式
- 函数
  - main()函数
  - 函数参数如何传递
  - 函数调用时堆栈的变化
  - 函数参数的默认值
  - 怎么禁止传值调用
  - 可变参数函数
  - 函数指针
  - 函数重载
  - 操作符重载
  - 类成员函数与外部函数的区别
  - 内联函数
  - 函数的返回值在哪
  - extern "C"的作用
- 类与对象
  - 类定义后面为什么要加分号
  - 初始化列表
  - 对象的生成方式
  - 临时对象
  - 关于点操作符
  - 嵌套类与局部类
  - 对象之间的比较
  - 静态成员
  - 类的设计及实现规范
  - 抽象类与纯虚函数
  - 类对象的内存布局
  - 为什么基类的析构函数要定义为虚函数
  - 对象数据成员的初始值
  - 对象产生和销毁的顺序
  - 拷贝构造函数
- 数组与指针
  - 数组名的意义
  - 什么是指针
  - 数组与指针的关系
  - 数组的初始化
  - 多维数组与多重指针
  - 成员数据指针
  - this指针
  - 什么是悬挂指针
  - 什么是解引用
  - 指针与句柄
- 模板与标准模板库
  - 模板参数
  - 模板实例化
  - 函数声明对函数模板实例化的屏蔽
  - 将模板声明为友元
  - 模板与分离编译模式
  - 模板特化
  - 输入/输出迭代子的用法
  - bitset的简单用法
  - typename的简单用法
  - 什么是仿函数
  - 什么是引用计数
  - 什么是ADL
- 内存管理
  - C++程序的内存布局
  - new操作的实现过程
  - 禁止在堆或栈上创建对象
  - new和delete的使用规范
  - delete和delete[]区别
  - 什么是定位放置new
  - 在函数中创建动态对象
  - 什么是内存池技术
- 继承与多态
  - 私有成员会被继承吗
  - 怎么理解构造函数不能被继承
  - 什么是虚拟继承
  - 怎么编写一个不能被继承的类
  - 关于隐藏
  - 什么是RTTI
  - 虚调用的几种情形
  - 不要在构造函数或析构函数中调用虚函数
  - 虚函数可以是私有的吗
  - 动态联编是怎样实现的
  - !操作符重载
  - *操作符重载
  - 赋值操作符重载
  - 输入输出操作符重载
- 输入输出流
  - 什么是IO流
  - IO流的优点
  - endl是什么
  - 实现不带缓冲的输入
  - 提高输入输出操作的稳健性
  - 为什么要设定locale
  - `char*`和`wchar_T*`之间的转换
  - 获取文件信息
  - 管理网文件和目录操作
  - 二进制文件的IO操作
- 异常处理
  - 为什么要引入异常处理机制
  - 抛出异常和传递参数的不同
  - 抛出和接收异常的顺序
  - 在构造函数中抛出异常
  - 用传引用的方式捕捉异常
  - 在堆栈展开时如何防止内存泄漏
  
