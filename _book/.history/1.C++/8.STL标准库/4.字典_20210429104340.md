# 1. 字典`map`
**作用**：存储`key`-`value`对，并对`key`排序，提供O(logn)复杂度的数据查找和插入，底层实现为红黑树

##  1.1 构造函数
```cpp
#include<map>

std::map<std::string,int> map1;//默认构造
map1["a"] = 1; //插入元素
std::map<std::string,int> map2{{"a",1},{"b",2}}; // 初始化列表构造,初始化列表对应参数会自动绑定到泛型对应的构造函数
// 支持迭代器范围构造
```

## 2.1 常用操作
### 2.1.1 操作符
| 操作     | 操作符                                              |
| -------- | --------------------------------------------------- |
| 下标访问 | `operator []`                                       |
| 比较     | `operator ==`   (`!=` `>` `<`相关操作符C++20中移除) |

### 2.1.2 元素访问
**`map`支持双向迭代器**

| 成员函数      | 说明                                                       |
| ------------- | ---------------------------------------------------------- |
| `at(key)`     | 访问`key`对应的`value`，不存在会抛出异常                   |
| `operator []` | 返回键`key`值的引用，如果不存在`key`则插入,`value`默认为空 |


### 2.1.3 容量

| 成员函数  | 说明             |
| --------- | ---------------- |
| `empty()` | 判断是否为空字典 |
| `size()`  | 字典中元素个数   |

### 2.1.4 查找
| 成员函数        | 说明                                             |
| --------------- | ------------------------------------------------ |
| `count(key)`    | 统计字典中`key`的数量,`0`或`1`                   |
| `find(key)`     | 查找`key`，返回迭代器，没找到返回尾迭代器`end()` |
| `contains(key)` | 字典是否包含`key`                                |
| `upper_bound()` | 返回指向首个大于给定键的元素的迭代器             |
| `lower_bound()` | 返回指向首个不小于给定键的元素的迭代器           |
| `equal_range()` | 返回匹配特定键的元素范围                         |


### 2.1.5 修改元素

| 成员函数         | 说明                                                                                        |
| ---------------- | ------------------------------------------------------------------------------------------- |
| `insert()`       | 插入`key`-`value`对                                                                         |
| `erase()`        | 移除指定元素，可以根据`key`、位置、范围移除                                                 |
| `emplace_back()` | 使用参数调用泛型对应的构造函数原位构造，插入到字典中   <br>该方法不会产生临时对象，效率较高 |
| `try_emplace()`  | 若键不存在原位构造键值对，插入到字典中；若存在不做任何事<br>(也不会更新`value`) (C++17)     |
| `clear()`        | 清空字典                                                                                    |
| `extract(key)`   | 从字典中释放出一个键值对,返回其引用<br>`extract`是更换`map`的键而不重分配的唯一方式(C++17)  |
| `merge(map2)`    | 合并`map2`到当前字典，不存在的键值对会被移动<br>已存在则不合并(C++17)                       |

### 2.1.6 插入元素的方式
插入元素的方式：
- 初始化列表插入(推荐)
- 下标方式插入
- 插入`pair`元素

> `map`和`unordered_map`利用`std::pair<T1,T2>`存储键值对，插入时应该插入`pair`对象（或使用初始化列表将参数传入到`pair`的构造函数）
> 遍历`map`时，对于每一个`pair`可以访问`pair.first`和`pair.second`代表`key`和`value`

```cpp
map1.emplace_back("a", 1); //emplace_back方法插入
map1.insert({"a", 1}); // 初始化列表插入
map1["a"] = 1; // 下标方式插入，如果本来就存在则会更新value
map1.insert(pair<string, int>("a", 1); //pair方式插入
map1.insert(make_pair<string, int>("a", 1); //make_pair方式插入
```



# 2. 无序字典`unordered_map`
**和`map`的区别**
- 没有顺序，不按`key`排序，底层实现为哈希表
- 只支持单向迭代器
- 没有范围查找`lower_bound()`和`upper_bound()`
- 增加了哈希表相关的接口

## 2.1 哈希桶接口
| 成员函数        | 说明                                   |
| --------------- | -------------------------------------- |
| `bucket(key)`   | 返回带有特定`key`的桶的编号            |
| `bucket_size(bucket)` | 返回特定桶中的键值对数量               |
| `bucket_count()` | 返回桶的数量                      |
| `max_bucket_count()` | 返回桶的数量                      |
| `begin(bucket)/end()` | 返回指定的桶的迭代器   |

## 2.2 哈希策略
| 成员函数        | 说明                                   |
| --------------- | -------------------------------------- |
| `load_factor()`   | 返回每个桶的平均键值对数量            |
| `max_load_factor()`   | 返回每个桶的平均键值对数量            |
| `rehash(count)`   | 设置桶数为`count`，并重哈希            |

