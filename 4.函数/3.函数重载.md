## 函数重载
### 重载和覆盖的区别
> 1. 重载是在同一个类或作用域中，覆盖是在子类和父类中(不同作用域)
> 2. 覆盖要求参数列表相同，重载要求参数列表不同，当虚函数返回类型或参数不一样时将会造成函数的隐藏而不是覆盖
覆盖的方法不能为`private`
> 3. 覆盖返回类型必须一致(抛出异常也要一致)，重载可以不一致
### 运算符重载
**概念**：运算符重载是通过函数实现的，本质上是函数重载。`oprator`是关键字，用来定义重载运算符的函数。可以将`operator运算符`看作函数名。
> - 运算符函数或者是类的成员，或者至少含有一个类类型的参数（无法改变内置类型运算符的含义）
> - 重载运算符的参数数量与该运算符作用的运算对象数量一样。当一个重载的运算符是成员函数时，左侧运算对象绑定到隐式的`this`指针上（函数体内用`this`作为参数）。因此成员运算符的显式参数数量比运算符运算对象少一个。
> - 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变
> - 重载不能改变运算符的优先级和结合性
> - 运算符重载函数不能有默认的参数（否则就改变了运算符操作数的个数）
> - 运算符重载函数既可以作为类的成员函数，也可以作为类的友元函数或普通函数（普通函数不能访问类的私有，极少用到）

运算符重载的格式：
```cpp
type operator 运算符名称(parm){
    ...
}
```

#### 运算符重载的规则
> 1. 箭头运算符`->`、下标运算符`[]`、函数调用运算符`()`、赋值运算符`=`只能以成员函数的形式重载
> 2. 一般将单目运算符以及`+=`、`-=`、`*=`、`/=`（复合赋值运算符）重载成成员函数，将双目运算符重载为友元函数（非成员函数）
> 3. 双目运算符形参在参数表中的顺序任意，但在使用时左侧操作数需要与第一个参数对应，右侧操作数与第二个参数对应。数学上的交换律在此不适用，如果希望适用，应在此重载操作符并调整参数表顺序。

#### 不能被重载的运算符
下列5个运算符不能被重载：
```cpp
::      .*       .     ?:   sizeof
```
通常情况下，尽量避免逗号`,`、取地址`&`、逻辑与`&&`或`and`、逻辑或`||`或`or`运算符的重载

#### 可以被重载的运算符
```cpp
	+  -   *   /   %   ^   &   |   ~   !   
    =   <   >   +=   -=   *=   /=   % =   
    ^=   &=   |=   <<   >>   <<=   >>=   
    ==   !=   <=   >=   &&  ||   ++   --   
    ,   ->*   ->   ()   []   new   new[]   
    delete   delete[]
```
##### 示例1：重载`+`运算符
```cpp
//以全局函数的形式重载`+`
class Complex{
public:
	friend Complex operator+(const Complex &c1, const Complex &c2);
//重载+运算符
}
Complex operator+(const Complex &c1, const Complex &c2){
Complex c;
c.real_ = c1.real_ + c2.real_;
c.imag_ = c1.imag_ + c2.imag_;
return c;
}
```
##### 示例2：重载复合赋值`+=`运算符
```cpp
 //以成员函数的形式重载+=，双目运算符，返回引用类型可作为左值
 Complex & Complex::operator+=(const Complex &c){
 this->real_ += c.real_;
 this->imag_ += c.imag_;
 return *this;
 }
```
##### 示例3：重载输入输出运算符`>>`和`<<`
输入输出运算符必须是非成员函数，不能是成员函数，否则左侧运算对象将是当前类，无法完成输入。

```cpp
// 以全局函数的形式重载>>，用来输入复数
istream &operator>>(istream &is, complex &A){//返回引用，目的为能够连续读取
is >> A.real_ >> A.imag_;
return is;
}
```
##### 示例4：重载输出运算符`<<`
输出运算符应尽量减少格式化操作，以便让用户能控制输出的细节
```cpp
//对输出运算符>>进行重载，让它能够输出复数
ostream &operator<<(ostream &os, complex &A){
os << A.real_ <<" + "<< A.imag_ <<" i ";
return os;
}
```	
##### 示例5：重载下标运算符`[]`
单目运算符必须以成员函数形式进行重载，`[]`是后置运算符
```cpp
//不仅可以访问元素，还可以修改
int &operator[](int i){
return data_[i];
}
//只能访问不能修改，为了适应const int& Array::operator[](int i)
const int &Array::operator[](int i) const{
return data_[i];
}
```
##### 示例6：重载自增`++`和自减`--`运算符：
对++运算符以成员函数形式进行重载，有前置和后置两种形式
```cpp
A &operator++(); //++i，前置形式。为了与内置保持一致应返回对象的引用
A operator++(int); //i++，后置形式，参数int没有意义，只是为了区分前置和后置
A::A &operator++(){
return run();//run返回增加后的值
}
A::A operator++(int n){
A temp = *this;
run();
return temp;//temp保存原来的值
 }
```	
##### 示例7：重载`new`和`delete`运算符：
可以以成员函数形式或全局函数形式重载`new`运算符，在重载`new`或`new[]`时，无论是作为成员函数还是作为全局函数，它的第一个参数必须是`size_t`类型。`size_t`表示的是要分配空间的大小，对于`new[]`的重载函数而言，`size_t`则表示所需要分配的所有空间的总和。
```cpp
void * className::operator new(size_t size){//成员函数形式
    ...
}
void * operator new(size_t size){//全局函数形式
    ...
}
```		
重载`delete`运算符，两种重载形式的返回值都是`void`类型，并且都必须有一个`void`类型的指针作为参数，该指针指向需要释放的内存空间。
```cpp
void className::operator delete( void *ptr){//成员函数形式
    ...
}
void operator delete( void *ptr){//全局函数形式
    ...
}
```		
