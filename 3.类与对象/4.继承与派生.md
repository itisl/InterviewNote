## 继承与派生
1. 被继承的类称为父类或基类，继承的类称为子类或派生类
2. 派生类包含了全部基类中除构造函数和析构函数外的所有成员
语法：
```cpp
class 派生类名：继承方式 基类名{
    // 派生类新增成员
}；
```
class People{
public:
    void setname(char *name);
    void setage(int age);
private:
    string m_name;
    int m_age;
};
class Student: public People{//单继承时派生类 Student
public:
    void setscore(float score);
    float getscore();
private:
    float m_score;
};
class girl:pubilc People,private Student{//多继承时的派生类girl，尽量不要用多继承
    …//其他语句
};
防止该类被继承：使用关键字final
class People final{…};//People将不能被继承

1. 继承的访问权限：
继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限。基类中的 private 成员在派生类中始终不能在派生类的成员函数中访问或调用，在派生类访问基类private成员的方法是使用基类非private成员函数
继承方式/基类成员	public成员	protected成员	private成员
public继承	public	protected	不可见
protected继承	protected	protected	不可见
private继承	private	private	不可见
改变访问权限：使用using关键字可以改变基类成员在派生类的访问权限
public:
    using People::m_name;
4. 基类成员的遮蔽：
当派生类声明了和基类成员同名的新成员，派生的新成员会遮蔽同名成员（虚函数必须形参列表相同才能覆盖，否则编译器会认为相互独立而遮蔽）。基类成员函数和派生类成员函数不会构成重载。要使用基类中的同名成员：xiaoming.People::f();
final关键字：防止成员函数被覆盖，如：void setname() final;
override关键字：说明该虚函数被覆盖，如果不能覆盖（不是虚函数、形参不对）会出错

二义性	从不同基类继承的同名成员，派生类中没有定义同名成员，要用类名限定：xiaohong.People::f();//或xiaohong.Student::f();
冗余	A1、A2继承了A，B又继承了A1和A2（菱形继承），A中的变量在B就会有两份，产生冗余，也应该加A1::或A2::限定
二义性和冗余应该尽量避免，不要重新定义继承来的非虚函数

• 公有派生类对象可以被当做基类对象使用，反之不行。基类对象名、指针只能使用从基类继承的成员
a. 派生类的对象可以隐含转换为基类对象；
b. 派生类的对象可以初始化基类的引用；
c. 派生类的指针可以隐含转换为基类的指针


## 虚继承：为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。虚派生只影响从指定了虚基类的派生类中进一步派生出来的类D，它不会影响派生类A、B。


b. 虚继承的语法:在继承方式前加上virtual关键字
//虚基类A
class A{
public:
    int x;
};
//虚继承
class B: virtual public A{
    …
};
class C: virtual public A{
    …
};
//只会保留一份间接基类A中的成员
class D: public B, public C{
    …
};
c. 虚继承的变量覆盖
类A和B中都没有定义变量x	x被解析成A的成员，无二义性
类A或B中有一个定义了变量x	x被解析成A或B中的成员变量，A中的被覆盖
类A和B中都定义了变量x	有二义性，必须用::说明x所属的类
d. 虚继承时的构造函数
D::D(int x1,int x2,int x3,int x4):A(x1),B(x2),C(x3),D_x(x4){}
最终派生类不仅需要调用B,C的构造函数，还需要调用间接基类A的构造函数（B,C的构造函数对A的初始化是无效的，只有D有效，普通继承不能调用间接基类）
构造函数的调用顺序：先调用虚基类的构造函数，再按出现顺序调用其他构造函数
e. 向上转型（upcasting）
向上转型	将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用（编译器自动完成）
向下转型	将基类赋值给派生类（需要手动干预）
对象的赋值	赋值是将现有数据写入到已分配的内存中，赋值是成员变量的赋值，成员函数不存在赋值
指针的赋值	指针指向哪个对象就使用哪个对象的数据，指针属于哪个类就使用哪个类的成员函数（虚函数除外）
引用	引用和指针一样

