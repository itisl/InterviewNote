[TOC]
---
## 类成员关键词
---

### `this`关键词：
**作用**：
1. 在类的非静态成员函数中需要返回类对象本身的时候，使用 `return *this;`
2. 当参数与成员变量名相同时，如`this->n = n;` （不能写成`n = n`）
> 1. 用在类的内部，是一个`const`指针，指向当前对象，可以用->来访问当前对象的成员变量或成员函数
> 2. `this`是`const`指针，不能被修改，==只能在成员函数内部使用==，用在其他地方是非法的
> 3. `this`实质上是成员函数的一个形参，在调用成员函数时将对象地址作为实参传递给`this`, 在编译阶段由编译器自动将其添加到参数列表
> 4. `this`是一个右值，不能取得`this`的地址(不能`&this`)

### `inline`关键词
**作用**：`inline`希望编译器能够在编译时将函数在调用的地方展开，能加快运行效率。
在`class`/`struct`/`union`的定义之内定义的函数，无论它是成员函数还是非成员`friend`函数，均为隐式的内联函数
```cpp
// 模板类类外内联函数的定义示例
template<class T>
class shared_ptr
{
public:
    inline T& operator() const;
private:
    T* px;
    long* pn;
};
template<class T>
inline T* shared_ptr<T>::operator->() const{
    return px;
}
```

内联函数比较简单，当形式复杂时，编译器不会将其编译为内联函数


### `const`与`mutable`关键词
`const`可以用来修饰**成员变量**、**成员函数**、**对象**
- `const`**成员变量**：和普通变量用法相似，只能通过参数初始化列表初始化
- `const`**对象**：将对象定义为常对象后，就只能访问被`const`修饰的成员（非`const`成员可能会修改对象数据，编译器是禁止的，因此不改变数据的成员函数必须加`const`）
- `const`**成员函数**（常成员函数）：可以使用类中所有成员变量，但是不能修改它们的值，在定义和声明的时候都要在结尾加上`const`关键词
> 实际上`const`修饰的是隐式的`this`指针

```cpp
int gethour() const; //类内
void Clock::gethour() const{
    return m_hour;
}
```
> 1. `const`成员函数可以使用类中所有成员变量，但是不能修改它们的值
> 2. `const`成员函数声明和定义都必须使用`const`后缀
> 3. `const`对象只能调用`const`成员函数，不能调用非`const`成员函数

**`mutable`**：容许在即便包含它的对象被声明为`const`时仍可修改声明为`mutable`的类成员。如果需要一部分成员变量能在`const`对象中修改，可以加上`mutable`修饰：

```cpp
mutable string cache;
```

### `static`关键词
> ==static数据或函数成员在整个程序中只能有唯一定义==

#### 静态成员变量

**作用**：使用`static`成员变量来实现多个对象共享数据（如计数器）。
> 1. 函数体内`static`变量的作用范围为该函数体, 不同于普通成员变量, 该变量的内存只被分配一次, 因此其值在下次调用时仍维持上次的值
> 2. 在模块内的`static`全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问
> 3. 在类的static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝
> 4. `static`成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。

```cpp
class Clock
{
    ...
public:
    static int count_;
}；
```
**注意事项**：
> - `static`静态成员变量必须在类声明的外部初始化(C++17之前)；
>   ```cpp
>   type class::name = value; //静态成员变量在初始化时不能再加static，但必须要有数据类型
>   ```
> - (C++17)静态数据成员可以声明为`inline`。内联静态数据成员可以在类定义中定义，而且可以指定初始化器，不需要类外定义：
>   ```cpp
>   struct X
>   {
>       inline static int n = 1;
>   };
>   ```
> - `static`成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。没有在类外初始化的 static 成员变量不能使用。
> - `static`成员变量既可以通过对象来访问，也可以通过`classname::member`来访问
> 
#### 静态成员函数
> 没有对象的时候要访问类成员函数的话，只能访问静态成员函数
> 静态成员函数主要目的是访问静态成员变量。
> 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量
> 4. 在模块内的static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内
> 

操作 | 说明
:------- | :-------
**声明和定义** | 类中声明需要`static`，类外定义不能加`static`，但必须要有数据类型
**this指针** | 静态成员函数通过类调用，不属于对象，编译器不会为其增加形参`this`**指针**
**访问** | 不可使用`this`指针，可以通过对象调用，也可以在没有实例化对象时直接调用

### `friend`友元函数
**作用**：可以使其他类中的成员函数或全局函数访问当前类的`private`成员。
1. `friend`的关系不能传递（你朋友的朋友不是你的朋友），也不能被继承（你朋友的孩子不是你的朋友）；
2. `friend`函数没有`this`指针，不能直接访问类的成员，必须借助类的对象访问；
3. 同一个`class`的对象互为`friend`；
4. 一个函数可以被多个类声明为友元函数，这样可以访问多个类中的`private`成员；
5. 访问说明符(`public`，`protect`，`private`)对于友元声明的含义没有影响
#### 1. `friend`函数
1. 将非成员函数声明为`friend`函数：
    ```cpp
    class Clock{
    public:
        friend void show(Clock &ck);
    ...
    };
    void show(Clock &ck){ //非成员函数
        ...
    }
    ```
2. 其他类的成员函数声明为`friend`函数：
    ```cpp
    class Clock{
    ...
    public:
        friend void show(Clock *ptime);
    };//声明Clock类
    class Address{
    ...
    pubilc:
        void show(Clock *ptime);
    };
    ```
#### 2. `friend`类
**友元类**：可以将整个类声明为另一个类的友元（==不建议，只将成员函数声明为友元函数更安全==）
> 1. 友元关系是单向的（你是我的朋友，我不一定是你的）
> 2. 友元类只能声明，不能定义新的类（`friend class X {};` 是错的）

```cpp
class Clock{
 public:
    friend class Address;//Address类声明为Clock的友元类
...
};
```

### `explicit`关键词
**作用**：禁止隐式调用单参数的构造函数，包括：
1. 禁止隐式调用拷贝构造函数
2. 禁止类对象之间的隐式转换(见转换函数)
> - 一般而言，只有单参数的构造函数会用到`explicit`关键字
> - `explicit`指明构造函数不能作隐式类型转换，只能进行初始化和显式类型转换
> - 用`=`进行初始化可看作拷贝初始化，初始化器是右值时可能会采取移动操作。省略`=`会将初始化变为显式初始化
> - ==单参数的构造函数应声明为`explicit`==，避免发生不必要的类型转换，更多可见转换函数
```cpp
class Clock{
public:
	explicit Clock(int d);
};
```
### `virtual`, `override`与`final`关键词
**作用**：
1. **`virtual`函数**(Virtual Function)见[虚函数与多态](5.虚函数与多态.md)。
2. `override`说明该虚函数必须被覆盖
    > 1. 是在**成员函数声明符**之后使用时拥有特殊含义的标识符：其他情况下它不是保留的关键词，如果不能覆盖（不是虚函数、形参不对）会出错
    > 2. 如果没有用`overide`关键字，当虚函数返回类型或参数不一样时将会造成函数的隐藏而不是覆盖
    > 3. 覆盖的方法不能为`private`
3. `final`用来防止成员函数被覆盖:
    ```cpp
    void setname() final;
    ```