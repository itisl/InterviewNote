1. 尽量将数据成员声明为`private`
2. 成员函数定义放到类外(内联函数加`inline`)
   1. 影响可读性
   2. 泄漏类的实现细节
   3. 可能出现重定义错误
3. 不要在构造函数中调用虚函数
   1. 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.
    在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 禁用 了) 等方法的条件下, 构造函数很难上报错误
    如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 bool IsValid() 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.
    构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的.
4. 不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 `explicit` 关键字
5. `struct` vs. `class` 仅当只有数据成员时使用 `struct`, 其它一概使用 `class`(对于仿函数等特性可以不用 `class` 而是使用 `struct`)
6. 使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 `public` 继承 
   1. 组合 > 实现继承 > 接口继承 > 私有继承
   1. 所有继承必须是 `public` 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式
   2. 子类重载的虚函数也要声明` virtual` 关键字(为了表明这是虚函数，编译器允许不声明)

7. 基类的析构函数也应该为虚函数，否则使用基类指针指向派生类对象,`delete`时只会调用基类构造函数不会调用派生类
8. 对于重载的虚函数或虚析构函数, 使用 `override`, 或 (较不常用的) `final` 关键字显式地进行标记
9.  类定义一般应以 `public:` 开始, 后跟 `protected:`, 最后是 `private`:
10. 类定义后面为什么要加分号