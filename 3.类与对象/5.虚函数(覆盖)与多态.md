[TOC]
## 虚函数 
---
**虚函数**是可在派生类中覆盖其行为的成员函数。与非虚函数相反，即使没有关于该类实际类型的编译时信息，仍然保留被覆盖的行为。==虚函数的唯一用途就是构成运行时的多态。==
重载和覆盖的区别
> ```cpp
> 声明符 虚说明符序列(可选) 纯说明符(可选)
> ```
> 虚说明符序列，必须是 `override`、`final`、`final override` 或 `override final`之一
> 1. 非虚(non-`virtual`)函数：不希望派生类重定义(`override`)，普通成员函数
> 2. 虚(`virtual`)函数：希望派生类重新定义，当前类有定义
> 3. 纯虚(pure `virtual`)函数：派生类必须重新定义，而且没有默认定义

### 普通虚函数

```cpp
class A{
public:
    virtual void display();//虚函数的定义
};
class B:public A{
public:
    virtual void display();
};
```
### 纯虚函数

1. 纯虚函数的声明:
```cpp
virtual type FunName(para_list) = 0; //在结尾加上=0告诉编译器这是纯虚函数
```
只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数
1. 抽象类（Abstract Class）：包含纯虚函数的类成为抽象类。
> 一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。纯虚函数没有函数体，因此抽象类无法被实例化(通常没有构造函数)
```cpp
class Line(){
public:
    Line();//默认构造函数
    virtual float area() = 0;//声明这是一个纯虚函数
protected:
    float m_len;
};
class Cube:public Line{
public:
    Cube(float len);
    float area();//纯虚函数在派生类中声明
};
Cube::Cube(float len):Line(len){}
//纯虚函数的定义
float Cube::area(){
    return m_len*m_len;
}
main中：
Line *p = new Cube(5);//纯虚函数可以实现多态
```

> 在抽象基类中不需要或无法实现的功能，可以声明为纯虚函数。纯虚函数为派生类提供了约束，派生类必须完成纯虚函数的功能才能实例化

## 多态
对某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数（virtual function），让基类指针可以访问派生类的成员函数。可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行访问。基类指针可以使用基类的方法，也可以使用派生类的方法，这种多种表现方式成为多态。
指针和引用都可以实现多态，但是引用不如指针灵活

1. 多态的用途：
> 派生类的方法，可以被基类的方法或引用变量调用。而有了多态，只需要一个指针变量 p 就可以调用所有派生类的虚函数。提高可扩充性。
> 同一个函数可以处理多种不同的情况，定义了统一的接口
4. 虚函数注意事项：
1. 只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。
1. 可以只将基类中的函数声明为虚函数，这样所有派生类中具有遮蔽（覆盖）关系1同名函数都将自动成为虚函数。
1. 在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将1用基类的虚函数。
1. 只有派生类的虚函数遮蔽基类的虚函数（函数原型相同）才能构成多态。
1. 构造函数不能是虚函数。因为构造函数不能被继承
1. 析构函数可以声明为虚函数，而且有时候必须被声明成虚函数（析构时防止析构函数只析构基类而不析构派生类）
构成多态的条件：
    a. 必须存在继承关系；
    b. 继承关系中必须有同名的虚函数，并且它们是遮蔽（覆盖）关系。
    c. 存在基类的指针，通过该指针调用虚函数。
虚函数实现：
> 将虚函数名转换为虚函数表(vbtl)中的一个索引，每个虚函数都有自己的vbtl用来标识虚函数



- 橙色线框中的内容仅限于虚拟继承的情形（若无虚拟继承，则无此内容）
- “offset to top”是指到对象起始地址的偏移值，只有多重继承的情形才有可能不为0，单继承或无继承的情形都为0。
- “RTTI information”是一个对象指针，它用于唯一地标识该类型。
“virtual function pointers”也就是我们之前理解的虚函数表，其中存放着虚函数指针列表

## 虚函数表与虚指针
**虚函数实现**：将虚函数名转换为虚函数表(vbtl)中的一个索引，每个虚函数都有自己的vbtl用来标识虚函数
![20190903104536.png](https://raw.githubusercontent.com/itisl/Pic_Bed/master/img/20190903104536.png)


![20190903104551.png](https://raw.githubusercontent.com/itisl/Pic_Bed/master/img/20190903104551.png)
- 橙色线框中的内容仅限于虚拟继承的情形（若无虚拟继承，则无此内容）
- “offset to top”是指到对象起始地址的偏移值，只有多重继承的情形才有可能不为0，单继承或无继承的情形都为0。
- “RTTI information”是一个对象指针，它用于唯一地标识该类型。
“virtual function pointers”也就是我们之前理解的虚函数表，其中存放着虚函数指针列表。