## 构造函数
**构造函数作用**：创建对象时自动执行，用于初始化成员变量。名字和类名相同，无返回值：
> 1. 构造函数没有名字且无法被直接调用。它们在发生初始化时调用，且它们按照初始化的规则进行选择；
> 2. 单参数的构造函数应该声明为`explicit`，避免编译器做类型转换，无`explicit`说明符的构造函数是转换构造函数；
> 3. 有`constexpr`说明符的构造函数令其类型成为字面类型(LiteralType)

```cpp
class Clock{
public:
    Clock(int hour,int minute,int second);//声明构造函数
    Clock();
    void show();
private:
    int hour_;
    int minute_;
    int second_;
};
```
    
### 1. 参数初始化列表：
**初始化列表作用**：在构造函数中对成员变量一一赋值
```cpp
Clock::Clock(int hour,int minute,int second):hour_(hour),minute_(minute), second_(second){};
```
> 1. ==初始化const成员变量只能用参数初始化列表==
> 2. 参数初始化表并没有效率上的优势，仅仅是书写方便
> 3. 参数初始化顺序与初始化表列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关
### 2. 默认构造函数：
作用：
不能定义两个带初始值的默认构造函数（会报错）。程序中已定义构造函数，编译器不再隐含生成，如果希望，可以使用：Clock()=default;调用没有参数的构造函数可以省略括号：Clock today;
=default 可以写在声明处也可以写在定义处
### 3. 拷贝构造函数：
**拷贝构造函数作用**：类内成员变量含指针、动态分配的内存时，必须定义拷贝构造函数进行深拷贝，否则可以不定义。
> 1. 类内成员变量含指针、动态分配的内存时，必须定义拷贝构造函数进行深拷贝；
> 2. 拷贝构造函数和赋值操作`operator=`必须同时给出，见[拷贝与移动](3.拷贝与移动.md)。
> 3. 可以在`private`中加入拷贝构造的声明（不必定义），用来防止默认拷贝。
```cpp
Clock(const Clock &today);//复制构造函数的声明
Clock(const Clock &today)=delete;//指示编译器不生成默认复制构造函数
Clock B = A;   // Clock B(A); 使用拷贝构造函数初始化新对象
```
==**注意：**==
> 1. 拷贝构造函数参数必须是当前类的引用，否则形参会调用拷贝构造函数创建临时对象，陷入死循环；
> 2. 如果不加const限制，将不能拷贝const修饰的对象

### 4. 移动构造函数：
> 3. 移动构造函数和移动赋值操作必须同时给出.
### 5. 转换构造函数：
转换构造函数还作为用户定义的转换序列中的一部分，在复制初始化中受到考虑
隐式声明的及用户定义的非 explicit 复制构造函数与移动构造函数也是转换构造函数
```cpp
// 加上默认参数，构成单参数构造函数
Fraction(int numerator, int denomirator=1)
:numerator_(numerator), denomirator_(denomirator){ };
// 重载 + 操作符
Fraction operator+(){
    return Fraction(...);
}
// 运算时，会将整数当做一个参数
Fraction f(3, 5);
double d = 4 + f; // 调用构造函数将4转换为F(4,1), 然后调用operator+
```

### 6. 委托构造函数：
使用类的其他构造函数执行初始化过程(两个构造函数功能相似时，可以调用减少代码量)
```cpp
Clock::Clock(int hour,int minute,int second):m_hour(hour),m_minute(minute),m_second(second){};
Clock::Clock():m_hour(0),m_minute(0),m_second(0){};//不使用委托构造函数
Clock::Clock():Clock(0,0,0){};//使用委托构造函数
```
### 7. 派生类的构造函数：
类的构造函数不能被继承，可以用using语句继承基类构造函数（只能初始化继承的成员）即使继承了也不能成为派生类的构造函数（最好不用）
`using People::People;
解决方法是在派生类的构造函数中调用基类的构造函数。

`派生类名::派生类名(基类所需的形参，本类成员所需的形参): 基类名(参数表), 本类成员初始化列表`

```cpp
People(std::string name,int age);//基类构造函数声明
Student(std::string name,int age,float score);//派生类构造函数声明
Student::Student(std::string name,int age,float score):
People(name, age), score_(score){
    ... //单继承派生类构造函数的初始化列表
```    
#### 派生类构造函数的执行顺序：
1. 调用基类构造函数：顺序按照继承时声明的顺序
2. 初始化列表成员进行初始化，按照在类中定义的顺序，对象成员初始化自动调用所. 的构造函数
3. 执行派生类的构造函数体
派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的
#### 基类构造函数的调用规则：
定义派生类构造函数时应指明基类构造函数，否则就调用基类的默认构造函数。如果基类没有默认构造函数（定义了其他构造函数，编译器不生成隐含的默认构造函数），编译失败

## 析构函数
**析构函数作用**：用于销毁对象释放内存。
> 1. 一个类只有一个析构函数；
> 2. 析构函数在销毁对象时自动执行，无法显式调用，没有参数和返回值；
> 3. 当类中不存在指针、动态分配内存时，可以不指定析构函数；否则必须指定用来释放掉指针所指向内存，避免内存泄漏

```cpp
Clock::~Clock(){
    delete[] m_arr; //释放申请的数组的内存
} //析构函数定义
```
### 派生类的析构函数：
类的析构函数也不能被继承，与构造函数不同的是，在子类的析构函数中不用显式地调用父类的析构函数。子类的析构函数另外声明定义（若需要）

## 限定符


