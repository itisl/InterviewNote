[TOC]
---
## 类成员关键字
### `this`关键字：
**作用**：
1. 在类的非静态成员函数中需要返回类对象本身的时候，使用 `return *this;`
2. 当参数与成员变量名相同时，如`this->n = n;` （不能写成`n = n`）
> 1. 用在类的内部，是一个`const`指针，指向当前对象，可以用->来访问当前对象的成员变量或成员函数
> 2. `this`是`const`指针，不能被修改，==只能在成员函数内部使用==，用在其他地方是非法的
> 3. `this`实质上是成员函数的一个形参，在调用成员函数时将对象地址作为实参传递给`this`, 在编译阶段由编译器自动将其添加到参数列表
> 4. `this`是一个右值，不能取得`this`的地址(不能`&this`)

### `const关键字`
`const`可以用来修饰成员变量、成员函数、对象
- `const`成员变量：和普通变量用法相似，只能通过参数初始化列表初始化
- `const`对象：将对象定义为常对象后，就只能访问被const修饰的成员（非const成员可能会修改对象数据，编译器是禁止的，因此不改变数据的成员函数必须加const）
- `const`成员函数（常成员函数）：可以使用类中所有成员变量，但是不能修改它们的值，在定义和声明的时候都要在结尾加上const关键字
> 实际上const修饰的是隐式的this指针

```cpp
int gethour() const;//类内
void Clock::gethour() const{
    return m_hour;
}
```

1	const成员函数可以使用类中所有成员变量，但是不能修改它们的值
2	const成员函数声明和定义都必须使用const后缀
3	const对象只能调用const成员函数，不能调用非const成员函数

### `static关键字`
> ==static数据或函数成员在整个程序中只能有唯一定义==

#### 静态成员变量
> static修饰的成员变量是一种特殊的成员变量，可以使用静态成员变量来实现多个对象共享数据（如计数器）。
> 1. 函数体内`static`变量的作用范围为该函数体, 不同于普通成员变量, 该变量的内存只被分配一次, 因此其值在下次调用时仍维持上次的值
> 没有对象的时候要访问类成员函数的话，只能访问静态成员函数
> 3. 在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问
> 4. 在模块内的static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内
> 5. 在类的static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝

```cpp
class Clock
{
    … //其他语句
public:
    static int m_count;
}；
```
> - static静态成员变量必须在类声明的外部初始化()；
>   ```cpp
>   type class::name = value;//静态成员变量在初始化时不能再加 static，但必须要有数据类型
>   ```
> - static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。没有在类外初始化的 static 成员变量不能使用。
> - static 成员变量既可以通过对象来访问，也可以通过`classname::member`来访问
> 
static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。
#### 静态成员函数
> 静态成员函数主要目的是访问静态成员变量。
> 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量

操作 | 说明
:------- | :-------
**声明和定义** | 类中声明需要static，类外定义不能加static，但必须要有数据类型
**this指针** | 静态成员函数通过类调用，不属于对象，编译器不会为其增加形参**this指针**
**访问** | 不可使用this指针，可以通过对象调用，也可以在没有实例化对象时直接调用

### `friend`友元
**友元函数作用**：可以使其他类中的成员函数或全局函数访问当前类的private成员。
1. `friend`的关系不能传递（你朋友的朋友不是你的朋友），也不能被继承（你朋友的孩子不是你的朋友）；
2. `friend`函数没有`this`指针，不能直接访问类的成员，必须借助类的对象访问；
3. 同一个`class`的对象互为`friend`；
4. 一个函数可以被多个类声明为友元函数，这样可以访问多个类中的`private`成员；
5. 访问说明符(`public`，`protect`，``)对于友元声明的含义没有影响
#### `friend`函数
1. 将非成员函数声明为`friend`函数：
    ```cpp
    class Clock{
    public:
        friend void show(Clock &ck);
    ...
    };
    void show(Clock &ck){ //非成员函数
        ...
    }
    ```
2. 其他类的成员函数声明为`friend`函数：
    ```cpp
    class Clock{
    ...
    public:
        friend void show(Clock *ptime);
    };//声明Clock类
    class Address{
    ...
    pubilc:
        void show(Clock *ptime);
    };
    ```
#### 友元类
**友元类**：可以将整个类声明为另一个类的友元（==不建议，只将成员函数声明为友元函数更安全==）
> 1. 友元关系是单向的（你是我的朋友，我不一定是你的）
> 2. 友元类只能声明，不能定义新的类（`friend class X {};` 是错的）

```cpp
class Clock{
 public:
    friend class Address;//Address类声明为Clock的友元类
...
};
```


### `explicit`与构造函数

> - explicit指明构造函数不能作隐式类型转换，只能用于初始化和显式类型转换
> - 用 = 进行初始化可看作拷贝初始化，初始化器是右值时可能会采取移动操作。省略= 会将初始化变为显式初始化
> - ==单参数的构造函数应声明为explicit==，避免发生不必要的类型转换
```cpp
class Clock{
public:
	explicit Clock(int d);
};

```
### `mutable`
如果需要一部分成员变量能在const对象中修改，可以加上`mutable`修饰

```cpp
mutable string cache;
```
